<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gcc的博客</title>
  
  <subtitle>永远保持对技术的热爱</subtitle>
  <link href="https://gccforstudy.github.io/atom.xml" rel="self"/>
  
  <link href="https://gccforstudy.github.io/"/>
  <updated>2023-04-13T02:16:35.909Z</updated>
  <id>https://gccforstudy.github.io/</id>
  
  <author>
    <name>gcc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C程序设计语言学习感想</title>
    <link href="https://gccforstudy.github.io/2023/04/13/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/"/>
    <id>https://gccforstudy.github.io/2023/04/13/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/</id>
    <published>2023-04-13T02:14:30.000Z</published>
    <updated>2023-04-13T02:16:35.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-导言"><a href="#第一章-导言" class="headerlink" title="第一章 导言"></a>第一章 导言</h2><span id="more"></span><h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><h4 id="1-20"><a href="#1-20" class="headerlink" title="1-20"></a>1-20</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABINC 3</span></span><br><span class="line"></span><br><span class="line"> main() &#123;</span><br><span class="line"> <span class="type">int</span> c, nb, pos;</span><br><span class="line"> nb = <span class="number">0</span>;</span><br><span class="line"> pos = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> ((c = getchar()) != EOF) &#123;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"> nb = TABINC - (pos - <span class="number">1</span>) % TABINC;</span><br><span class="line"> <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"> <span class="keyword">while</span> (nb &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"> nb--;</span><br><span class="line"> pos++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"> <span class="built_in">putchar</span>(c);</span><br><span class="line"> pos = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">putchar</span>(c);</span><br><span class="line"> pos++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-21"><a href="#1-21" class="headerlink" title="1-21"></a>1-21</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define TABINC <span class="number">3</span></span><br><span class="line"></span><br><span class="line"> main() &#123;</span><br><span class="line"> <span class="type">int</span> c, nb, nt, pos;</span><br><span class="line"> nb = <span class="number">0</span>;</span><br><span class="line"> nt = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (pos = <span class="number">1</span>; (c = getchar()) != EOF; ++pos) &#123;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (pos % TABINC != <span class="number">0</span>)</span><br><span class="line"> ++nb;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> nb = <span class="number">0</span>;</span><br><span class="line"> ++nt;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (; nt &gt; <span class="number">0</span>; --nt)</span><br><span class="line"> putchar(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"> nb = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">for</span> (; nb &gt; <span class="number">0</span>; --nb)</span><br><span class="line"> putchar(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"> putchar(c);</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> pos = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"> pos = pos * (TABINC - (pos - <span class="number">1</span>) % TABINC) - <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二章-类型、运算符与表达式"><a href="#第二章-类型、运算符与表达式" class="headerlink" title="第二章 类型、运算符与表达式"></a>第二章 类型、运算符与表达式</h2><h3 id="2-1-变量名"><a href="#2-1-变量名" class="headerlink" title="2.1 变量名"></a>2.1 变量名</h3><p>名字是由字母和数字组成的序列，但其第一个字符必须为字母。下划线”_”被看做是字母。库例程的名字常以下划线开头，因此变量名不要以下划线开头。大写字母和小写字母是有区别的，对于内部名而言，至少前31个字符是有效的。对于外部名，ANSI标准保证前6个字符的唯一性，且不区分大小写。</p><h3 id="2-2-数据类型及长度"><a href="#2-2-数据类型及长度" class="headerlink" title="2.2 数据类型及长度"></a>2.2 数据类型及长度</h3><table><thead><tr><th align="center">数据类型</th><th align="center">位宽</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1个字节</td></tr><tr><td align="center">int</td><td align="center">16或32位</td></tr><tr><td align="center">float</td><td align="center"></td></tr><tr><td align="center">double</td><td align="center"></td></tr><tr><td align="center">long double</td><td align="center"></td></tr><tr><td align="center">short || short int</td><td align="center">通常16位，小于int</td></tr><tr><td align="center">long || long int</td><td align="center">通常32位，大于int</td></tr></tbody></table><h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2-1"></a>练习2-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> main() &#123;</span><br><span class="line"> <span class="comment">//signed types</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed char min = %d\n&quot;</span>, SCHAR_MIN);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed char max = %d\n&quot;</span>, SCHAR_MAX);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed short min = %d\n&quot;</span>, SHRT_MIN);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed short max = %d\n&quot;</span>, SHRT_MAX);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed int min = %d\n&quot;</span>, INT_MIN);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed int max = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed long min = %ld\n&quot;</span>, LONG_MIN);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;signed long max = %ld\n&quot;</span>, LONG_MAX);</span><br><span class="line"> <span class="comment">//unsigned types</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;unsigned char max = %u\n&quot;</span>, UCHAR_MAX);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;unsigned short max = %u\n&quot;</span>, USHRT_MAX);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;unsigned int max = %u\n&quot;</span>, UINT_MAX);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;unsigned long max = %lu\n&quot;</span>, ULONG_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不同硬件上的数据长度都在limits.h和float.h头文件中</p></blockquote><h3 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3 常量"></a>2.3 常量</h3><p>类似于1 2 3 4的整数常量属于int类型。long类型的常量以字母l或L结尾，无符号常量常以字母u或U结尾。后缀ul或UL表明是unsigned long类型。</p><p>没有后缀的浮点数常量为double类型，后缀f或F表示float类型，而后缀l或L表示long double。带前缀0的整形常量表示它为八进制形式，前缀为0x或0X，则表示它为十六进制形式。</p><p>字符常量，’\ooo’，ooo代表1~3个八进制数，’\xhh’，hh是一个或多个十六进制数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VTAB <span class="string">&#x27;\013&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BELL <span class="string">&#x27;\007&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VTAB <span class="string">&#x27;\xb&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BELL <span class="string">&#x27;\x7&#x27;</span></span></span><br></pre></td></tr></table></figure><p>![](C程序设计语言学习感想&#x2F;ANSI C的转义字符.png)</p><p>字符常量’\0’表示值为0的字符，也就是空字符null。常量表达式是仅仅只包含常量的表达式。这种表达式在编译时求值而不是在运行时求值。</p><p>字符串常量也叫做字符串字面值，是用双引号括起来的0个或多个字符组成的字符序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> <span class="comment">//空串</span></span><br><span class="line"><span class="string">&quot;I am a string&quot;</span></span><br><span class="line"><span class="string">&quot;hello, &quot;</span> <span class="string">&quot;world&quot;</span> <span class="comment">//等价于下边,相当于字符串的拼接</span></span><br><span class="line"><span class="string">&quot;hello, world&quot;</span> </span><br></pre></td></tr></table></figure><p>枚举常量是另外一种类型的常量。枚举是一种常量整形值的列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">boolean</span> &#123;</span>NO, YES&#125;; <span class="comment">//默认NO = 0, YES = 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">escapes</span> &#123;</span> BELL = <span class="string">&#x27;\a&#x27;</span>, BACKSPACE = <span class="string">&#x27;\b&#x27;</span>, TAB = <span class="string">&#x27;\t&#x27;</span>, </span><br><span class="line">                  NEWLINE = <span class="string">&#x27;\n&#x27;</span>, VTAB = <span class="string">&#x27;\v&#x27;</span>, RETURN = <span class="string">&#x27;\r&#x27;</span> &#125;; </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">months</span> &#123;</span> JAN = <span class="number">1</span>, FEB, MAR, APR, MAY, JUN, </span><br><span class="line">                 JUL, AUG, SEP, OCT, NOV, DEC &#125;; </span><br><span class="line">                       <span class="comment">/* FEB = 2, MAR = 3, etc. */</span> </span><br></pre></td></tr></table></figure><p>枚举类型为建立常量值与名字之间的关联提供了一种便利的方式。</p><h3 id="2-4-声明"><a href="#2-4-声明" class="headerlink" title="2.4 声明"></a>2.4 声明</h3><p>所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一起声明</span></span><br><span class="line"><span class="type">int</span> lower, upper, step;</span><br><span class="line"><span class="type">char</span> c, line[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">// 分开声明</span></span><br><span class="line"><span class="type">int</span> lower;</span><br><span class="line"><span class="type">int</span> upper;</span><br><span class="line"><span class="type">int</span> step;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> line[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">// 可以在声明的同时对变量进行初始化</span></span><br><span class="line"><span class="type">char</span> esc = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> limit = MAXLINE + <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> eps = <span class="number">1.0e-5</span>;</span><br></pre></td></tr></table></figure><p>任何变量的声明都可以使用const限定符限定。该限定符指定变量的值不能被修改。对于数组而言，const限定符指定数组所有元素的值都不能被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> e = <span class="number">2.71828</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> msg[] = <span class="string">&quot;warning: &quot;</span>;</span><br></pre></td></tr></table></figure><p>const限定符也可配合数组参数使用，它表明函数不能修改数组元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>[])</span></span><br></pre></td></tr></table></figure><h3 id="2-5-算术运算符"><a href="#2-5-算术运算符" class="headerlink" title="2.5 算术运算符"></a>2.5 算术运算符</h3><p>二元算术运算符包括：+、-、*、&#x2F;、%</p><h3 id="2-6-关系运算符与逻辑运算符"><a href="#2-6-关系运算符与逻辑运算符" class="headerlink" title="2.6 关系运算符与逻辑运算符"></a>2.6 关系运算符与逻辑运算符</h3><p>关系运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;= &lt; &lt;= == !=</span><br></pre></td></tr></table></figure><p>逻辑运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; || !</span><br></pre></td></tr></table></figure><p>根据定义，在关系表达式或逻辑表达式中，如果关系为真，则表达式的结果值为数值1；如果为假，则结果值为数值0。</p><p>逻辑非运算符!的作用是将非0操作数转换为0，将操作数0转换为1。</p><h3 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2-2"></a>练习2-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价程序如下</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; lim<span class="number">-1</span> &amp;&amp; (c=getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF; ++i) </span><br><span class="line">       s[i] = c; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">loop</span> &#123;</span>NO, YES&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">loop</span> <span class="title">okloop</span> =</span> YES;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (okloop == YES) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= lim - <span class="number">1</span>) </span><br><span class="line">        okloop = NO;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((c = getchar()) == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        okloop = NO;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == EOF)</span><br><span class="line">        okloop = NO;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s[i] = c;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-类型转换"><a href="#2-7-类型转换" class="headerlink" title="2.7  类型转换"></a>2.7  类型转换</h3><p>当一个运算符的几个操作数类型不同时，就需要通过一些规则把它们转换为某种共同的类型。一般来说，自动转换是指把<strong>比较窄的</strong>操作数转换为<strong>比较宽的</strong>操作数，并且不丢失信息的转换。</p><p>标准头文件&lt;ctype.h&gt;定义了一组与字符集无关的测试和转换函数。C语言没有规定char类型的变量是无符号变量还是有符号变量。当把一个char类型的值转换为int类型的值时，对于不同的机器，其结果不一样。（取决于符号填充还是零填充）</p><p>赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式结果的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(类型名)表达式 <span class="comment">// 强制类型转换 </span></span><br></pre></td></tr></table></figure><h3 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2-3"></a>练习2-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">htoi</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> hexdigit, inhex, i, n;</span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"> ++i;</span><br><span class="line"> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;x&#x27;</span> || s[i] == <span class="string">&#x27;X&#x27;</span>) </span><br><span class="line"> ++i;</span><br><span class="line"> &#125;</span><br><span class="line"> n = <span class="number">0</span>;</span><br><span class="line"> inhex = YES;</span><br><span class="line"> <span class="keyword">for</span> (; inhex == YES; ++i) &#123;</span><br><span class="line"> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"> hexdigit = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"> hexdigit = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"> hexdigit = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> inhex = NO;</span><br><span class="line"> <span class="keyword">if</span> (inhex == YES)</span><br><span class="line"> n = <span class="number">16</span> * n + hexdigit;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-自增运算符与自减运算符"><a href="#2-8-自增运算符与自减运算符" class="headerlink" title="2.8 自增运算符与自减运算符"></a>2.8 自增运算符与自减运算符</h3><p>自增与自减运算符只能作用于变量，不用作用于表达式。</p><h3 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2-4"></a>练习2-4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">squeeze</span><span class="params">(<span class="type">char</span> s1[], <span class="type">char</span> s2[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, k;</span><br><span class="line"> <span class="keyword">for</span> (i = k = <span class="number">0</span>; s1[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; s2[j] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s2[j] != s1[i]; j++)</span><br><span class="line"> ;</span><br><span class="line"> <span class="keyword">if</span> (s2[j] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"> s1[k++] = s1[i];</span><br><span class="line"> &#125;</span><br><span class="line"> s1[k] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2-5"></a>练习2-5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">any</span><span class="params">(<span class="type">char</span> s1[], <span class="type">char</span> s2[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; s1[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; s2[j] != <span class="string">&#x27;\0&#x27;</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) </span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-按位运算符"><a href="#2-9-按位运算符" class="headerlink" title="2.9 按位运算符"></a>2.9 按位运算符</h3><p>C语言提供了6个位操作运算符。这些运算符只能作用域整形操作数，无符号数或有符号数都可以。</p><table><thead><tr><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">位与</td></tr><tr><td align="center">|</td><td align="center">位或</td></tr><tr><td align="center">^</td><td align="center">位异或</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td></tr><tr><td align="center">~</td><td align="center">按位求反</td></tr></tbody></table><h3 id="练习2-6"><a href="#练习2-6" class="headerlink" title="练习2-6"></a>练习2-6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置从0开始算</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">setbits</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> p, <span class="type">int</span> n, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x &amp; ~(~(~<span class="number">0</span> &lt;&lt; n) &lt;&lt; (p + <span class="number">1</span> - n)) | (y &amp; ~(~<span class="number">0</span> &lt;&lt; n)) &lt;&lt; (p + <span class="number">1</span> - n);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="练习2-7"><a href="#练习2-7" class="headerlink" title="练习2-7"></a>练习2-7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">invert</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x ^ ((~(~<span class="number">0</span> &lt;&lt; n)) &lt;&lt; (p + <span class="number">1</span> - n));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="练习2-8"><a href="#练习2-8" class="headerlink" title="练习2-8"></a>练习2-8</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wordLength</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">unsigned</span> v = (<span class="type">unsigned</span>)~<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; (v = v &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span>; i++)</span><br><span class="line"> ;</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">unsigned</span> <span class="title function_">rightrot</span><span class="params">(<span class="type">unsigned</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"> <span class="type">int</span> len = wordLength();</span><br><span class="line"> <span class="type">int</span> rbit;</span><br><span class="line"> <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> rbit = (x &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>);</span><br><span class="line"> x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line"> x = x | rbit;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-赋值运算符与表达式"><a href="#2-10-赋值运算符与表达式" class="headerlink" title="2.10 赋值运算符与表达式"></a>2.10 赋值运算符与表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">2</span>;</span><br><span class="line">i += <span class="number">2</span>; <span class="comment">// 赋值运算符</span></span><br></pre></td></tr></table></figure><h3 id="练习2-9"><a href="#练习2-9" class="headerlink" title="练习2-9"></a>练习2-9</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitcount</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line"> <span class="type">int</span> b;</span><br><span class="line"> <span class="keyword">for</span> (b = <span class="number">0</span>; x != <span class="number">0</span>; x &amp;= (x - <span class="number">1</span>))</span><br><span class="line"> b++;</span><br><span class="line"> <span class="keyword">return</span> b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-11条件表达式"><a href="#2-11条件表达式" class="headerlink" title="2.11条件表达式"></a>2.11条件表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 ? expr2 : expr3</span><br></pre></td></tr></table></figure><h3 id="习题2-10"><a href="#习题2-10" class="headerlink" title="习题2-10"></a>习题2-10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line"> s[i] = (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) ? (<span class="string">&#x27;a&#x27;</span> + s[i] - <span class="string">&#x27;A&#x27;</span>) : s[i];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-控制流"><a href="#第三章-控制流" class="headerlink" title="第三章 控制流"></a>第三章 控制流</h2><h3 id="3-1语句与程序块"><a href="#3-1语句与程序块" class="headerlink" title="3.1语句与程序块"></a>3.1语句与程序块</h3><p>用一对花括号”{“与”}”把一组声明和语句括在一起就构成了一个符合语句（也叫作程序块）。</p><h3 id="3-2if-else语句"><a href="#3-2if-else语句" class="headerlink" title="3.2if-else语句"></a>3.2if-else语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式) 等价于 <span class="keyword">if</span>(表达式!=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>建议在有if语句嵌套的情况下使用花括号</p><h3 id="3-3else-if语句"><a href="#3-3else-if语句" class="headerlink" title="3.3else-if语句"></a>3.3else-if语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式)</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句</span><br></pre></td></tr></table></figure><h3 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3-1"></a>练习3-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binsearch</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"> <span class="type">int</span> low, high, mid;</span><br><span class="line"> low = <span class="number">0</span>;</span><br><span class="line"> high = n - <span class="number">1</span>;</span><br><span class="line"> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">while</span> (low &lt;= high &amp;&amp; x != v[mid]) &#123;</span><br><span class="line"> <span class="keyword">if</span> (x &lt; v[mid])</span><br><span class="line"> high = mid - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> low = mid + <span class="number">1</span>;</span><br><span class="line"> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (v[mid] == x)</span><br><span class="line"> <span class="keyword">return</span> mid;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-switch语句"><a href="#3-4-switch语句" class="headerlink" title="3.4 switch语句"></a>3.4 switch语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line">   main()  <span class="comment">/* count digits, white space, others */</span> </span><br><span class="line">   &#123; </span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> c, i, nwhite, nother, ndigit[<span class="number">10</span>]; </span><br><span class="line"> </span><br><span class="line">       nwhite = nother = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">           ndigit[i] = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">while</span> ((c = getchar()) != EOF) &#123; </span><br><span class="line">           <span class="keyword">switch</span> (c) &#123; </span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: </span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>: </span><br><span class="line"></span><br><span class="line">               ndigit[c-<span class="string">&#x27;0&#x27;</span>]++; </span><br><span class="line"></span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: </span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>: </span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: </span><br><span class="line">               nwhite++; </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">           <span class="keyword">default</span>: </span><br><span class="line">               nother++; </span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;digits =&quot;</span>); </span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, ndigit[i]); </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;, white space = %d, other = %d\n&quot;</span>, </span><br><span class="line">           nwhite, nother); </span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>switch case用法示例</p></blockquote><p>在switch语句中，case的作用只是一个标号，因此，某个分支中的代码执行完后，程序将进入下一个分支继续执行，除非在程序中显示地跳转。</p><h3 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3-2"></a>练习3-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">escape</span><span class="params">(<span class="type">char</span> s[], <span class="type">char</span> t[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j;</span><br><span class="line"> <span class="keyword">for</span> (i = j = <span class="number">0</span>; t[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">switch</span> (t[i])</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line"> s[j++] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"> s[j++] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line"> s[j++] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"> s[j++] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> s[j++] = t[i];</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> s[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unescape</span><span class="params">(<span class="type">char</span> s[], <span class="type">char</span> t[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j;</span><br><span class="line"> <span class="keyword">for</span> (i = j = <span class="number">0</span>; t[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (t[i] != <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line"> s[j++] = t[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (t[++i])</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line"> s[j++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line"> s[j++] = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> s[j++] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"> s[j++] = t[i];</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> s[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-while循环和for循环"><a href="#3-5-while循环和for循环" class="headerlink" title="3.5 while循环和for循环"></a>3.5 while循环和for循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (expr1; expr2; expr3) </span><br><span class="line">       statement </span><br><span class="line"><span class="comment">//上下是等价的</span></span><br><span class="line"> expr1; </span><br><span class="line"> <span class="keyword">while</span> (expr2) &#123; </span><br><span class="line">       statement </span><br><span class="line">       expr3; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>把循环控制部分集中在一起，对于多重嵌套循环，优势更为明显。</p><h3 id="练习3-3"><a href="#练习3-3" class="headerlink" title="练习3-3"></a>练习3-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="type">char</span> s1[], <span class="type">char</span> s2[])</span> &#123;</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> <span class="type">int</span> i, j;</span><br><span class="line"> i = j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ((c = s1[i++]) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (s1[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; s1[i + <span class="number">1</span>] &gt;= c) &#123;</span><br><span class="line"> i++;</span><br><span class="line"> <span class="keyword">while</span> (c &lt; s1[i])</span><br><span class="line"> s2[j++] = c++;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> s2[j++] = c;</span><br><span class="line"> &#125;</span><br><span class="line"> s2[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-do-while循环"><a href="#3-6-do-while循环" class="headerlink" title="3.6 do-while循环"></a>3.6 do-while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p>经验表明，do-while循环比while循环和for循环用得少得多。</p><h3 id="练习3-4"><a href="#练习3-4" class="headerlink" title="练习3-4"></a>练习3-4</h3><p>首先，我们必须了解这样一个事实：</p><p>-（2^字长^^-1^）无法通过 n &#x3D; - n转化为一个正数，这是因为对二的补码所能表示的最大正数只能是（2^字长^^-1^) - 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> abs(x) ((x) &lt; 0 ? -(x) : (x))</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j;</span><br><span class="line"> <span class="type">char</span> temp;</span><br><span class="line"></span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"> ++i;</span><br><span class="line"> --i;</span><br><span class="line"> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> --i;</span><br><span class="line"> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (j &lt; i) &#123;</span><br><span class="line"> temp = s[j];</span><br><span class="line"> s[j] = s[i];</span><br><span class="line"> s[i] = temp;</span><br><span class="line"> --i;</span><br><span class="line"> ++j;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> s[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i,sign;</span><br><span class="line"> sign = n;</span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line"> s[i++] = <span class="built_in">abs</span>(n % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> &#125; <span class="keyword">while</span> ((n /= <span class="number">10</span>) != <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (sign &lt; <span class="number">0</span>)</span><br><span class="line"> s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"> s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> reverse(s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="练习3-5"><a href="#练习3-5" class="headerlink" title="练习3-5"></a>练习3-5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> abs(x) ((x) &lt; 0 ? -(x) : (x))</span></span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j;</span><br><span class="line"> <span class="type">char</span> temp;</span><br><span class="line"></span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"> ++i;</span><br><span class="line"> --i;</span><br><span class="line"> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> --i;</span><br><span class="line"> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (j &lt; i) &#123;</span><br><span class="line"> temp = s[j];</span><br><span class="line"> s[j] = s[i];</span><br><span class="line"> s[i] = temp;</span><br><span class="line"> --i;</span><br><span class="line"> ++j;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">itob</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> s[], <span class="type">int</span> b)</span> &#123;</span><br><span class="line"> <span class="type">int</span> i, j, sign;</span><br><span class="line"> sign = n;</span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line"> j = <span class="built_in">abs</span>(n % b);</span><br><span class="line"> s[i++] = (j &lt;= <span class="number">9</span>) ? j + <span class="string">&#x27;0&#x27;</span> : j  + <span class="string">&#x27;a&#x27;</span> - <span class="number">10</span>;</span><br><span class="line"> &#125; <span class="keyword">while</span> ((n /= b) != <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (sign &lt; <span class="number">0</span>)</span><br><span class="line"> s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"> s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> reverse(s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="练习3-6"><a href="#练习3-6" class="headerlink" title="练习3-6"></a>练习3-6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">itoa</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> s[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i,sign;</span><br><span class="line"> sign = n;</span><br><span class="line"> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line"> s[i++] = <span class="built_in">abs</span>(n % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> &#125; <span class="keyword">while</span> ((n /= <span class="number">10</span>) != <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (sign &lt; <span class="number">0</span>)</span><br><span class="line"> s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; w)</span><br><span class="line">        s[i++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"> s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> reverse(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-break语句与continue语句"><a href="#3-7-break语句与continue语句" class="headerlink" title="3.7 break语句与continue语句"></a>3.7 break语句与continue语句</h3><p>break语句可以用于从for、while与do-while等循环提前退出。continue语句与break语句相关联，但它没有break语句常用。continue语句用于使for、while或do-while语句开始下一次循环的执行。</p><h3 id="3-8-goto语句与标号"><a href="#3-8-goto语句与标号" class="headerlink" title="3.8 goto语句与标号"></a>3.8 goto语句与标号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ... ) </span><br><span class="line">          <span class="keyword">for</span> ( ... ) &#123; </span><br><span class="line">              ... </span><br><span class="line">              <span class="keyword">if</span> (disaster) </span><br><span class="line"></span><br><span class="line">                  <span class="keyword">goto</span> error; </span><br><span class="line"></span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">      ... </span><br><span class="line">  error: <span class="comment">// 标号</span></span><br><span class="line">      <span class="comment">/* clean up the mess */</span></span><br></pre></td></tr></table></figure><p>所有使用了got语句的程序代码都能改写成不带goto语句的程序，但可能会增加一些额外的重复测试或变量。</p><h2 id="第四章-函数与程序结构"><a href="#第四章-函数与程序结构" class="headerlink" title="第四章 函数与程序结构"></a>第四章 函数与程序结构</h2><h3 id="4-1-函数的基础知识"><a href="#4-1-函数的基础知识" class="headerlink" title="4.1 函数的基础知识"></a>4.1 函数的基础知识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MAXLINE 1000 <span class="comment">/* maximum input line length */</span> </span></span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> <span class="title function_">getline</span><span class="params">(<span class="type">char</span> line[], <span class="type">int</span> max)</span> </span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">strindex</span><span class="params">(<span class="type">char</span> source[], <span class="type">char</span> searchfor[])</span>; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> pattern[] = <span class="string">&quot;ould&quot;</span>;   <span class="comment">/* pattern to search for */</span> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* find all lines matching pattern */</span> </span><br><span class="line">   main() </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">char</span> line[MAXLINE]; </span><br><span class="line">       <span class="type">int</span> found = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (getline(line, MAXLINE) &gt; <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">if</span> (strindex(line, pattern) &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, line); </span><br><span class="line">               found++; </span><br><span class="line">           &#125; </span><br><span class="line">       <span class="keyword">return</span> found; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* getline:  get line into s, return length */</span> </span><br><span class="line">   <span class="type">int</span> <span class="title function_">getline</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> lim)</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">int</span> c, i; </span><br><span class="line"> </span><br><span class="line">       i = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">while</span> (--lim &gt; <span class="number">0</span> &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">           s[i++] = c; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line">           s[i++] = c; </span><br><span class="line">  <span class="number">64</span> </span><br><span class="line">       s[i] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">       <span class="keyword">return</span> i; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* strindex:  return index of t in s, -1 if none */</span> </span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">strindex</span><span class="params">(<span class="type">char</span> s[], <span class="type">char</span> t[])</span> </span><br><span class="line"></span><br><span class="line">   &#123; </span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> i, j, k; </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123; </span><br><span class="line">           <span class="keyword">for</span> (j=i, k=<span class="number">0</span>; t[k]!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; s[j]==t[k]; j++, k++) </span><br><span class="line">               ; </span><br><span class="line">           <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; t[k] == <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">               <span class="keyword">return</span> i; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数的例子</p></blockquote><p>函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>-type function-name(argument declarations) </span><br><span class="line">&#123; </span><br><span class="line">    declarations and statements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数定义中省略了返回值类型，则默认为int类型。函数之间的通信可以通过参数、函数返回值以及外部变量进行。</p><h3 id="练习4-1"><a href="#练习4-1" class="headerlink" title="练习4-1"></a>练习4-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strrindex</span><span class="params">(<span class="type">char</span> s[], <span class="type">char</span> t[])</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = i, k = <span class="number">0</span>; t[k] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s[j] == t[k]; k++, j++)</span><br><span class="line">;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; t[k] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-返回非整型值的函数"><a href="#4-2-返回非整型值的函数" class="headerlink" title="4.2  返回非整型值的函数"></a>4.2  返回非整型值的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* atof:  convert string s to double */</span> </span><br><span class="line">  <span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">char</span> s[])</span> </span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line"></span><br><span class="line">      <span class="type">double</span> val, power; </span><br><span class="line">      <span class="type">int</span> i, sign; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="built_in">isspace</span>(s[i]); i++)  <span class="comment">/* skip white space */</span> </span><br><span class="line">          ; </span><br><span class="line">      sign = (s[i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) </span><br><span class="line">          i++; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (val = <span class="number">0.0</span>; <span class="built_in">isdigit</span>(s[i]); i++) </span><br><span class="line"></span><br><span class="line">          val = <span class="number">10.0</span> * val + (s[i] - <span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">          i++; </span><br><span class="line">      <span class="keyword">for</span> (power = <span class="number">1.0</span>; <span class="built_in">isdigit</span>(s[i]); i++) &#123; </span><br><span class="line">          val = <span class="number">10.0</span> * val + (s[i] - <span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">          power *= <span class="number">10</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> sign * val / power; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果函数带有参数，则要声明它们；如果没有参数，则使用void进行声明。</p><h3 id="练习4-2"><a href="#练习4-2" class="headerlink" title="练习4-2"></a>练习4-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">char</span> s[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> val, power;</span><br><span class="line">    <span class="type">int</span> i, sign, <span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="built_in">isspace</span>(s[i]); i++)  <span class="comment">/* skip white space */</span></span><br><span class="line">        ;</span><br><span class="line">    sign = (s[i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span> (val = <span class="number">0.0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">        val = <span class="number">10.0</span> * val + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span> (power = <span class="number">1.0</span>; <span class="built_in">isdigit</span>(s[i]); i++) &#123;</span><br><span class="line">        val = <span class="number">10.0</span> * val + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        power *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    val = sign * val / power;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        sign = (s[++i] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">            <span class="built_in">exp</span> = <span class="number">10</span> * <span class="built_in">exp</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">exp</span>-- &gt; <span class="number">0</span>)</span><br><span class="line">                val *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">exp</span>-- &gt; <span class="number">0</span>)</span><br><span class="line">                val /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-外部变量"><a href="#4-3-外部变量" class="headerlink" title="4.3 外部变量"></a>4.3 外部变量</h3><p>外部变量的用途表现在它们与内部变量相比具有更大的作用域和更长的生存期。自动变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时变量也将消息。而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。</p><h3 id="4-4-作用域规则"><a href="#4-4-作用域规则" class="headerlink" title="4.4 作用域规则"></a>4.4 作用域规则</h3><p>外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。</p><p>将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此以外还将引起存储器的分类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果将下列语句放在所有函数的外部，将为之分配存储单元</span></span><br><span class="line"><span class="type">int</span> sp;</span><br><span class="line"><span class="type">double</span> val[MAXVAL];</span><br><span class="line"><span class="comment">//只声明，但不分配存储单元</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sp;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> val[];</span><br></pre></td></tr></table></figure><p>在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过extern声明来访问它（定义外部变量的源文件也可以包含对该外部变量的extern声明）。外部变量的定义中必须指定数组的长度，但extern声明则不一定要指定数组的长度。</p><h3 id="4-5-头文件"><a href="#4-5-头文件" class="headerlink" title="4.5 头文件"></a>4.5 头文件</h3><p><img src="%E5%A4%B4%E6%96%87%E4%BB%B6.png"></p><p>对于某些中等规模的程序，最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要使用更多的头文件，我们需要精心地组织它们。</p><h3 id="4-6-静态变量"><a href="#4-6-静态变量" class="headerlink" title="4.6 静态变量"></a>4.6 静态变量</h3><p>用static声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[BUFSIZE];  <span class="comment">/* buffer for ungetch */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufp = <span class="number">0</span>;       <span class="comment">/* next free position in buf */</span></span><br></pre></td></tr></table></figure><p>外部的static声明通常多用于变量，当然，它也可用于声明函数。通常情况下，函数名字是全局可访问的，对整个程序的各个部分而言都是可见。但是如果把函数声明为static类型，则该函数名除了对该函数声明所在的文件可见外，其他文件都无法访问。</p><p>static也可用于声明内部变量。static类型的内部变量同自动变量一样，是某个特点函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其所在的函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，static类型的内部变量是一种只能在某个特定函数中使用但一直占据空间的变量。</p><h3 id="练习4-11"><a href="#练习4-11" class="headerlink" title="练习4-11"></a>练习4-11</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">getch</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line">  <span class="type">void</span> <span class="title function_">ungetch</span><span class="params">(<span class="type">int</span>)</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* getop:  get next character or numeric operand */</span> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">getop</span><span class="params">(<span class="type">char</span> s[])</span> </span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line">      <span class="type">int</span> i, c; </span><br><span class="line">      <span class="type">static</span> <span class="type">int</span> lastc = <span class="number">0</span>; <span class="comment">//改动在这里</span></span><br><span class="line">      <span class="keyword">if</span> (lastc == <span class="number">0</span>)</span><br><span class="line">          c = getch();</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          c = lastc;</span><br><span class="line">          lastc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> ((s[<span class="number">0</span>] = c = getch()) == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\t&#x27;</span>) </span><br><span class="line">          ; </span><br><span class="line"></span><br><span class="line">      s[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c) &amp;&amp; c != <span class="string">&#x27;.&#x27;</span>) </span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> c;      <span class="comment">/* not a number */</span> </span><br><span class="line">      i = <span class="number">0</span>; </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))    <span class="comment">/* collect integer part */</span> </span><br><span class="line">          <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) </span><br><span class="line">             ; </span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>)      <span class="comment">/* collect fraction part */</span> </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[++i] = c = getch())) </span><br><span class="line">             ; </span><br><span class="line">      s[i] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">      <span class="keyword">if</span> (c != EOF) </span><br><span class="line">          lastc = c;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> NUMBER; </span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-寄存器变量"><a href="#4-7-寄存器变量" class="headerlink" title="4.7 寄存器变量"></a>4.7 寄存器变量</h3><p>register声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将register变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">register</span> <span class="type">char</span> c;</span><br></pre></td></tr></table></figure><p>register声明只适用于自动变量以及函数的形式参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">register</span> <span class="type">unsigned</span> m, <span class="keyword">register</span> <span class="type">long</span> n) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="keyword">register</span> <span class="type">int</span> i; </span><br><span class="line">       ... </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。</p><h3 id="4-8-程序块结构"><a href="#4-8-程序块结构" class="headerlink" title="4.8 程序块结构"></a>4.8 程序块结构</h3><p>每次进入程序块时，在程序块内声明以及初始化的自动变量都将被初始化。静态变量只在第一次进入程序块时被初始化一次。</p><p>自动变量（包括形式参数）也可以隐藏同名的外部变量与函数。</p><p>在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。</p><h3 id="4-9-初始化"><a href="#4-9-初始化" class="headerlink" title="4.9 初始化"></a>4.9 初始化</h3><p>在不进行显示初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值则没有意义(即初值为无用的信息)。</p><p>对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是在程序开始执行前进行初始化）。对于自动变量与寄存器变量，则每次进入函数或程序块时都将被初始化。</p><p>对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式：表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。</p><p>如果初始化表达式的个数比数组元素少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0.</p><h3 id="4-10-递归"><a href="#4-10-递归" class="headerlink" title="4.10 递归"></a>4.10 递归</h3><p>C语言中的函数可以递归调用，即函数可以直接或间接调用自身。</p><h3 id="习题4-12"><a href="#习题4-12" class="headerlink" title="习题4-12"></a>习题4-12</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">itoa</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (n / <span class="number">10</span>)</span><br><span class="line">        itoa(n / <span class="number">10</span>, s);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">             s[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i++] = <span class="built_in">abs</span>(n) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-11-C预处理器"><a href="#4-11-C预处理器" class="headerlink" title="4.11 C预处理器"></a>4.11 C预处理器</h3><ul><li>#include指令(用于在编译期间把指定文件的内容包含进当前文件中)</li><li>#define指令(用任意字符串序列替代一个标记)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 名字 替换文本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dprint(expr) printf(#expr <span class="string">&quot; = %g\n&quot;</span>, expr)</span></span><br><span class="line">dprint(x/y);<span class="comment">//等价于下边，因为进行了宏扩展</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x/y&quot;</span> <span class="string">&quot; = %g\n&quot;</span>, x/y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x/y = %g\n&quot;</span>, x/y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ##为宏扩展提供了一种连接实际参数的手段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  paste(front, back)  front ## back <span class="comment">// paste(name, 1) -&gt; name1</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行的过程中进行计算。这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(HDR) </span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> HDR </span></span><br><span class="line">   <span class="comment">/* contents of hdr.h go here */</span> </span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYSTEM == SYSV </span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> HDR <span class="string">&quot;sysv.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYSTEM == BSD </span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> HDR <span class="string">&quot;bsd.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYSTEM == MSDOS </span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> HDR <span class="string">&quot;msdos.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> HDR <span class="string">&quot;default.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> HDR </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDR</span></span><br><span class="line"><span class="comment">/* contents of hdr.h go here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="练习4-14"><a href="#练习4-14" class="headerlink" title="练习4-14"></a>练习4-14</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> swap(t, x, y) &#123; t temp;</span></span><br><span class="line">  temp = y;</span><br><span class="line">  y = x;</span><br><span class="line">  x = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五章-指针与数组"><a href="#第五章-指针与数组" class="headerlink" title="第五章 指针与数组"></a>第五章 指针与数组</h2><p>指针是一种保存地址的变量。</p><h3 id="5-1-指针与地址"><a href="#5-1-指针与地址" class="headerlink" title="5.1 指针与地址"></a>5.1 指针与地址</h3><p>一元运算符&amp;可用于取一个对象的地址 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><p>地址运算符&amp;只能应用于内存中的对象，即变量与数组元素。它不用作用于表达式、常量或register类型的变量。</p><p>一元运算符*是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z[<span class="number">10</span>]; </span><br><span class="line"><span class="type">int</span> *ip;          <span class="comment">/* ip is a pointer to int */</span> </span><br><span class="line">ip = &amp;x;          <span class="comment">/* ip now points to x */</span> </span><br><span class="line">y = *ip;          <span class="comment">/* y is now 1 */</span> </span><br><span class="line">*ip = <span class="number">0</span>;          <span class="comment">/* x is now 0 */</span> </span><br><span class="line">ip = &amp;z[<span class="number">0</span>];       <span class="comment">/* ip now points to z[0] */</span></span><br></pre></td></tr></table></figure><p>指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某中特定的数据类型。（一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。）</p><h3 id="5-2-指针与函数参数"><a href="#5-2-指针与函数参数" class="headerlink" title="5.2 指针与函数参数"></a>5.2 指针与函数参数</h3><p>由于C语言是以传值的方式将参数值传递给被调用函数，因此，被调用函数不能直接修改主调函数中变量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>  <span class="comment">/* WRONG */</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">int</span> temp;</span><br><span class="line">       temp = x; </span><br><span class="line">       x = y; </span><br><span class="line">       y = temp; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *px, <span class="type">int</span> *py)</span>  <span class="comment">/* interchange *px and *py */</span> </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> temp; </span><br><span class="line">       temp = *px; </span><br><span class="line">       *px = *py; </span><br><span class="line">       *py = temp; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>swap函数的所有参数都声明为指针，并且通过这些指针来间接访问它们指向的操作数。</p></blockquote><p><img src="%E6%8C%87%E9%92%88.png"></p><h3 id="5-3-指针与数组"><a href="#5-3-指针与数组" class="headerlink" title="5.3 指针与数组"></a>5.3 指针与数组</h3><p>在C语言中，指针和数组之间的关系十分密切。通过数组下标所能完成的任何操作都可以通过指针来实现。一般来说，用指针编写的程序比用数组下标编写的程序执行速度快。</p><p><img src="%E6%95%B0%E7%BB%84.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pa;</span><br><span class="line">pa = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p><img src="%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = *pa; <span class="comment">// 将把数组元素a[0]中的内容复制到变量x中</span></span><br></pre></td></tr></table></figure><p><img src="%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97.png"></p><p>无论数组a中元素的类型或数组长度是什么，上面的结论都成立。”指针加1”就意味着pa+1指向pa所指向的对象的下一个对象。相应地，pa+i指向pa所指向的对象之后的第i个对象。</p><p>数组名所代表的就是该数组最开始的第一个元素的地址，所以，赋值语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pa = &amp;a[<span class="number">0</span>]; <span class="comment">// 等价于下边</span></span><br><span class="line">pa = a;</span><br></pre></td></tr></table></figure><p>我们必须记住，数组名和指针之间有一个不同之处。指针是一个变量，因此，在C语言中，语句pa&#x3D;a和pa++都是合法的。但数组名不是变量，因此，类似于a&#x3D;pa和a++形式的语句是非法的。</p><p>在函数定义中，形式参数char s[ ]和char *s是等价的。</p><h3 id="5-4-地址算术运算"><a href="#5-4-地址算术运算" class="headerlink" title="5.4 地址算术运算"></a>5.4 地址算术运算</h3><p>如果p是一个指向数组某个元素的指针，那么p++将对p进行自增运算并指向下一个元素，而p+&#x3D;i将对p进行加i的增量运算，使其指向指针p当前所指向的元素之后的第i个元素。</p><p>C语言中的地址算术运算方法是一致且有规律的，将指针、数组和地址的算术运算集成在一起是该语言的一大优点。</p><p><img src="%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOCSIZE 10000 <span class="comment">/* size of available space */</span> </span></span><br><span class="line"> </span><br><span class="line">   <span class="type">static</span> <span class="type">char</span> allocbuf[ALLOCSIZE]; <span class="comment">/* storage for alloc */</span> </span><br><span class="line">   <span class="type">static</span> <span class="type">char</span> *allocp = allocbuf;  <span class="comment">/* next free position */</span> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> *<span class="title function_">alloc</span><span class="params">(<span class="type">int</span> n)</span>    <span class="comment">/* return pointer to n characters */</span> </span><br><span class="line"></span><br><span class="line">   &#123; </span><br><span class="line">       <span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123;  <span class="comment">/* it fits */</span> </span><br><span class="line">           allocp += n; </span><br><span class="line">           <span class="keyword">return</span> allocp - n; <span class="comment">/* old p */</span> </span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">else</span>      <span class="comment">/* not enough room */</span> </span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">afree</span><span class="params">(<span class="type">char</span> *p)</span>  <span class="comment">/* free storage pointed to by p */</span> </span><br><span class="line"></span><br><span class="line">   &#123; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE) </span><br><span class="line">           allocp = p; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>C语言保证0永远不是有效的数据地址，因此，返回值0可用来表示发生了异常事件。</p><p>指针和整数之间不能相互转换，但0是唯一的例外：常量0可以赋值给指针，指针也可也和常量0进行比较。程序中常用符号常量NULL代替常量0，这样便于更清晰地说明常量0是指针的一个特殊值。符号常量NULL定义在标准头文件&lt;stddef.h&gt;中。</p><p>在某些情况下对指针可以进行比较运算。例如，如果指针p和q指向同一个数组的成员，那么它们之间可以进行类似于&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;&#x3D;的关系比较运算。</p><p>任何指针与0进行相等或不等的比较运算都有意义。但是指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特例：指针的算术运算中可以使用数组最后一个元素的下一个元素的地址）</p><p>指针可以和整数进行相加或相减运算。例如，结构 <code>p + n</code>表示指针p当前指向的对象之后的第n个对象的地址。无论指针p指向的对象是何种类型，上述结论都成立。在计算<code>p + n</code>时，n将根据p指向的对象的长度按比例缩放，而p指向的对象的长度则取决于p的声明。例如，如果int类型占4个字节的存储空间，那么在int类型的计算中，对应的n将按4的倍数来计算。</p><p>有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加法或减法运算；指向相同数组中元素的两个指针间的减法或比较运算；将指针赋值为0或指针与0之间的比较运算。其他所有形式的指针运算都是非法的，例如两个指针间的加法、乘法、除法、移位或屏蔽运算；指针同float或double类型之间的加法运算；不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针的运算（两个指针之一是void*类型的情况除外）。</p><h3 id="5-5-字符指针与函数"><a href="#5-5-字符指针与函数" class="headerlink" title="5.5 字符指针与函数"></a>5.5 字符指针与函数</h3><p>实际上可以通过字符指针访问该字符串，也就是说，字符串常量可以通过一个指向其第一个元素的指针访问。</p><p>下面两个定义之间有很大的差别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> amessage[] = <span class="string">&quot;now is the time&quot;</span>; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">char</span> *pmessage = <span class="string">&quot;now is the time&quot;</span>; <span class="comment">// 定义一个指针</span></span><br></pre></td></tr></table></figure><p>上述声明中，amessage是一个仅仅足以存放初始化字符串以及空字符’\0’的一维数组。数组中的单个字符可以进行修改，但amessage始终指向同一个存储位置。另一方面，pmessage是一个指针，其初值指向一个字符串常量，之后可以修改以指向其他地址，但如果试图修改字符串的内容，结果是没有定义的。</p><p><img src="%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84.png"></p><h3 id="练习5-3"><a href="#练习5-3" class="headerlink" title="练习5-3"></a>练习5-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">str</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (*s)</span><br><span class="line">s++;</span><br><span class="line"><span class="keyword">while</span> (*s++ = *t++)</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习5-4"><a href="#练习5-4" class="headerlink" title="练习5-4"></a>练习5-4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strend</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *bs = s;</span><br><span class="line">    <span class="type">char</span> *bt = t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; *s; s++)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; *t; t++)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; *s == *t; s--, t--)</span><br><span class="line">        <span class="keyword">if</span> (t == bt || s == bs)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (*s == *t &amp;&amp; t == bt &amp;&amp; *s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习5-5"><a href="#练习5-5" class="headerlink" title="练习5-5"></a>练习5-5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*t &amp;&amp; n-- &gt; <span class="number">0</span>)</span><br><span class="line">        *s++ = *t++;</span><br><span class="line">    <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">        *s++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *, <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(s + <span class="built_in">strlen</span>(s), t, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; *s == *t; s++, t++) </span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;\0&#x27;</span> || --n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *s - *t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-指针数组以及指向指针的指针"><a href="#5-6-指针数组以及指向指针的指针" class="headerlink" title="5.6 指针数组以及指向指针的指针"></a>5.6 指针数组以及指向指针的指针</h3><p>指针数组的名字其实就是指向指针的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *lineptr[MAXLINES]; <span class="comment">/* 它表示lineptr是一个具有MAXLINES个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说lineptr[i]是一个字符指针，而*lineptr[i]是该指针指向的第i个文本行的首字符，lineptr本身是一个数组名，它是指向lineptr数组第一个指针的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="练习5-7"><a href="#练习5-7" class="headerlink" title="练习5-7"></a>练习5-7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTOR 5000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getline</span><span class="params">(<span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readlines</span><span class="params">(<span class="type">char</span> *lineptr[], <span class="type">char</span> *linestor, <span class="type">int</span> maxlines)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len, nlines;</span><br><span class="line">    <span class="type">char</span> line[MAXLEN];</span><br><span class="line">    <span class="type">char</span> *p = linestor;</span><br><span class="line">    <span class="type">char</span> *linestop = linestor + MAXSTOR;</span><br><span class="line">    </span><br><span class="line">    nlines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = getline(line, MAXLEN)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nlines &gt;= maxlines || p + len &gt; linestop)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            line[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p, line);</span><br><span class="line">            lineptr[nlines++] = p;</span><br><span class="line">            p += len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> nlines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-多维数组"><a href="#5-7-多维数组" class="headerlink" title="5.7 多维数组"></a>5.7 多维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> daytab[<span class="number">2</span>][<span class="number">13</span>] = &#123; </span><br><span class="line">       &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;, </span><br><span class="line">       &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125; </span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* day_of_year:  set day of year from month &amp; day */</span> </span><br><span class="line">   <span class="type">int</span> <span class="title function_">day_of_year</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">int</span> i, leap; </span><br><span class="line">       leap = year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">0</span> || year%<span class="number">400</span> == <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; month; i++) </span><br><span class="line">           day += daytab[leap][i]; </span><br><span class="line">       <span class="keyword">return</span> day; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* month_day:  set month, day from day of year */</span> </span><br><span class="line">   <span class="type">void</span> <span class="title function_">month_day</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> yearday, <span class="type">int</span> *pmonth, <span class="type">int</span> *pday)</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">int</span> i, leap; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">       leap = year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">0</span> || year%<span class="number">400</span> == <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">1</span>; yearday &gt; daytab[leap][i]; i++) </span><br><span class="line"></span><br><span class="line">           yearday -= daytab[leap][i]; </span><br><span class="line">       *pmonth = i; </span><br><span class="line">       *pday = yearday; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f (<span class="type">int</span> daytab[<span class="number">2</span>][<span class="number">13</span>]) &#123;...&#125; <span class="comment">// 如果将数组daytab作为参数传递给函数f，那么f的声明应该写成如下形式</span></span><br><span class="line">f (<span class="type">int</span> daytab[][<span class="number">13</span>]) &#123;...&#125;</span><br><span class="line">f (<span class="type">int</span> (*daytab)[<span class="number">13</span>]) &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8-指针数组的初始化"><a href="#5-8-指针数组的初始化" class="headerlink" title="5.8 指针数组的初始化"></a>5.8 指针数组的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* month_name:  return name of n-th month */</span> </span><br><span class="line">   <span class="type">char</span> *<span class="title function_">month_name</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">static</span> <span class="type">char</span> *name[] = &#123; </span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;Illegal month&quot;</span>, </span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, </span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, </span><br><span class="line">           <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, </span><br><span class="line">           <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span> </span><br><span class="line">       &#125;; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">12</span>) ? name[<span class="number">0</span>] : name[n]; </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><h3 id="5-9-指针与多维数组"><a href="#5-9-指针与多维数组" class="headerlink" title="5.9 指针与多维数组"></a>5.9 指针与多维数组</h3><p>假如有下面两个定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从语法角度，a[3][4]和b[3][4]都是对一个int对象的合法引用</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">20</span>]; <span class="comment">// 它分配了200个int类型长度的存储空间</span></span><br><span class="line"><span class="type">int</span> *b[<span class="number">10</span>]; <span class="comment">// 该定义仅仅分配了10个指针，并且没有对它们初始化，它们的初始化必须以显示的方式进行</span></span><br></pre></td></tr></table></figure><p>指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，b的每个元素不必都指向一个具有20个元素的向量。</p><p><img src="%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84.png"></p><p><img src="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png"></p><h3 id="5-10-命令行参数"><a href="#5-10-命令行参数" class="headerlink" title="5.10 命令行参数"></a>5.10 命令行参数</h3><p>按照C语言的约定，argv[0]的值是启动该程序的程序名，因此argc的值至少为1.如果argc的值为1，则说明程序名后面没有命令行参数。在上面的例子中，argc的值为3，argv[0]、argv[1]、argv[2]的值分别为”echo”、”hello”，以及”world”。第一个可选参数为argv[1，而最后一个可选参数为argv[argc - 1]。另外，ANSI标准要求argv[argc]的值必须为一个空指针。</p><p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0.png"></p><p>UNIX系统中的C语言程序有一个公共约定：以负号开头的参数表示一个可选标志或参数。可选参数应该允许以任意次序出现。同时，程序的其余部分应该与命令行中参数的数目无关。此外，如何可选参数能够组合使用，将给使用者带来更大的方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">2</span>] == *(a + <span class="number">2</span>); <span class="comment">//结果是true，[]相当于解引用</span></span><br></pre></td></tr></table></figure><h3 id="5-11-指向函数的指针"><a href="#5-11-指向函数的指针" class="headerlink" title="5.11 指向函数的指针"></a>5.11 指向函数的指针</h3><p>在C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINES 5000     <span class="comment">/* max #lines to be sorted */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *lineptr[MAXLINES];  <span class="comment">/* pointers to text lines */</span> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">readlines</span><span class="params">(<span class="type">char</span> *lineptr[], <span class="type">int</span> nlines)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">writelines</span><span class="params">(<span class="type">char</span> *lineptr[], <span class="type">int</span> nlines)</span>; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *lineptr[], <span class="type">int</span> left, <span class="type">int</span> right, </span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">           <span class="type">int</span> (*comp)(<span class="type">void</span> *, <span class="type">void</span> *))</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">numcmp</span><span class="params">(<span class="type">char</span> *, <span class="type">char</span> *)</span>; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* sort input lines */</span> </span><br><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> nlines;        <span class="comment">/* number of input lines read */</span> </span><br><span class="line">    <span class="type">int</span> numeric = <span class="number">0</span>;   <span class="comment">/* 1 if numeric sort */</span> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-n&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">        numeric = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> ((nlines = readlines(lineptr, MAXLINES)) &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        qsort((<span class="type">void</span>**) lineptr, <span class="number">0</span>, nlines<span class="number">-1</span>, </span><br><span class="line">          (<span class="type">int</span> (*)(<span class="type">void</span>*,<span class="type">void</span>*))(numeric ? numcmp : <span class="built_in">strcmp</span>)); </span><br><span class="line">        writelines(lineptr, nlines); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input too big to sort\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在调用函数qsort的语句中，strcmp和numcmp是函数的地址。因为它们是函数，所以前面不需要加上取地址运算符&amp;，同样的原因，数组名前面也不需要&amp;运算符。</p><p>由于任何类型的指针都可以转换为void *类型，并且在将它转换回原来的类型时不会丢失信息，所以，调用qsort函数时可以将参数强制转换为void *类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* qsort:  sort v[left]...v[right] into increasing order */</span> </span><br><span class="line">  <span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *v[], <span class="type">int</span> left, <span class="type">int</span> right, </span></span><br><span class="line"><span class="params">             <span class="type">int</span> (*comp)(<span class="type">void</span> *, <span class="type">void</span> *))</span> </span><br><span class="line">  &#123; </span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> i, last; </span><br><span class="line"></span><br><span class="line">      <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span> *v[], <span class="type">int</span>, <span class="type">int</span>)</span>; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (left &gt;= right)    <span class="comment">/* do  nothing if array contains */</span> </span><br><span class="line">          <span class="keyword">return</span>;           <span class="comment">/* fewer than two elements */</span> </span><br><span class="line"></span><br><span class="line">      swap(v, left, (left + right)/<span class="number">2</span>); </span><br><span class="line">      last = left; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (i = left+<span class="number">1</span>; i &lt;= right;  i++) </span><br><span class="line">          <span class="keyword">if</span> ((*comp)(v[i], v[left]) &lt; <span class="number">0</span>) </span><br><span class="line">              swap(v, ++last, i); </span><br><span class="line">      </span><br><span class="line">      swap(v, left, last); </span><br><span class="line">      qsort(v, left, last<span class="number">-1</span>, comp); </span><br><span class="line">      qsort(v, last+<span class="number">1</span>, right, comp); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们仔细研究一下其中的声明。qsort函数的第四个参数声明如下：</p><p><code>int (*comp) (void *, void *)</code></p><p>它表明comp是一个指向函数的指针，该函数有两个void*类型的参数，其返回值类型为int。</p><p>在下列语句中：</p><p><code>if ((*comp)(v[i], v[left]) &lt; 0)</code></p><p>comp的使用和其声明是一致的，comp是一个指向函数的指针，*comp代表一个函数。下列语句是对该函数进行调用：</p><p><code>(*comp)(v[i], v[left])</code></p><p>其中圆括号是必须的，这样才能够保证其中的各个部分正确结合。如果没有括号，例如写成下面的形式：</p><p><code>int *comp(void *, void *) /* 错误的写法 */ </code></p><p>则表明comp是一个函数，该函数返回一个指向int类型的指针，这同我们的本意显然有很大的差别。</p><h2 id="第六章-结构"><a href="#第六章-结构" class="headerlink" title="第六章 结构"></a>第六章 结构</h2><p>结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。</p><h3 id="6-1-结构的基本知识"><a href="#6-1-结构的基本知识" class="headerlink" title="6.1  结构的基本知识"></a>6.1  结构的基本知识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键字struct引入结构声明。结构声明包含在花括号内的一系列声明组成。关键字struct后面的名字是可选的，称为结构标记。</p><p>结构中定义的变量称为成员。struct声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他类型的变量声明是相同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>....&#125; x, y, z;</span><br></pre></td></tr></table></figure><p>从语法角度来讲，这种方式的声明与声明</p><p><code>int x, y, z;</code></p><p>具有类似的意义。这两个声明都将x、y、z声明为指定类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span>;</span> <span class="comment">// 用结构标记声明结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">maxpt</span> =</span> &#123;<span class="number">320</span>, <span class="number">200</span>&#125;; <span class="comment">// 初值表中每个成员对应的初值必须是常量表达式</span></span><br></pre></td></tr></table></figure><p>在表达式中，可以通过下列形式引用某个特定结构中的成员：</p><p><code>结构名.成员</code></p><p>其中的结构成员运算符”.”将结构名与成员名连接起来。结构可以嵌套。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span> <span class="title">screen</span>;</span></span><br><span class="line">screen.pt1.x;</span><br></pre></td></tr></table></figure><h3 id="6-2-结构与函数"><a href="#6-2-结构与函数" class="headerlink" title="6.2  结构与函数"></a>6.2  结构与函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> point <span class="title function_">makepoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">temp</span>;</span></span><br><span class="line">    temp.x = x; <span class="comment">// 注意，参数名和结构成员同名不会引起冲突。事实上，使用重名可以强调二者之间的关系。</span></span><br><span class="line">    temp.y = y;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何传递给函数的结构很大，使用指针方式的效率通常比复制整个结构的效率更高。结构指针类似于普通变量指针。</p><p>结构指针的使用频率非常高，为了方便，C语言提供了另一种简写方式。假定p是一个指向结构的指针，可以用</p><p><code>p-&gt;结构成员</code>这种形式引用相应的结构成员。</p><p>在所有运算符中，下面4个运算符的优先级最高：结构运算符”.”和”-&gt;”、用于函数调用的”( )”以及用于下标的”[ ]”，因此它们同操作数之间的结合也最紧密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure><h3 id="6-3-结构数组"><a href="#6-3-结构数组" class="headerlink" title="6.3 结构数组"></a>6.3 结构数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *word;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125; keytab[NKEYS];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *word;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> <span class="title">keytab</span>[<span class="title">NKEYS</span>];</span></span><br></pre></td></tr></table></figure><p>上述两种方式定义结构数组一样。</p><p>C语言提供了一个编译时(compile-time)一元运算符，它可用来计算任一对象的长度。表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> 对象;</span><br><span class="line"><span class="keyword">sizeof</span> (类型名);</span><br></pre></td></tr></table></figure><p>将返回一个整型值，它等于指定对象或类型占用的存储空间字节数。(严格地说，sizeof的返回值是无符号整型值，其类型为size_t，该类型在头文件&lt;stddef.h&gt;中定义)其中，对象可以是变量，数组或结构；类型可以是基本类型，如int、double，也可以是派生类型，如结构类型或指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NKEYS (sizeof keytab / sizeof(struct key))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NKEYS (sizeof keytab / sizeof keytab[0])</span></span><br></pre></td></tr></table></figure><p>条件编译语句#if不能使用sizeof，因为预处理器不对类型名进行分析。但预处理器并不计算#define语句中的表达式，因此，在#define中使用sizeof是合法的。</p><h3 id="6-4-指向结构的指针"><a href="#6-4-指向结构的指针" class="headerlink" title="6.4 指向结构的指针"></a>6.4 指向结构的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXWORD 100 </span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">getword</span><span class="params">(<span class="type">char</span> *, <span class="type">int</span>)</span>; </span><br><span class="line"><span class="keyword">struct</span> key *<span class="title function_">binsearch</span><span class="params">(<span class="type">char</span> *, <span class="keyword">struct</span> key *, <span class="type">int</span>)</span>; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* count C keywords; pointer version */</span> </span><br><span class="line"></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> word[MAXWORD]; </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">p</span>;</span> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getword(word, MAXWORD) != EOF) </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(word[<span class="number">0</span>])) </span><br><span class="line">            <span class="keyword">if</span> ((p=binsearch(word, keytab, NKEYS)) != <span class="literal">NULL</span>) </span><br><span class="line"></span><br><span class="line">                p-&gt;count++; </span><br><span class="line">    <span class="keyword">for</span> (p = keytab; p &lt; keytab + NKEYS; p++) <span class="comment">// 对p的算术运算需要考虑结构的长度</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;count &gt; <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4d %s\n&quot;</span>, p-&gt;count, p-&gt;word); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* binsearch: find word in tab[0]...tab[n-1] */</span> </span><br><span class="line"><span class="keyword">struct</span> key *<span class="title function_">binsearch</span><span class="params">(<span class="type">char</span> *word, struck key *tab, <span class="type">int</span> n)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> cond; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">low</span> =</span> &amp;tab[<span class="number">0</span>]; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">high</span> =</span> &amp;tab[n]; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">mid</span>;</span> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123; </span><br><span class="line">        mid = low + (high-low) / <span class="number">2</span>; <span class="comment">// 只能这样写，不能写成 mid = (low + high) / 2，因为指针之间的加法运算是非法的。但是指针的减法运算却是合法的</span></span><br><span class="line">        <span class="keyword">if</span> ((cond = <span class="built_in">strcmp</span>(word, mid-&gt;word)) &lt; <span class="number">0</span>) </span><br><span class="line">            high = mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cond &gt; <span class="number">0</span>) </span><br><span class="line">            low = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对算法的最重要修改在于，要确保不会生成非法的指针，或者试图访问数组范围之外的元素。问题在于，&amp;tab[-1]和&amp;tab[n]都超出了数组tab的范围。前者是绝对非法的，而后者的间接引用也是非法的。但是，C语言的定义保证数组末尾之后的第一个元素(即&amp;tab[n])的指针算术运算可以正确执行。</p><p>千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要求，所以，结构中可能会出现未命名的”空穴”(hole)。例如，假设char类型占用一个字节，int类型占用4个字节，则下例结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能需要8个字节的存储空间，而不是5个字节。使用sizeof运算符可以返回正确的对象长度。</p><h3 id="6-5-自引用结构"><a href="#6-5-自引用结构" class="headerlink" title="6.5  自引用结构"></a>6.5  自引用结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span>     <span class="comment">/* the tree node: */</span> </span><br><span class="line"><span class="type">char</span> *word; <span class="comment">/* points to the text */</span> </span><br><span class="line"><span class="type">int</span> count; <span class="comment">/* number of occurrences */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">left</span>;</span>   <span class="comment">/* left child */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">right</span>;</span>  <span class="comment">/* right child */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>自己引用自己</p></blockquote><h3 id="6-6-类型定义Typedef"><a href="#6-6-类型定义Typedef" class="headerlink" title="6.6  类型定义Typedef"></a>6.6  类型定义Typedef</h3><p>C语言提供了一个称为typedef的功能，它用来建立新的数据类型名，例如，声明</p><p>typedef int Length;</p><p>将Length定义为与int具有相同意义的名字。类型Length可用于类型声明、类型转换等，它和类型int完全相同，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Length;</span><br><span class="line">Length len, maxlen;</span><br><span class="line">Length *lengths[];</span><br></pre></td></tr></table></figure><p>注意，typedef中声明的类型在变量名的位置出现，而不是紧接在关键字typedef之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">Treeptr</span>;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span> <span class="comment">/* the tree node: */</span> </span><br><span class="line">      <span class="type">char</span> *word;           <span class="comment">/* points to the text */</span> </span><br><span class="line">      <span class="type">int</span> count;            <span class="comment">/* number of occurrences */</span> </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">left</span>;</span>   <span class="comment">/* left child */</span> </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">right</span>;</span>  <span class="comment">/* right child */</span> </span><br><span class="line"></span><br><span class="line"> &#125; Treenode;</span><br></pre></td></tr></table></figure><p>这里必须强调的是，从任何意义上讲，typedef声明并没有创建一个新类型，它知识为某个已存在的类型增加一个新的名称而已。typedef是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PFI)</span> <span class="params">(<span class="type">char</span> *, <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure><p>该语句定义了类型PFI是“一个指向函数的指针，该函数具有两个char *类型的参数，返回值类型为int”。</p><p>typedef的第一个作用是使程序参数化，以提高程序的可移植性。第二个作用是为程序提供更好的说明性。</p><h3 id="6-7-联合"><a href="#6-7-联合" class="headerlink" title="6.7 联合"></a>6.7 联合</h3><p>联合是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">u_tag</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">float</span> fval;</span><br><span class="line">    <span class="type">char</span> *sval;</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure><p>变量u必须足够大，已保存这三种类型中最大的一种。</p><p>可以通过下列语法访问联合体中的成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">联合名.成员</span><br><span class="line">联合名-&gt;成员</span><br></pre></td></tr></table></figure><p>联合可以使用在结构和数组中，反之亦可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">       <span class="type">char</span> *name; </span><br><span class="line">       <span class="type">int</span> flags; </span><br><span class="line">       <span class="type">int</span> utype; </span><br><span class="line">       <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line">           <span class="type">int</span> ival; </span><br><span class="line">           <span class="type">float</span> fval; </span><br><span class="line">           <span class="type">char</span> *sval; </span><br><span class="line">       &#125; u; </span><br><span class="line">   &#125; symtab[NSYM]; </span><br></pre></td></tr></table></figure><p>可以通过下列语句引用其成员ival：</p><p>symtab[i].u.ival</p><p>也可通过下列语句之一引用字符串sval的第一个字符：</p><p>*symtab[i].u.sval</p><p>symtab[i].u.sval[0]</p><p>实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都为0，此结构空间要大到足够容纳最宽的成员，并且，其对齐方式要适合于联合中所有类型的成员。对联合允许的操作与对结构允许的操作相同：作为一个整体单元进行赋值、复制、取址及访问其中一个成员。</p><p>联合只能用其第一个成员类型的值进行初始化，因此，上述联合u只能用整数值进行初始化。</p><h3 id="6-8-位字段"><a href="#6-8-位字段" class="headerlink" title="6.8  位字段"></a>6.8  位字段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> is_keyword : <span class="number">1</span>; </span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> is_extern  : <span class="number">1</span>; </span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> is_static  : <span class="number">1</span>; </span><br><span class="line">   &#125; flags; </span><br></pre></td></tr></table></figure><p>这里定义一个变量flags，它包含3个一位的字段。冒号后的数字表示字段的宽度（用二进制位数表示）。字段被声明为unsigned int类型，以保证它们是无符号量。</p><p>字段的作用与小整数相似。同其他整数一样，字段可出现在算术表达式中。因此上面的例子可用更自然的方式表达为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags.is_extern = flags.is_static = <span class="number">1</span>; </span><br><span class="line">flags.is_extern = flags.is_static = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (flags.is_extern == <span class="number">0</span> &amp;&amp; flags.is_static == <span class="number">0</span>) </span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>字段不是数组，并且没有地址，因此它们不能使用&amp;运算符。</p><h2 id="第七章-输入与输出"><a href="#第七章-输入与输出" class="headerlink" title="第七章 输入与输出"></a>第七章 输入与输出</h2><p>输入&#x2F;输出功能并不是C语言本身的组成部分。</p><h3 id="7-1-标准输入-x2F-输出"><a href="#7-1-标准输入-x2F-输出" class="headerlink" title="7.1 标准输入&#x2F;输出"></a>7.1 标准输入&#x2F;输出</h3><p>文本流是一系列行组成，每一行的结尾是一个换行符。</p><p>最简单的输入机制使用getchar函数从标准输入(一般为键盘)中一次读取一个字符：</p><p><code>int getchar(void)</code></p><p>getchar函数在每次被调用时返回下一个输入字符。若遇到文件结尾，则返回EOF。符号常量EOF在头文件&lt;stdio.h&gt;中定义，其值一般为-1。</p><p>函数<code>int putchar(int)</code>用于输出数据，putchar(c)将字符c送至标准输出上，在默认情况下，标准输出为屏幕显示。如果没有发生错误，则函数putchar将返回输出的字符；如果发生了错误，则返回EOF。</p><p>函数printf也向标准输出设备上输出数据。使用输入&#x2F;输出库函数的每个源程序文件必须在引用这些函数之前包含下列语句：</p><p><code>#include &lt;stdio.h&gt;</code></p><p>当文件名用一对尖括号&lt;和&gt;括起来时，预处理器将在由具体实现定义的有关位置查找指定的文件（例如，在UNIX系统中，文件一般放在目录&#x2F;usr&#x2F;include）。</p><p>头文件&lt;stdio.h&gt;中的getchar和putchar函数以及&lt;ctype.h&gt;中的tolower函数一般都是宏，这样就避免了对每个字符都进行函数调用的开销。</p><h3 id="练习7-1"><a href="#练习7-1" class="headerlink" title="练习7-1"></a>练习7-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(agrv[<span class="number">0</span>], <span class="string">&quot;lower&quot;</span>))</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="built_in">tolower</span>(c));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="built_in">toupper</span>(c));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-格式化输出——printf函数"><a href="#7-2-格式化输出——printf函数" class="headerlink" title="7.2 格式化输出——printf函数"></a>7.2 格式化输出——printf函数</h3><p><code>int printf(char *format, arg1, arg2, ...)</code></p><p>格式字符串包括两种类型的对象：普通字符和转换说明。每个转换说明都由一个百分号字符(即%)开始，并以一个转换字符结束。</p><h3 id="7-3-变长参数表"><a href="#7-3-变长参数表" class="headerlink" title="7.3 变长参数表"></a>7.3 变长参数表</h3><p>函数printf的正确声明形式为：</p><p><code>int printf(char *fmt, ...)</code>，其中，省略号表示参数表中参数的数量和类型是可变的，省略号只能出现在参数表的尾部。</p><h3 id="7-4-格式化输入——scanf函数"><a href="#7-4-格式化输入——scanf函数" class="headerlink" title="7.4 格式化输入——scanf函数"></a>7.4 格式化输入——scanf函数</h3><p>输入函数scanf对英语输出函数printf，它在与后者相反的方向上提供同样的转换功能。具有变长参数表的函数scanf的声明形式如下：</p><p><code>int scanf(char *format, ...)</code></p><p>scanf函数从标准输入中读取字符序列，按照format中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。其他所有参数都必须是指针，用于指定经格式转换后的相应输入保存的位置。该函数返回成功匹配并复制的输入项的个数，如果到达文件的结尾，该函数返回EOF。</p><p>另外还有一个输入函数sscanf，它用于从一个字符串（而不是标准输入）中读取字符序列：</p><p><code>int sscanf(char *string, char *format, arg1, arg2, ...)</code></p><p>它按照格式参数format中规定格式扫描字符串string，并把结果分别保存到arg1、arg2、…这些参数中。这些参数必须是指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="type">double</span> sum, v;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>. &amp;v) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%.2f\n&quot;</span>, sum += v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们要读取包含下列日期格式的输入行：</p><p>25 DEC 1988</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> day, year;</span><br><span class="line"><span class="type">char</span> monthname[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %s %d&quot;</span>, &amp;day, monthname, &amp;year);</span><br></pre></td></tr></table></figure><p>scanf函数忽略格式串中的空格和制表符。此外，在读取输入值时，它将跳过空白符。</p><p>注意，scanf和sscanf函数的所有参数都必须是指针。</p><h3 id="7-5-文件访问"><a href="#7-5-文件访问" class="headerlink" title="7.5 文件访问"></a>7.5 文件访问</h3><p>在读写文件之前，必须通过库函数fopen打开该文件。fopen用文件的外部名与操作系统进行某些必要的连接和通信，并返回一个随后可以用于文件读写操作的指针。</p><p>该指针称为文件指针，它指向一个包含文件信息的结构，这些信息包括：缓冲区的位置、缓冲区当前字符的位置、文件的读或写状态、是否出错或是否以及达到文件结尾等等。用户不必关系这些细节，因为&lt;stdio.h&gt;中已经定义了一个包含这些信息的结构。在程序中只需按照下列方式声明一个文件指针即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>fopen的第一个参数是一个字符串，它包含文件名。第二个参数是访问模式，也是一个字符串，用于指定文件的使用方式。允许的模式包括：读（”r”）、写（”w”）及追加（”a”)。某些系统还区分文本文件和二进制文件，对后者的访问需要在模式字符串中增加字符”b”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getc和putc是宏而不是函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *fp)</span> <span class="comment">// getc函数返回fp指向的输入流中的下一个字符。如果到达文件尾或出现错误，该函数将返回EOF</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span> <span class="comment">// 该函数将字符c写入到fp指向的文件中，并返回写入的字符。如果发生错误，则返回EOF</span></span><br></pre></td></tr></table></figure><p>启动一个C语言程序时，操作系统环境负责打开3个文件，并将这3个文件的指针提供给该程序。这3个文件分别是标准输入、标准输出和标准错误，相应的文件指针分别为stdin、stdout和stderr，它们在&lt;stdio.h&gt;中声明。在大多数环境中，stdin指向键盘，而stdout和stderr指向显示器。stdin和stdout可以被重定向文件或管道。</p><p>对于文件的格式化输入或输出，可以使用函数fscanf和fprintf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">char</span> *format, ...)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">char</span> *format, ...)</span> </span><br></pre></td></tr></table></figure><p>文件指针stdin与stdout都是FILE*类型的对象。但它们是常量，而非变量，因此不能对他们赋值。</p><p>函数<code>int fclose(FILE *fp)</code>执行和fopen相反的操作，它断开由fopen函数建立的文件指针和外部名之间的连接，并释放文件指针以供其他文件使用。因为大多数操作系统都限制了一个程序可以同时打开的文件数，所以，当文件指针不再需要时就应该释放。对输出文件执行fclose还有另外一个原因：它将把缓冲区中由putc函数正在收集的输出写到文件中。当程序正常终止时，程序会自动为每个打开的文件调用fclose函数。</p><h3 id="7-6-错误处理——stderr和exit"><a href="#7-6-错误处理——stderr和exit" class="headerlink" title="7.6  错误处理——stderr和exit"></a>7.6  错误处理——stderr和exit</h3><p>即使对标准输出进行了重定向，写道stderr的输出通常也会显示在屏幕上。</p><p>程序使用了标准库函数exit，当该函数被调用时，它将终止调用程序的执行。任何调用该程序的进程都可以获取exit的参数值，因此，可通过另一个将该程序作为子进程的程序来测试该程序的执行是否成功。按照惯例，返回值0表示一切正常，而非0返回值通常表示出现了异常情况。exit为每个已打开的输出文件调用fclose函数，以将缓冲区的所以输出写到相应的文件中。</p><p>函数<code>int ferror(FILE *fp)</code>，如果流fp中出现错误，则函数ferror返回一个非0值。</p><p>函数<code>int feof(FILE *fp)</code>，如果指定的文件到达文件结尾，它将返回一个非0值。</p><p>对于任何重要的程序来说，都应该让程序返回有意且有用的值。</p><h3 id="7-7-行输入和行输出"><a href="#7-7-行输入和行输出" class="headerlink" title="7.7  行输入和行输出"></a>7.7  行输入和行输出</h3><p><code>char * fgets(char *line, int maxline, FILE *fp)</code>,fgets函数从fp指向的文件中读取下一个输入行(包括换行符)，并将它存放在字符数组line中，它最多可以读取maxline-1个字符。读取的行将以’\0’结尾保存到数组。通常情况下，fgets返回line，但如果遇到了文件结尾或发生了错误，则返回NULL。</p><p><code>int fputs(char *line, FILE *fp)</code>，输出函数fputs将一个字符串(不需要包含换行符)写入到一个文件中，如果发生错误，该函数将返回EOF，否则返回一个非负值。</p><h2 id="第8章-UNIX系统接口"><a href="#第8章-UNIX系统接口" class="headerlink" title="第8章 UNIX系统接口"></a>第8章 UNIX系统接口</h2><p>UNIX操作系统通过一系列的系统调用提供服务，这些系统调用实际上是操作系统内的函数，它们可以被用户程序调用。</p><h3 id="8-1-文件描述符"><a href="#8-1-文件描述符" class="headerlink" title="8.1 文件描述符"></a>8.1 文件描述符</h3><p>未完待续！！！！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章-导言&quot;&gt;&lt;a href=&quot;#第一章-导言&quot; class=&quot;headerlink&quot; title=&quot;第一章 导言&quot;&gt;&lt;/a&gt;第一章 导言&lt;/h2&gt;</summary>
    
    
    
    
    <category term="C-Language" scheme="https://gccforstudy.github.io/tags/C-Language/"/>
    
  </entry>
  
  <entry>
    <title>JAVA对象头与锁优化</title>
    <link href="https://gccforstudy.github.io/2022/11/20/JVM%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <id>https://gccforstudy.github.io/2022/11/20/JVM%E5%AF%B9%E8%B1%A1%E5%A4%B4/</id>
    <published>2022-11-20T00:49:59.000Z</published>
    <updated>2022-11-20T01:33:05.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA对象头与锁优化"><a href="#JAVA对象头与锁优化" class="headerlink" title="JAVA对象头与锁优化"></a>JAVA对象头与锁优化</h1><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头</strong>（Header）、<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong>（Padding）。</p><span id="more"></span><h2 id="JAVA对象头"><a href="#JAVA对象头" class="headerlink" title="JAVA对象头"></a>JAVA对象头</h2><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别位32个比特和64个比特，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个<strong>有着动态定义的数据结构</strong>（当Mark Word的锁状态标志位处于不同的状态时，Mark Word的结构是不一样的），以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间的25个比特用于存储对象的HashCode，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>重量级锁定</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向锁ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><h3 id="Klass-pointer"><a href="#Klass-pointer" class="headerlink" title="Klass pointer"></a>Klass pointer</h3><p>对象头的另外一部分是<strong>类型指针</strong>（klass pointer），即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定经过对象本身。此外，如果对象是一个Java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p><p>klass pointer在32位的虚拟机中占32位，在64位的虚拟机中占64位，但是在64位的虚拟机中该地址也可以被编码为32位。这项优化被称为“compressed oops”，你可以使用UseCompressedOops虚拟机参数来控制是否使用这项优化。详见 <a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops%E3%80%82">https://wiki.openjdk.java.net/display/HotSpot/CompressedOops。</a></p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>接下来实例数据部分是真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义的顺序的影响。HotSpot虚拟机默认的分配顺序位longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers， OOPs），从以上的默认分配策略中可以看到，相同的宽度的字段总是被分配到一起存放，在满足这个前提的条件的情况下，在父类中定义的变量会出现在子类之前。（如果HotSpot虚拟机的-XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。）</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的第三部分是<strong>对齐填充</strong>，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>为何要在讲解对象头的内容时将锁优化的内容插入进来呢？因为Mark Word与锁优化息息相关。</p><h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，<strong>共享数据的锁定状态只会持续很短的一段时间</strong>，为了这段时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个<strong>忙循环（自旋）</strong>，这项技术就是所谓的<strong>自旋锁</strong>。</p><p>自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX：+UseSpinning参数来开启，在JDK 6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，<strong>所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作</strong>，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次，用户也可以使用参数-XX：PreBlockSpin来自行更改。</p><p>不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。<strong>在JDK 6中对自旋锁的优化，引入了自适应的自旋。</strong>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。<strong>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。</strong>有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况<br>预测就会越来越精准，虚拟机就会变得越来越“聪明”了。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。</p><p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点，<strong>轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p><p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对HotSpot虚拟机对象的内存布局（尤其是对象头部分）有所了解。HotSpot虚拟机的对象头（Object Header）分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。<strong>这部分是实现轻量级锁和偏向锁的关键</strong>。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。这部分知识我们在文章的<a href="#JAVA%E5%AF%B9%E8%B1%A1%E5%A4%B4">JAVA对象头</a>已经介绍过了。</p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，<strong>考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构</strong>，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，对象未被锁定的状态下，Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特固定为0（这表示未进入偏向模式）。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同状态，这些状态下对象头的存储内容如下表所示。</p><p><img src="MarkWord.jpg"></p><p>我们简单回顾了对象的内存布局后，接下来就可以介绍轻量级锁的工作过程了：在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），<strong>虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间</strong>，<strong>用于存储锁对象目前的Mark Word的拷贝</strong>（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如下图所示。</p><p><img src="LockRecord.jpg"></p><p>Lock Record包含一个displaced header reference用于替换对象头中的Mark Word和一个指向被上锁的对象的指针。</p><p>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图下图所示。</p><p><img src="LockRecord2.jpg"></p><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向<strong>当前线程的栈帧</strong>，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。<strong>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，</strong>后面等待锁的线程也必须进入阻塞状态。</p><p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。（如果替换失败，则说明轻量级锁已经膨胀为重量级锁，现在mark word存的是指向重量级锁的指针）。</p><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在<strong>无竞争情况下</strong>的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下<strong>把整个同步都消除掉，连CAS操作都不去做了。</strong></p><p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>如果读者理解了前面轻量级锁中关于对象头Mark Word与线程之间的操作过程，那偏向锁的原理就会很容易理解。假设当前虚拟机启用了偏向锁（启用参数-XX：+UseBiased Locking，这是自JDK 6起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。</p><p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示。</p><p><img src="%E9%94%81%E8%BD%AC%E5%8C%96%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg"></p><p>细心的读者看到这里可能会发现一个问题：当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？</p><p>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；<strong>而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。</strong>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</p><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p><p>下面是我将OpenJDK官网关于同步与对象头的原文摘抄过来的，是为了记录自己的学习成果，如果读者想要更加深入地了解JAVA的同步机制，建议各位读者去OpenJDK官网寻找自己想要了解的内容。</p><h1 id="Synchronization-and-Object-Locking"><a href="#Synchronization-and-Object-Locking" class="headerlink" title="Synchronization and Object Locking"></a>Synchronization and Object Locking</h1><p><em>Written by Thomas Kotzmann and Christian Wimmer</em></p><p>One of the major strengths of the Java programming language is its built-in support for multi-threaded programs. An object that is shared between multiple threads can be locked in order to synchronize its access. Java provides primitives to designate critical code regions, which act on a shared object and which may be executed only by one thread at a time. The first thread that enters the region locks the shared object. When a second thread is about to enter the same region, it must wait until the first thread has unlocked the object again.</p><p>In the Java HotSpot™ VM, every object is preceded by a class pointer and a header word. The header word, which stores the identity hash code as well as age and marking bits for generational garbage collection, is also used to implement a <em>thin lock scheme</em> [<a href="https://wiki.openjdk.org/display/HotSpot/Synchronization#Synchronization-Agesen99">Agesen99</a>, <a href="https://wiki.openjdk.org/display/HotSpot/Synchronization#Synchronization-Bacon98">Bacon98</a>]. The following figure shows the layout of the header word and the representation of different object states.</p><p><img src="https://wiki.openjdk.org/download/attachments/11829266/Synchronization.gif?version=4&modificationDate=1208918680000&api=v2" alt="img"></p><p>The right-hand side of the figure illustrates the standard locking process. As long as an object is unlocked, the last two bits have the value 01. When a method synchronizes on an object, the header word and a pointer to the object are stored in a lock record within the current stack frame. Then the VM attempts to install a pointer to the lock record in the object’s header word via a <em>compare-and-swap</em> operation. If it succeeds, the current thread afterwards owns the lock. Since lock records are always aligned at word boundaries, the last two bits of the header word are then 00 and identify the object as being locked.</p><p>If the compare-and-swap operation fails because the object was locked before, the VM first tests whether the header word points into the method stack of the current thread. In this case, the thread already owns the object’s lock and can safely continue its execution. <strong>For such a <em>recursively</em> locked object, the lock record is initialized with 0 instead of the object’s header word.</strong> Only if two different threads concurrently synchronize on the same object, the thin lock must be <em>inflated</em> to a heavyweight monitor for the management of waiting threads.</p><p>Thin locks are a lot cheaper than inflated locks, but their performance suffers from the fact that every compare-and-swap operation must be executed atomically on multi-processor machines, although most objects are locked and unlocked only by one particular thread. In Java 6, this drawback is addressed by a so-called <em>store-free biased locking technique</em> [<a href="https://wiki.openjdk.org/display/HotSpot/Synchronization#Synchronization-Russel06">Russell06</a>], which uses concepts similar to [<a href="https://wiki.openjdk.org/display/HotSpot/Synchronization#Synchronization-Kawachiya02">Kawachiya02</a>]. <strong>Only the first lock acquisition performs an atomic compare-and-swap to install an ID of the locking thread into the header word.</strong> The object is then said to be <em>biased</em> towards the thread. Future <strong>locking and unlocking</strong> of the object by the same thread <strong>do not require any atomic operation or an update of the header word.</strong> Even the lock record on the stack is left uninitialized as it will never be examined for a biased object.</p><p>When a thread synchronizes on <strong>an object that is biased towards another thread</strong>, the bias must be <em>revoked</em> by making the object appear as if it had been locked the <strong>regular way.</strong> The stack of the bias owner is traversed, lock records associated with the object are adjusted according to the thin lock scheme, and a pointer to <strong>the oldest of them</strong> is installed in the object’s header word.(大概的意思是当偏向锁被撤销时，会按照常规的加锁方式进行加锁，先是轻量锁，再膨胀为重量锁) All threads must be suspended for this operation. The bias is also <strong>revoked when the identity hash code of an object is accessed</strong> <strong>since the hash code bits are shared with the thread ID</strong>.</p><p>Objects that are explicitly designed to be shared between multiple threads, such as producer&#x2F;consumer queues, are not suitable for biased locking. Therefore, biased locking is disabled for a class <strong>if revocations for its instances happened frequently in the past.</strong> This is called <em><strong>bulk revocation</strong></em>. If the locking code is invoked on an instance of a class for which biased locking was disabled, it performs the standard thin locking. Newly allocated instances of the class are marked as non-biasable.</p><p>A similar mechanism, called <strong><em>bulk rebiasing</em>,</strong> optimizes situations in which <strong>objects of a class are locked and unlocked by different threads but never concurrently.</strong> It invalidates the bias of all instances of a class without disabling biased locking. An <em>epoch value</em> in the class acts as a timestamp that indicates the validity of the bias. This value is copied into the header word upon object allocation. Bulk rebiasing can then efficiently be implemented as an increment of the epoch in the appropriate class. The next time an instance of this class is going to be locked, the code detects a different value in the header word and rebiases the object towards the current thread.</p><h3 id="Source-Code-Hints"><a href="#Source-Code-Hints" class="headerlink" title="Source Code Hints"></a>Source Code Hints</h3><p>Synchronization affects multiple parts of the JVM: The structure of the object header is defined in the classes <code>oopDesc</code> and <code>markOopDesc</code>, the code for thin locks is integrated in the interpreter and compilers, and the class <code>ObjectMonitor</code> represents inflated locks. Biased locking is centralized in the class <code>BiasedLocking</code>. It can be enabled via the flag <code>-XX:+UseBiasedLocking</code> and disabled via <code>-XX:-UseBiasedLocking</code>. It is enabled by default for Java 6 and Java 7, but activated only some seconds after the application startup. Therefore, beware of short-running <a href="https://wiki.openjdk.org/display/HotSpot/MicroBenchmarks">micro-benchmarks</a>. If necessary, turn off the delay using the flag <code>-XX:BiasedLockingStartupDelay=0</code>.</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[Agesen99] O. Agesen, D. Detlefs, A. Garthwaite, R. Knippel, Y. S. Ramakrishna, D. White: <em>An Efficient Meta-lock for Implementing Ubiquitous Synchronization</em>. In <em>Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</em>, pages 207-222. ACM Press, 1999. <a href="http://dx.doi.org/10.1145/320384.320402">doi:10.1145&#x2F;320384.320402</a></p><p>[Bacon98] D. F. Bacon, R. Konuru, C. Murthy, M. Serrano: <em>Thin Locks: Featherweight Synchronization for Java</em>. In <em>Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pages 258-268. ACM Press, 1998. <a href="http://dx.doi.org/10.1145/277650.277734">doi:10.1145&#x2F;277650.277734</a></p><p>[Kawachiya02] K. Kawachiya, A. Koseki, T. Onodera: Lock Reservation: Java Locks can Mostly do without Atomic Operations. In <em>Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</em>, pages 130-141. ACM Press, 2002. <a href="http://dx.doi.org/10.1145/582419.582433">doi:10.1145&#x2F;582419.582433</a></p><p>[Russel06] K. Russell, D. Detlefs: Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing. In <em>Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</em>, pages 263-272. ACM Press, 2006. <a href="http://dx.doi.org/10.1145/1167473.1167496">doi:10.1145&#x2F;1167473.1167496</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JAVA对象头与锁优化&quot;&gt;&lt;a href=&quot;#JAVA对象头与锁优化&quot; class=&quot;headerlink&quot; title=&quot;JAVA对象头与锁优化&quot;&gt;&lt;/a&gt;JAVA对象头与锁优化&lt;/h1&gt;&lt;p&gt;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：&lt;strong&gt;对象头&lt;/strong&gt;（Header）、&lt;strong&gt;实例数据&lt;/strong&gt;（Instance Data）和&lt;strong&gt;对齐填充&lt;/strong&gt;（Padding）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JAVA对象头" scheme="https://gccforstudy.github.io/tags/JAVA%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    
    <category term="锁优化" scheme="https://gccforstudy.github.io/tags/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java值传递</title>
    <link href="https://gccforstudy.github.io/2022/09/16/Java%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>https://gccforstudy.github.io/2022/09/16/Java%E5%80%BC%E4%BC%A0%E9%80%92/</id>
    <published>2022-09-16T07:38:39.000Z</published>
    <updated>2022-09-16T07:39:01.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h1><p>在开始讨论值传递之前，我们需要先来了解以下两个概念：</p><ul><li>形参&amp;实参</li><li>值传递&amp;引用传递</li></ul><span id="more"></span><h2 id="实参-amp-形参"><a href="#实参-amp-形参" class="headerlink" title="实参&amp;形参"></a>实参&amp;形参</h2><p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p><ul><li><strong>实参（实际参数）</strong> ：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li><li><strong>形参（形式参数）</strong> ：用于定义函数&#x2F;方法，接收实参，不需要有确定的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str形参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">helloWorld</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">helloWorld</span> <span class="operator">=</span> <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line">    <span class="comment">//helloWorld为实参</span></span><br><span class="line">    helloWorld(helloWorld);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h2><p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p><ul><li><strong>值传递</strong> ：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li><strong>引用传递</strong> ：是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p><h2 id="为什么Java只有值传递？"><a href="#为什么Java只有值传递？" class="headerlink" title="为什么Java只有值传递？"></a>为什么Java只有值传递？</h2><p>下面我想通过三个例子来说明Java为什么只有值传递。</p><h3 id="案例1：传递基本类型参数"><a href="#案例1：传递基本类型参数" class="headerlink" title="案例1：传递基本类型参数"></a>案例1：传递基本类型参数</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">       swap(num1, num2);</span><br><span class="line">       System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">       System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">       a = b;</span><br><span class="line">       b = temp;</span><br><span class="line">       System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">       System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">num1 = <span class="number">1</span></span><br><span class="line">num2 = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>解析：</p><p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例2。</p><h3 id="案例2：传递引用类型参数1"><a href="#案例2：传递引用类型参数1" class="headerlink" title="案例2：传递引用类型参数1"></a>案例2：传递引用类型参数1</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">     System.out.println(<span class="string">&quot;before : arr[3] = &quot;</span> + arr[<span class="number">3</span>]);</span><br><span class="line">     change(arr);</span><br><span class="line">     System.out.println(<span class="string">&quot;after : arr[3] = &quot;</span> + arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">     <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">     arr[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before : arr[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">after : arr[<span class="number">3</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>解析：</p><p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p><p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p><p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p><p>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！</p><h3 id="案例3：传递引用类型参数2"><a href="#案例3：传递引用类型参数2" class="headerlink" title="案例3：传递引用类型参数2"></a>案例3：传递引用类型参数2</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">dog11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;柯基&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">dog22</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;金毛&quot;</span>);</span><br><span class="line">    swap(dog1, dog2);</span><br><span class="line">    System.out.println(<span class="string">&quot;dog11:&quot;</span> + dog1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;dog22:&quot;</span> + dog2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Dog dog1, Dog dog2)</span> &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">temp</span> <span class="operator">=</span> dog1;</span><br><span class="line">    dog1 = dog2;</span><br><span class="line">    dog2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;dog1:&quot;</span> + dog1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;dog2:&quot;</span> + dog2.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog1:金毛</span><br><span class="line">dog2:柯基</span><br><span class="line">dog11:柯基</span><br><span class="line">dog22:金毛</span><br></pre></td></tr></table></figure><p>解析：</p><p><code>swap</code> 方法的参数 <code>dog1</code> 和 <code>dog2</code> 只是拷贝的实参 <code>dog11</code> 和 <code>dog22</code> 的地址。因此， <code>dog1</code> 和 <code>dog2</code> 互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>dog11</code> 和 <code>dog22</code> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</li><li><a href="https://www.zhihu.com/question/31203609/answer/576030121">Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎</a></li><li><a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java.html#%E5%BD%A2%E5%8F%82-%E5%AE%9E%E5%8F%82">为什么Java中只有值传递？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java值传递&quot;&gt;&lt;a href=&quot;#Java值传递&quot; class=&quot;headerlink&quot; title=&quot;Java值传递&quot;&gt;&lt;/a&gt;Java值传递&lt;/h1&gt;&lt;p&gt;在开始讨论值传递之前，我们需要先来了解以下两个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形参&amp;amp;实参&lt;/li&gt;
&lt;li&gt;值传递&amp;amp;引用传递&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java值传递机制" scheme="https://gccforstudy.github.io/tags/Java%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://gccforstudy.github.io/2022/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://gccforstudy.github.io/2022/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-04T02:49:16.000Z</published>
    <updated>2022-09-04T02:53:36.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="Pattern和Matcher类介绍"><a href="#Pattern和Matcher类介绍" class="headerlink" title="Pattern和Matcher类介绍"></a>Pattern和Matcher类介绍</h2><p>Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象。匹配结果保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象。</p><span id="more"></span><h3 id="Pattern-类的常用方法"><a href="#Pattern-类的常用方法" class="headerlink" title="Pattern 类的常用方法"></a>Pattern 类的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个字符串编译成 Pattern 对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*c&quot;</span>);</span><br><span class="line"><span class="comment">// 使用 Pattern 对象创建 Matcher 对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aac&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> m.matches();</span><br></pre></td></tr></table></figure><p>上面定义的 Pattern 对象可以多次重复使用。如果某个正则表达式仅需一次使用，则可直接使用 Pattern 类的静态 <code>matches()</code>方法，此方法自动把指定字符串编译成匿名的 Pattern 对象，并执行匹配，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Pattern.matches (<span class="string">&quot;a*c&quot;</span>,<span class="string">&quot;aac&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Matcher-类的常用方法"><a href="#Matcher-类的常用方法" class="headerlink" title="Matcher 类的常用方法"></a>Matcher 类的常用方法</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>find()</td><td>返回目标字符串中是否包含与 Pattern 匹配的子串</td></tr><tr><td>group()</td><td>返回上一次与 Pattern 匹配的子串</td></tr><tr><td>start()</td><td>返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置</td></tr><tr><td>end()</td><td>返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加 1</td></tr><tr><td>lookingAt()</td><td>返回目标字符串前面部分与 Pattern 是否匹配</td></tr><tr><td>matches()</td><td>返回整个目标字符串与 Pattern 是否匹配</td></tr><tr><td>reset()</td><td>将现有的 Matcher 对象应用于一个新的字符序列。</td></tr></tbody></table><h4 id="find-和-group-方法"><a href="#find-和-group-方法" class="headerlink" title="find()和 group()方法"></a>find()和 group()方法</h4><p>通过 Matcher 类的 <code>find()</code> 和 <code>group()</code> 方法可以从目标字符串中依次取出特定子串（匹配正则表达式的子串），例如互联网的网络爬虫，它们可以自动从网页中识别出所有的电话号码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字符串模拟从网络上得到的网页源码</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;出售JAVA教程，联系电话：13600000001&quot;</span> + <span class="string">&quot;毕业代做，联系电话：13600000002&quot;</span> + <span class="string">&quot;出售二手电脑，联系电话：15800000001&quot;</span>;</span><br><span class="line">   <span class="comment">// 创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line">   <span class="comment">// 该正则表达式只抓取13X和15X段的手机号</span></span><br><span class="line">   <span class="comment">// 实际要抓取哪些电话号码，只要修改正则表达式即可</span></span><br><span class="line">   <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;((13\\d)|(15\\d))\\d&#123;8&#125;&quot;</span>).matcher(str);</span><br><span class="line">   <span class="comment">// 将所有符合正则表达式的子串（电话号码）全部输出</span></span><br><span class="line">   <span class="keyword">while</span> (m.find())</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(m.group());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面运行结果可以看出，<code>find()</code> 方法依次查找字符串中与 Pattern 匹配的子串，一旦找到对应的子串，下次调用 <code>find()</code> 方法时将接着向下查找。</p><h4 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start()和 end()方法"></a>start()和 end()方法</h4><p><code>find()</code> 方法还可以传入一个 int 类型的参数，带 int 参数的 <code>find()</code> 方法将从该 int 索引处向下搜索。<code>start()</code> 和 <code>end() </code>方法主要用于确定子串在目标字符串中的位置，如下程序所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;Java is very easy!&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;目标字符串是：&quot;</span> + regStr);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>).matcher(regStr);</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(m.group() + <span class="string">&quot;子串的起始位置：&quot;</span> + m.start() + <span class="string">&quot;，其结束位置：&quot;</span> + m.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序使用 <code>find()</code>、<code>group()</code> 方法逐项取出目标字符串中与指定正则表达式匹配的子串，并使用<code>start()</code>、<code>end()</code> 方法返回子串在目标字符串中的位置。运行上面程序，看到如下运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目标字符串是：Java is very easy!</span><br><span class="line">Java子串的起始位置：<span class="number">0</span>，其结束位置：<span class="number">4</span></span><br><span class="line">is子串的起始位置：<span class="number">5</span>，其结束位置：<span class="number">7</span></span><br><span class="line">very子串的起始位置：<span class="number">8</span>，其结束位置：<span class="number">12</span></span><br><span class="line">easy子串的起始位置：<span class="number">13</span>，其结束位置：<span class="number">17</span></span><br></pre></td></tr></table></figure><h4 id="matches-和-lookingAt-方法"><a href="#matches-和-lookingAt-方法" class="headerlink" title="matches() 和 lookingAt() 方法"></a>matches() 和 lookingAt() 方法</h4><p><code>matches()</code> 和 <code>lookingAt()</code> 方法有点相似，只是 <code>matches()</code> 方法要求整个字符串和 Pattern 完全匹配时才返回 <code>true</code>，而 <code>lookingAt()</code> 只要字符串以 Pattern 开头就会返回 <code>true</code>。<code>reset()</code> 方法可将现有的 Matcher 对象应用于新的字符序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String[] mails =</span><br><span class="line">       &#123; <span class="string">&quot;mymail@163.com&quot;</span>, <span class="string">&quot;mymail@gmail.com&quot;</span>, <span class="string">&quot;mymail@myweb.org&quot;</span>, <span class="string">&quot;mymail@abc.xx&quot;</span> &#125;;</span><br><span class="line">       <span class="type">String</span> <span class="variable">mailRegEx</span> <span class="operator">=</span> <span class="string">&quot;\\w&#123;3,20&#125;@\\w+\\.(com|org|cn|net|gov)&quot;</span>;</span><br><span class="line">       <span class="type">Pattern</span> <span class="variable">mailPattern</span> <span class="operator">=</span> Pattern.compile(mailRegEx);</span><br><span class="line">       <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (String mail : mails)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (matcher == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               matcher = mailPattern.matcher(mail);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               matcher.reset(mail);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mail + (matcher.matches() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;不是&quot;</span>) + <span class="string">&quot;一个有效的邮件地址！&quot;</span>;</span><br><span class="line">           System.out.println(result);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>上面程序创建了一个邮件地址的 Pattern，接着用这个 Pattern 与多个邮件地址进行匹配。当程序中的 Matcher 为 <code>null</code> 时，程序调用 <code>matcher()</code> 方法来创建一个 Matcher 对象，一旦 Matcher 对象被创建，程序就调用 Matcher 的 <code>reset()</code> 方法将该 Matcher 应用于新的字符序列。</p><p>从某个角度来看，Matcher 的 <code>matches()</code>、<code>lookingAt()</code> 和 String 类的 <code>equals()</code> 有点相似。区别是 String 类的 <code>equals()</code> 都是与字符串进行比较，而 Matcher 的 <code>matches()</code> 和 <code>lookingAt()</code> 则是与正则表达式进行匹配。</p><p>事实上，String 类里也提供了 <code>matches()</code> 方法，该方法返回该字符串是否匹配指定的正则表达式。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mymail@163.com&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,20&#125;@\\w+\\.(com|org|cn|net|gov)&quot;</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在Matcher类中，<code>matches()</code>是必须全部匹配；<code>lookingAt()</code>匹配的字符必须要在字符串的最前面；<code>find()</code>匹配的字符可以在字符串的任意的地方。</p><p><code>start()</code>、<code>end()</code>、<code>group()</code>这三个方法必须是在有字符匹配到的条件下才能够调用，否则会报错。<code>start()</code>返回匹配到的子字符串在字符串中的索引位置，<code>end()</code>返回匹配到的子字符串的最后一个字符在字符串中的索引位置，<code>group()</code>返回匹配到的子字符串。另外，<code>start()</code>、<code>end()</code>、<code>group()</code>均有一个重载方法它们是<code>start(int group)</code>、<code>end(int group)</code>、<code>group(int group)</code>专用于分组操作。最后，Mathcer类还有一个<code>groupCount()</code>用于返回有多少组。</p><blockquote><p>举个例子来说明一下什么是分组：下面这个matcher对象有5个分组，每对括号就代表一个分组，并且groupCount()不会把整个正则表达式记录在内即group(0)不会被记录在内。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;([a-zA-Z0-9]+)([\\s]+)([a-zA-Z ]+)([\\s]+)([0-9]+)&quot;</span>);</span><br><span class="line">       <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       System.out.println(matcher.groupCount());</span><br></pre></td></tr></table></figure><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><table><thead><tr><th align="center">元字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">将下一个字符标记符、或一个向后引用、或一个八进制转义符。</td></tr><tr><td align="center">^</td><td align="center">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td align="center">$</td><td align="center">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td align="center">*</td><td align="center">匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，“zo”以及“zoo”。</em>等价于{0,}</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次(大于等于1次)。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td align="center">?</td><td align="center">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td align="center">{n}</td><td align="center">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td align="center">{n,}</td><td align="center">n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td align="center">{n,m}</td><td align="center">m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="center">x|y</td><td align="center">匹配x或y。</td></tr><tr><td align="center">[xyz]</td><td align="center">字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td align="center">[^xyz]</td><td align="center">负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td align="center">[a-z]</td><td align="center">字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td></tr><tr><td align="center">[^a-z]</td><td align="center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td align="center">.</td><td align="center">可以匹配任何字符</td></tr><tr><td align="center">\d</td><td align="center">匹配一个数字字符。等价于[0-9]</td></tr><tr><td align="center">\D</td><td align="center">匹配一个非数字字符。等价于[^0-9]</td></tr><tr><td align="center">\s</td><td align="center">匹配所有的空白字符，包括空格、制表符、换页符、换行符、回车符 等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td align="center">\S</td><td align="center">匹配所有的非空白字符</td></tr></tbody></table><p>大家可以去<a href="https://jex.im/regulex/#!flags=&re=">正则表达式可视化工具</a>测试一下</p><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><p><strong>.</strong>  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p><p><strong>.</strong>  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p><p>正则表达式一般是区分大小写的，但是也有些实现是不区分。</p><p>正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nam.</span><br></pre></td></tr></table></figure><p>匹配结果：</p><p><img src="%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6.png"></p><h2 id="匹配一组字符"><a href="#匹配一组字符" class="headerlink" title="匹配一组字符"></a>匹配一组字符</h2><p><strong>[ ]</strong>  定义一个字符集合；</p><p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p><p><strong>-</strong>  只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p><p><strong>^</strong>  在 [ ] 中是取非操作。</p><p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc[^<span class="number">0</span>-<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>匹配结果：</p><p><img src="%E5%8C%B9%E9%85%8D%E4%B8%80%E7%BB%84%E5%AD%97%E7%AC%A6.png"></p><h2 id="使用元字符"><a href="#使用元字符" class="headerlink" title="使用元字符"></a>使用元字符</h2><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[\b]</td><td align="center">回退(删除)一个字符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr></tbody></table><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n。</p><p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它将匹配两个连续的行尾标签，而这正是两条记录之间的空白行；</p><h3 id="匹配特定的字符类别"><a href="#匹配特定的字符类别" class="headerlink" title="匹配特定的字符类别"></a>匹配特定的字符类别</h3><h4 id="数字元字符"><a href="#数字元字符" class="headerlink" title="数字元字符"></a>数字元字符</h4><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\d</td><td align="center">数字字符，等价于 [0-9]</td></tr><tr><td align="center">\D</td><td align="center">非数字字符，等价于 [^0-9]</td></tr></tbody></table><h4 id="字母数字元字符"><a href="#字母数字元字符" class="headerlink" title="字母数字元字符"></a>字母数字元字符</h4><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\w</td><td align="center">大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td></tr><tr><td align="center">\W</td><td align="center">对 \w 取非</td></tr></tbody></table><h4 id="空白字符元字符"><a href="#空白字符元字符" class="headerlink" title="空白字符元字符"></a>空白字符元字符</h4><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\s</td><td align="center">任何一个空白字符，等价于 [\f\n\r\t\v]</td></tr><tr><td align="center">\S</td><td align="center">对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10，等价于 \n。</p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><ul><li><strong>+</strong> 匹配 1 个或者多个字符</li><li><strong>*</strong> 匹配 0 个或者多个</li><li><strong>?</strong> 匹配 0 个或者 1 个</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\w.]+@\w+\.\w+</span><br></pre></td></tr></table></figure><p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p><p>匹配结果：</p><p><img src="%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D.png"></p><ul><li><strong>{n}</strong> 匹配 n 个字符</li><li><strong>{m, n}</strong> 匹配 m~n 个字符</li><li><strong>{m,}</strong> 至少匹配 m 个字符</li></ul><p>* 和 + 都是贪婪型元字符，会匹配最多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.+c</span><br></pre></td></tr></table></figure><p>由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。</p><p>匹配结果：</p><p><img src="%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D.png"></p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="单词的边界"><a href="#单词的边界" class="headerlink" title="单词的边界"></a>单词的边界</h3><p><strong>\b</strong> 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。（即\w和\w或\W和\W之间的位置）</p><p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p><p>详细解释大家可以查阅<a href="https://www.cnblogs.com/tnt-33/p/10676473.html">这篇文章</a></p><h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h3><p><strong>^</strong> 匹配整个字符串的开头，**$** 匹配结尾。</p><p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p><p>分行匹配模式(multiline)下，换行被当做字符串的边界。</p><h2 id="使用子表达式"><a href="#使用子表达式" class="headerlink" title="使用子表达式"></a>使用子表达式</h2><p>使用 <strong>( )</strong> 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p><p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ab)&#123;<span class="number">2</span>,&#125;</span><br></pre></td></tr></table></figure><p>匹配结果：ababab…</p><p><strong>|</strong> 是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">19</span>|<span class="number">20</span>)\d&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>匹配结果：1900、2010</p><h2 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h2><p>回溯引用使用 <strong>\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p><p>应用：匹配 HTML 中合法的标题元素。</p><p>正则表达式：</p><p>\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(h[<span class="number">1</span>-<span class="number">6</span>])&gt;\w*?&lt;\/\<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>匹配结果：</p><p><img src="%E5%9B%9E%E6%BA%AF%E5%BC%95%E7%94%A8.png"></p><p>顺便提一下，如果你不清楚?的作用，那么你需要回看一下重复匹配这节内容。</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>需要用到两个正则表达式。</p><p>举例如下：</p><p>查找正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;<span class="number">3</span>&#125;)(-)(\d&#123;<span class="number">3</span>&#125;)(-)(\d&#123;<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><p>替换正则表达式:</p><p>在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($<span class="number">1</span>) $<span class="number">3</span>-$<span class="number">5</span></span><br></pre></td></tr></table></figure><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;313-555-1234&quot;</span>.replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)(-)(\\d&#123;3&#125;)(-)(\\d&#123;4&#125;)&quot;</span>, <span class="string">&quot;($1) $3-$5&quot;</span>);</span><br><span class="line">       System.out.println(s);</span><br></pre></td></tr></table></figure><p>结果：(313) 555-1234</p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\l</td><td align="center">把下个字符转换为小写</td></tr><tr><td align="center">\u</td><td align="center">把下个字符转换为大写</td></tr><tr><td align="center">\L</td><td align="center">把\L 和\E 之间的字符全部转换为小写</td></tr><tr><td align="center">\U</td><td align="center">把\U 和\E 之间的字符全部转换为大写</td></tr><tr><td align="center">\E</td><td align="center">结束\L 或者\U</td></tr></tbody></table><p>举例如下：</p><p>文本</p><p>abcd</p><p>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w)(\w&#123;<span class="number">2</span>&#125;)(\w)</span><br></pre></td></tr></table></figure><p>替换</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1\U$2\E$3</span><br></pre></td></tr></table></figure><p>结果</p><p>aBCd</p><h2 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h2><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用  <strong>?&#x3D;</strong>  来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?&#x3D; 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;&#x3D; 定义(注: javaScript 不支持向后匹配, java 对其支持也不完善)。</p><p>举例如下：</p><p>查找出邮件地址 @ 字符前面的部分。</p><p>文本</p><p>abc @qq.com</p><p>正则表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\w+(?=@)</span><br></pre></td></tr></table></figure><p><strong>abc</strong> @qq.com</p><p>对向前和向后查找取非，只要把 &#x3D; 替换成 ! 即可，比如 (?&#x3D;) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容</p><h2 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h2><h3 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h3><p>条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p><p>正则表达式</p><p>子表达式 (() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\()?abc(?(<span class="number">1</span>)\))</span><br></pre></td></tr></table></figure><p>结果：（abc）匹配、abc匹配、（abc不匹配</p><h3 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h3><p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p><p>正则表达式</p><p>?(?&#x3D;-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;<span class="number">5</span>&#125;(?(?=-)-\d&#123;<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><p>结果：11111匹配、22222-不匹配、33333-4444匹配</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.</li><li><a href="https://pdai.tech/md/develop/regex/dev-regex-all.html">https://pdai.tech/md/develop/regex/dev-regex-all.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;Pattern和Matcher类介绍&quot;&gt;&lt;a href=&quot;#Pattern和Matcher类介绍&quot; class=&quot;headerlink&quot; title=&quot;Pattern和Matcher类介绍&quot;&gt;&lt;/a&gt;Pattern和Matcher类介绍&lt;/h2&gt;&lt;p&gt;Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象。匹配结果保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="正则表达式" scheme="https://gccforstudy.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>log4j2配置详解</title>
    <link href="https://gccforstudy.github.io/2022/09/02/log4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://gccforstudy.github.io/2022/09/02/log4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-09-02T08:23:50.000Z</published>
    <updated>2022-09-04T02:51:43.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="log4j2配置详解"><a href="#log4j2配置详解" class="headerlink" title="log4j2配置详解"></a>log4j2配置详解</h1><h2 id="log4j2介绍"><a href="#log4j2介绍" class="headerlink" title="log4j2介绍"></a>log4j2介绍</h2><p>log4j2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,”.json”或者”.jsn”。<br>配置文件的格式：log2j配置文件可以是xml格式的，也可以是json格式的。<br>配置文件的位置：log4j2默认会在classpath目录下寻找log4j2.xml、log4j.json、log4j.jsn等名称的文件。<br>系统选择配置文件的优先级(从先到后)如下：<br>　　(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件.<br>　　(2).classpath下的名为log4j2-test.xml的文件.<br>　　(3).classpath下名为log4j2.json 或者log4j2.jsn的文件.<br>　　(4).classpath下名为log4j2.xml的文件.<br>　　我们一般默认使用log4j2.xml进行命名。</p><span id="more"></span><h2 id="配置文件节点解析"><a href="#配置文件节点解析" class="headerlink" title="配置文件节点解析"></a>配置文件节点解析</h2><p>根节点Configuration有两个属性：</p><ul><li>status：用来指定log4j本身的打印日志的级别</li><li>monitorinterval：用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s</li></ul><p>两个子节点:</p><ul><li>Appenders</li><li>Loggers(表明可以定义多个Appender和Logger).</li></ul><h3 id="Appenders节点"><a href="#Appenders节点" class="headerlink" title="Appenders节点"></a>Appenders节点</h3><p>常见的有三种子节点:Console、RollingFile、File。Console节点用来定义输出到控制台的Appender。</p><h4 id="Console节点"><a href="#Console节点" class="headerlink" title="Console节点"></a>Console节点</h4><p>Console节点用来定义输出到控制台的Appender</p><ul><li>name:指定Appender的名字.</li><li>target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.</li><li>PatternLayout:输出格式，不设置默认为:%m%n.</li></ul><h4 id="File节点"><a href="#File节点" class="headerlink" title="File节点"></a>File节点</h4><p>File节点用来定义输出到指定位置的文件的Appender。</p><ul><li>name:指定Appender的名字.</li><li>fileName:指定输出日志的目的文件带全路径的文件名.</li><li>PatternLayout:输出格式，不设置默认为:%m%n.</li></ul><h4 id="RollingFile节点"><a href="#RollingFile节点" class="headerlink" title="RollingFile节点"></a>RollingFile节点</h4><p>RollingFile节点用来定义超过指定条件自动删除旧的创建新的Appender。</p><ul><li>name:指定Appender的名字.</li><li>fileName:指定输出日志的目的文件带全路径的文件名.</li><li>PatternLayout:输出格式，不设置默认为:%m%n.</li><li>filePattern : 指定当发生Rolling时，文件的转移和重命名规则.</li><li>Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志.</li><li>TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate&#x3D;true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am.</li><li>SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小.</li><li>DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。</li></ul><h3 id="Loggers节点"><a href="#Loggers节点" class="headerlink" title="Loggers节点"></a>Loggers节点</h3><p>Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</p><ul><li>Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。</li><li>level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.</li><li>name:用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点.</li><li>AppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity&#x3D;”false”只在自定义的Appender中进行输出。</li></ul><h2 id="配置参数解释"><a href="#配置参数解释" class="headerlink" title="配置参数解释"></a>配置参数解释</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>trace</td><td>追踪，就是程序推进一下，可以写个trace输出</td></tr><tr><td>debug</td><td>调试，一般作为最低级别，trace基本不用。</td></tr><tr><td>info</td><td>输出重要的信息，使用较多</td></tr><tr><td>warn</td><td>警告，有些信息不是错误信息，但也要给程序员一些提示。</td></tr><tr><td>error</td><td>错误信息。用的也很多。</td></tr><tr><td>fatal</td><td>致命错误</td></tr></tbody></table><h3 id="输出源"><a href="#输出源" class="headerlink" title="输出源"></a>输出源</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>CONSOLE</td><td>输出到控制台</td></tr><tr><td>FILE</td><td>输出到文件</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>SimpleLayout</td><td>以简单的形式显示</td></tr><tr><td>HTMLLayout</td><td>以HTML表格显示</td></tr><tr><td>PatternLayout</td><td>自定义形式显示</td></tr></tbody></table><p>PatternLayout自定义日志布局：</p><table><thead><tr><th align="center">格式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%d{HH:mm:ss.SSS}</td><td align="center">表示输出到毫秒的时间</td></tr><tr><td align="center">%t</td><td align="center">输出当前线程名称</td></tr><tr><td align="center">%-5level</td><td align="center">输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0</td></tr><tr><td align="center">%logger</td><td align="center">输出logger名称</td></tr><tr><td align="center">%msg</td><td align="center">日志文本</td></tr><tr><td align="center">%n</td><td align="center">换行</td></tr><tr><td align="center">%F</td><td align="center">输出所在的类文件名，如Log4j2Test.java</td></tr><tr><td align="center">%L</td><td align="center">输出行号</td></tr><tr><td align="center">%M</td><td align="center">输出所在方法名</td></tr><tr><td align="center">%l</td><td align="center">输出语句所在的行数, 包括类名、方法名、文件名、行数</td></tr></tbody></table><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--变量配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的日志路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的项目名&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;Filelog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/test.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileInfo&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/info.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileWarn&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/warn.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileError&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/error.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--监控系统信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Filelog&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileWarn&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileError&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/8mEU5ofwQPWA14JbtmQNrw">https://mp.weixin.qq.com/s/8mEU5ofwQPWA14JbtmQNrw</a></li><li><a href="https://www.cnblogs.com/keeya/p/10101547.html">https://www.cnblogs.com/keeya/p/10101547.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;log4j2配置详解&quot;&gt;&lt;a href=&quot;#log4j2配置详解&quot; class=&quot;headerlink&quot; title=&quot;log4j2配置详解&quot;&gt;&lt;/a&gt;log4j2配置详解&lt;/h1&gt;&lt;h2 id=&quot;log4j2介绍&quot;&gt;&lt;a href=&quot;#log4j2介绍&quot; class=&quot;headerlink&quot; title=&quot;log4j2介绍&quot;&gt;&lt;/a&gt;log4j2介绍&lt;/h2&gt;&lt;p&gt;log4j2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,”.json”或者”.jsn”。&lt;br&gt;配置文件的格式：log2j配置文件可以是xml格式的，也可以是json格式的。&lt;br&gt;配置文件的位置：log4j2默认会在classpath目录下寻找log4j2.xml、log4j.json、log4j.jsn等名称的文件。&lt;br&gt;系统选择配置文件的优先级(从先到后)如下：&lt;br&gt;　　(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件.&lt;br&gt;　　(2).classpath下的名为log4j2-test.xml的文件.&lt;br&gt;　　(3).classpath下名为log4j2.json 或者log4j2.jsn的文件.&lt;br&gt;　　(4).classpath下名为log4j2.xml的文件.&lt;br&gt;　　我们一般默认使用log4j2.xml进行命名。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日志" scheme="https://gccforstudy.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>JSON</title>
    <link href="https://gccforstudy.github.io/2022/08/31/JSON/"/>
    <id>https://gccforstudy.github.io/2022/08/31/JSON/</id>
    <published>2022-08-31T06:04:19.000Z</published>
    <updated>2022-08-31T06:05:39.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><ul><li>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</li><li>JSON 是轻量级的文本数据交换格式</li><li>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</li><li>JSON 具有自我描述性，更易理解</li></ul><span id="more"></span><h2 id="结构与类型"><a href="#结构与类型" class="headerlink" title="结构与类型"></a>结构与类型</h2><ul><li>只有两种结构：对象内的键值对集合结构和数组，对象用{}表示、内部是”key”:”value”，数组用[]表示，不同值用逗号分开</li><li>基本数值有7个： false &#x2F; null &#x2F; true &#x2F; object &#x2F; array &#x2F; number &#x2F; string</li><li>再加上结构可以嵌套，进而可以用来表达复杂的数据</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span>  <span class="number">800</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">600</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;Title&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;Thumbnail&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;Url&quot;</span><span class="punctuation">:</span>    <span class="string">&quot;http://www.example.com/image/481989943&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">125</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;100&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;IDs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116</span><span class="punctuation">,</span> <span class="number">943</span><span class="punctuation">,</span> <span class="number">234</span><span class="punctuation">,</span> <span class="number">38793</span><span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JSON优秀资源"><a href="#JSON优秀资源" class="headerlink" title="JSON优秀资源"></a>JSON优秀资源</h2><p><a href="https://github.com/burningtree/awesome-json">awesom-json</a></p><h2 id="JSON类库"><a href="#JSON类库" class="headerlink" title="JSON类库"></a>JSON类库</h2><p>Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。</p><p>下面是几个常用的 JSON 解析类库：</p><ul><li>FastJson: 阿里巴巴开发的 JSON 库，性能优秀。</li><li>Jackson: 社区十分活跃且更新速度很快。</li><li>Gson: 谷歌开发的 JSON 库，功能十分全面。</li></ul><p>下面将详细介绍Jackson和Gson，不推荐使用FastJson，对FastJson感兴趣的小伙伴可以自行查阅资料。</p><h2 id="JackSon"><a href="#JackSon" class="headerlink" title="JackSon"></a>JackSon</h2><h3 id="JackSon简介"><a href="#JackSon简介" class="headerlink" title="JackSon简介"></a>JackSon简介</h3><ul><li><a href="https://github.com/FasterXML/jackson">Jackson Github </a> </li><li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson Wiki </a></li><li><a href="https://github.com/FasterXML/jackson-docs">Jackson 文档 </a></li></ul><h3 id="JackSon组件"><a href="#JackSon组件" class="headerlink" title="JackSon组件"></a>JackSon组件</h3><ul><li><strong>Streaming</strong>: jackson-core jar，定义了底层的streaming API和实现了Json特性。</li><li><strong>Annotations</strong>: jackson-annotations jar，包含了标准的Jackson注解。本文暂不介绍。</li><li><strong>Databind</strong>: jackson-databind jar，实现了数据绑定和对象序列化，它依赖于streaming和annotations的包。</li></ul><h3 id="JackSon的使用"><a href="#JackSon的使用" class="headerlink" title="JackSon的使用"></a>JackSon的使用</h3><p>引用maven jar包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本自选--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="序列化一个对象成JSON字符串"><a href="#序列化一个对象成JSON字符串" class="headerlink" title="序列化一个对象成JSON字符串"></a>序列化一个对象成JSON字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;gcc&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;JSON:&quot;</span> + jsonStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：JSON:&#123;&quot;username&quot;:&quot;gcc&quot;,&quot;password&quot;:&quot;admin&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="反序列化一个JSON字符串成Java对象"><a href="#反序列化一个JSON字符串成Java对象" class="headerlink" title="反序列化一个JSON字符串成Java对象"></a>反序列化一个JSON字符串成Java对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toObj</span><span class="params">()</span> <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputJsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;gcc\&quot;,\&quot;password\&quot;:\&quot;admin\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(inputJsonStr, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user info:&quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果JSON字符串中有无法对应的字段，readValue方法会抛出JsonMappingException异常</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a>@JsonProperty</h4><p>@JsonProperty注解主要用于实体类的属性上,作用可以简单的理解为在反序列化的时候给属性重命名(多一个名字来识别)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty(&quot;user_name&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username; <span class="comment">//这时可以在反序列化时写user_name，同样会映射到username字段</span></span><br></pre></td></tr></table></figure><h4 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h4><p>@JsonIgnore注解被用来标注在某个属性上，在序列化时，被标注的属性会被忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanWithIgnore</span> &#123;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在序列化时id字段不会被序列化</p><h4 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a>@JsonInclude</h4><p>@JsonInclude注解可以用来在序列化时，排除掉某些属性，即不序列化某些属性</p><p>@JsonInclude注解有两个很重要的属性，源码如下(只列出了一分部源码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonInclude</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inclusion rule to use for instances (values) of types (Classes) or</span></span><br><span class="line"><span class="comment">     * properties annotated; defaults to &#123;<span class="doctag">@link</span> Include#ALWAYS&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Include <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Include.ALWAYS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inclusion rule to use for entries (&quot;content&quot;) of annotated</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.util.Map&#125;s and referential types (like</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.util.concurrent.atomic.AtomicReference&#125;);</span></span><br><span class="line"><span class="comment">     * defaults to &#123;<span class="doctag">@link</span> Include#ALWAYS&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Include <span class="title function_">content</span><span class="params">()</span> <span class="keyword">default</span> Include.ALWAYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value属性用来定义排除规则，content属性用来定义map集合中entry的排除规则（排除规则在@JsonInclude源码的枚举类Include中，大家可以自行查阅），如果你想对map集合进行排除规则的设置，你既需要设置value，也需要设置content。因为value仅可以设置对map集合本身的排除规则，而content可以设置对map集合中entry的排除规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span> &#123;</span><br><span class="line">    <span class="meta">@JsonInclude(value=Include.NON_EMPTY, content=Include.NON_NULL)</span></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String,String&gt; entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的@JsonInclude注解表示，只有当entries不为空，才序列化entries集合中的不为null的entry。</p><h4 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h4><p>可以定制某个字段使用自定义的字段转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要被序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventWithSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonSerialize(using = CustomDateSerializer.class)</span></span><br><span class="line">    <span class="keyword">public</span> Date eventDate;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">EventWithSerializer</span><span class="params">(String name, Date evenDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.evenDate = evenDate;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制化的序列器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDateSerializer</span> <span class="keyword">extends</span> <span class="title class_">StdSerializer</span>&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">formatter</span> </span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateSerializer</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateSerializer</span><span class="params">(Class&lt;Date&gt; t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(t); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(</span></span><br><span class="line"><span class="params">      Date value, JsonGenerator gen, SerializerProvider arg2)</span> </span><br><span class="line">      <span class="keyword">throws</span> IOException, JsonProcessingException &#123;</span><br><span class="line">        gen.writeString(formatter.format(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenSerializingUsingJsonSerialize_thenCorrect</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> JsonProcessingException, ParseException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">df</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">toParse</span> <span class="operator">=</span> <span class="string">&quot;20-12-2014 02:30:00&quot;</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(toParse);</span><br><span class="line">    <span class="type">EventWithSerializer</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventWithSerializer</span>(<span class="string">&quot;party&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(event);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：{“name”:”party”,”evenDate”:”20-12-2014 02:30:00”}</p><p>我们发现evenDate字段在序列化的时候是按照CustomDateSerializer的formatter格式化的。</p><h4 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h4><p>与@JsonSerialize注解的操作大致是一样的，可以指定某个属性在反序列化时，使用特定的Deserializer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventWithSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonDeserialize(using = CustomDateDeserializer.class)</span></span><br><span class="line">    <span class="keyword">public</span> Date eventDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义的deserializer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDateDeserializer</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">StdDeserializer</span>&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">formatter</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateDeserializer</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateDeserializer</span><span class="params">(Class&lt;?&gt; vc)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(vc); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">deserialize</span><span class="params">(</span></span><br><span class="line"><span class="params">      JsonParser jsonparser, DeserializationContext context)</span> </span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> jsonparser.getText();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> formatter.parse(date);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenDeserializingUsingJsonDeserialize_thenCorrect</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span></span><br><span class="line">      <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>name<span class="string">&quot;:&quot;</span>party<span class="string">&quot;,&quot;</span>eventDate<span class="string">&quot;:&quot;</span><span class="number">20</span>-<span class="number">12</span>-<span class="number">2014</span> <span class="number">02</span>:<span class="number">30</span>:<span class="number">00</span><span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">df</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">EventWithSerializer</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>()</span><br><span class="line">      .readerFor(EventWithSerializer.class)</span><br><span class="line">      .readValue(json);</span><br><span class="line">    </span><br><span class="line">    assertEquals(</span><br><span class="line">      <span class="string">&quot;20-12-2014 02:30:00&quot;</span>, df.format(event.eventDate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h4><p>@JsonAutoDetect可以标注在类上，覆盖类中属性的可见性。比如你可以通过在类上标注@JsonAutoDetect(fieldVisibility &#x3D; Visibility.ANY)来序列化类中的所有属性，因为私有的属性在默认情况下不会被序列化。（默认情况下只有public属性才会被序列化）</p><h4 id="JsonRawValue"><a href="#JsonRawValue" class="headerlink" title="@JsonRawValue"></a>@JsonRawValue</h4><p>被@JsonRawValue标注的属性可以被原封不动的输出，原封不动指的是直接输出字符串中的内容且进行转义（不包括字符串的双引号），如果不加@JsonRawValue注解，输出的字符串内部不会转义也不会去掉最外部的双引号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如有字符串&quot;\&quot;hello: \&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加@JsonRawValue时，序列化的输出为&quot;hello: &quot;world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不加@JsonRawValue时，序列化的输出为 &quot;\&quot;hello: \&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JsonValue"><a href="#JsonValue" class="headerlink" title="@JsonValue"></a>@JsonValue</h4><p>@JsonValue用在方法上，序列化时用该方法序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TypeEnumWithValue</span> &#123;</span><br><span class="line">    TYPE1(<span class="number">1</span>, <span class="string">&quot;Type A&quot;</span>), TYPE2(<span class="number">2</span>, <span class="string">&quot;Type 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    TypeEnumWithValue(<span class="type">int</span> i, String s) &#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException, ParseException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">enumAsString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>()</span><br><span class="line">                .writeValueAsString(TypeEnumWithValue.TYPE1);</span><br><span class="line"></span><br><span class="line">        System.out.println(enumAsString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出为：”Type A”</p><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><h3 id="Gson介绍"><a href="#Gson介绍" class="headerlink" title="Gson介绍"></a>Gson介绍</h3><p>Gson是这样一个Java类库，它可以将Java对象转换为相应的JSON形式，也可以将JSON字符串转换为对应的Java对象。 Gson可以使用任意Java对象，包括哪些预先存在的、不在你的源代码中的对象（因此，你并不知道对象的属性）。</p><ul><li><a href="https://www.jianshu.com/p/1e20b28c39d1">Gson用户指南（中文翻译）</a></li></ul><h3 id="Gson的使用"><a href="#Gson的使用" class="headerlink" title="Gson的使用"></a>Gson的使用</h3><p>使用Gson的首要类是Gson类，你可以仅仅通过new Gson()的方式创建它。你也可以通过GsonBuilder类去创建Gson实例，这个类允许你进行一系列配置，例如版本控制等等。</p><p>Gson实例不会保存任何进行Json操作时的状态。因此，你可以自由的复用相同的Gson对象进行诸多的Json序列化和反序列化操作。</p><p>引用maven jar包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多关于Gson序列化和反序列化的操作，大家可以参考<a href="https://www.jianshu.com/p/1e20b28c39d1">Gson用户指南</a>或<a href="https://link.jianshu.com/?t=https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a></li><li><a href="https://www.runoob.com/w3cnote/fastjson-intro.htm">https://www.runoob.com/w3cnote/fastjson-intro.htm</a></li><li><a href="https://blog.csdn.net/m0_37076574/article/details/81317403">https://blog.csdn.net/m0_37076574/article/details/81317403</a></li><li><a href="https://blog.csdn.net/blueheart20/article/details/52212221">https://blog.csdn.net/blueheart20/article/details/52212221</a></li><li><a href="https://blog.csdn.net/gjb724332682/article/details/51586701">https://blog.csdn.net/gjb724332682/article/details/51586701</a></li><li><a href="https://www.jianshu.com/p/1e20b28c39d1">https://www.jianshu.com/p/1e20b28c39d1</a></li><li><a href="https://www.jianshu.com/p/923a9fe78108">https://www.jianshu.com/p/923a9fe78108</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h1&gt;&lt;h2 id=&quot;JSON是什么&quot;&gt;&lt;a href=&quot;#JSON是什么&quot; class=&quot;headerlink&quot; title=&quot;JSON是什么&quot;&gt;&lt;/a&gt;JSON是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）&lt;/li&gt;
&lt;li&gt;JSON 是轻量级的文本数据交换格式&lt;/li&gt;
&lt;li&gt;JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。&lt;/li&gt;
&lt;li&gt;JSON 具有自我描述性，更易理解&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="JSON" scheme="https://gccforstudy.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC视图解析器</title>
    <link href="https://gccforstudy.github.io/2022/08/28/SpringMVC%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>https://gccforstudy.github.io/2022/08/28/SpringMVC%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/</id>
    <published>2022-08-28T03:28:42.000Z</published>
    <updated>2022-08-28T03:37:49.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更好地理解SpringMVC的工作流程，深入学习视图解析器是非常有必要的。希望这篇文章可以帮助大家更好地了解视图解析器。</p><span id="more"></span><p>当我们对<a href="https://so.csdn.net/so/search?q=SpringMVC&spm=1001.2101.3001.7020">SpringMVC</a>控制的资源发起请求时，这些请求都会被SpringMVC的DispatcherServlet处理，接着Spring会分析看哪一个HandlerMapping定义的所有请求映射中存在对该请求的最合理的映射。然后通过该HandlerMapping取得其对应的Handler，接着再通过相应的HandlerAdapter处理该Handler。HandlerAdapter在对Handler进行处理之后会返回一个ModelAndView对象。在获得了ModelAndView对象之后，Spring就需要把该View渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是ViewResolver和View。当Handler返回的ModelAndView中不包含真正的视图，只返回一个逻辑视图名称的时候，ViewResolver就会把该逻辑视图名称解析为真正的视图View对象。View是真正进行视图渲染，把结果返回给浏览器的。</p><h2 id="ViewResolver和View"><a href="#ViewResolver和View" class="headerlink" title="ViewResolver和View"></a>ViewResolver和View</h2><p><em>SpringMVC</em>用于处理视图最重要的两个接口是<em>ViewResolver</em>和<em>View</em>。<em>ViewResolver</em>的主要作用是把一个逻辑上的视图名称解析为一个真正的视图，<em>SpringMVC</em>中用于把<em>View</em>对象呈现给客户端的是<em>View</em>对象本身，而<em>ViewResolver</em>只是把逻辑视图名称解析为对象的<em>View</em>对象。<em>View</em>接口的主要作用是用于处理视图，然后返回给客户端。</p><p><em>Spring</em>为我们提供了非常多的视图解析器，下面将列举一些视图解析器。</p><h3 id="AbstractCachingViewResolver"><a href="#AbstractCachingViewResolver" class="headerlink" title="AbstractCachingViewResolver"></a>AbstractCachingViewResolver</h3><p><em><strong>AbstractCachingViewResolver</strong></em>：这是一个抽象类，这种视图解析器会把它曾经解析过的视图保存起来，然后每次要解析视图的时候先从缓存里面找，如果找到了对应的视图就直接返回，如果没有就创建一个新的视图对象，然后把它放到一个用于缓存的<em>map</em>中，接着再把新建的视图返回。使用这种视图缓存的方式可以把解析视图的性能问题降到最低。</p><h3 id="UrlBasedViewResolver"><a href="#UrlBasedViewResolver" class="headerlink" title="UrlBasedViewResolver"></a>UrlBasedViewResolver</h3><p><em><strong>UrlBasedViewResolver</strong></em>：它是对<em>ViewResolver</em>的一种简单实现，而且继承了<em>AbstractCachingViewResolver</em>，主要就是提供的一种拼接<em>URL</em>的方式来解析视图，它可以让我们通过<em>prefix</em>属性指定一个指定的前缀，通过<em>suffix</em>属性指定一个指定的后缀，然后把返回的逻辑视图名称加上指定的前缀和后缀就是指定的视图<em>URL</em>了。如<em>prefix&#x3D;&#x2F;WEB-INF&#x2F;jsps&#x2F;<em>，</em>suffix&#x3D;.jsp</em>，返回的视图名称<em>viewName&#x3D;test&#x2F;indx</em>，则<em>UrlBasedViewResolver</em>解析出来的视图<em>URL</em>就是*&#x2F;WEB-INF&#x2F;jsps&#x2F;test&#x2F;index.jsp<em>。默认的</em>prefix<em>和</em>suffix<em>都是空串。</em>URLBasedViewResolver<em>支持返回的视图名称中包含</em>redirect:*前缀，这样就可以支持*URL<em>在客户端的跳转，如当返回的视图名称是</em>”redirect:test.do”<em>的时候，</em>URLBasedViewResolver<em>发现返回的视图名称包含</em>”redirect:”<em>前缀，于是把返回的视图名称前缀</em>”redirect:”<em>去掉，取后面的</em>test.do<em>组成一个</em>RedirectView<em>，</em>RedirectView<em>中将把请求返回的模型属性组合成查询参数的形式组合到</em>redirect<em>的</em>URL<em>后面，然后调用</em>HttpServletResponse<em>对象的</em>sendRedirect<em>方法进行重定向。同样</em>URLBasedViewResolver<em>还支持</em>forword:<em>前缀，对于视图名称中包含</em>forword:<em>前缀的视图名称将会被封装成一个</em>InternalResourceView<em>对象，然后在服务器端利用</em>RequestDispatcher<em>的</em>forword<em>方式跳转到指定的地址。使用</em>UrlBasedViewResolver<em>的时候必须指定属性</em>viewClass<em>，表示解析成哪种视图，一般使用较多的就是</em>InternalResourceView<em>，利用它来展现</em>jsp<em>，但是当我们使用</em>JSTL<em>的时候我们必须使用</em>JstlView<em>。下面是一段</em>UrlBasedViewResolver<em>的定义，根据该定义，当返回的逻辑视图名称是</em>test<em>的时候，</em>UrlBasedViewResolver<em>将把逻辑视图名称加上定义好的前缀和后缀，即“</em>&#x2F;WEB-INF&#x2F;test.jsp<em>”，然后新建一个</em>viewClass<em>属性指定的视图类型予以返回，即返回一个</em>url<em>为“</em>&#x2F;WEB-INF&#x2F;test.jsp<em>”的</em>InternalResourceView*对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="InternalResourceViewResolver"><a href="#InternalResourceViewResolver" class="headerlink" title="InternalResourceViewResolver"></a>InternalResourceViewResolver</h3><p><em><strong>InternalResourceViewResolver</strong></em>：它是<em>URLBasedViewResolver</em>的子类，所以<em>URLBasedViewResolver</em>支持的特性它都支持。在实际应用中<em>InternalResourceViewResolver</em>也是使用的最广泛的一个视图解析器。那么<em>InternalResourceViewResolver</em>有什么自己独有的特性呢？单从字面意思来看，我们可以把<em>InternalResourceViewResolver</em>解释为内部资源视图解析器，这就是<em>InternalResourceViewResolver</em>的一个特性。<em>InternalResourceViewResolver</em>会把返回的视图名称都解析为<em>InternalResourceView</em>对象，<em>InternalResourceView</em>会把<em>Controller</em>处理器方法返回的模型属性都存放到对应的<em>request</em>属性中，然后通过<em>RequestDispatcher</em>在服务器端把请求<em>forword</em>转发到目标<em>URL</em>。比如在<em>InternalResourceViewResolver</em>中定义了<em>prefix&#x3D;&#x2F;WEB-INF&#x2F;<em>，</em>suffix&#x3D;.jsp</em>，然后请求的<em>Controller</em>处理器方法返回的视图名称为<em>test</em>，那么这个时候<em>InternalResourceViewResolver</em>就会把<em>test</em>解析为一个<em>InternalResourceView</em>对象，先把返回的模型属性都存放到对应的<em>HttpServletRequest</em>属性中，然后利用<em>RequestDispatcher</em>在服务器端把请求<em>forword</em>到*&#x2F;WEB-INF&#x2F;test.jsp<em>。这就是</em>InternalResourceViewResolver<em>一个非常重要的特性，我们都知道存放在</em>&#x2F;WEB-INF&#x2F;<em>下面的内容是不能直接通过</em>request<em>请求的方式请求到的，为了安全性考虑，我们通常会把</em>jsp<em>文件放在</em>WEB-INF<em>目录下，而</em>InternalResourceView<em>在服务器端跳转的方式可以很好的解决这个问题。下面是一个</em>InternalResourceViewResolver<em>的定义，根据该定义当返回的逻辑视图名称是</em>test<em>的时候，</em>InternalResourceViewResolver<em>会给它加上定义好的前缀和后缀，组成“</em>&#x2F;WEB-INF&#x2F;test.jsp<em>”的形式，然后把它当做一个</em>InternalResourceView<em>的</em>url<em>新建一个</em>InternalResourceView*对象返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XmlViewResolver"><a href="#XmlViewResolver" class="headerlink" title="XmlViewResolver"></a>XmlViewResolver</h3><p><em><strong>XmlViewResolver</strong></em>：它继承自<em>AbstractCachingViewResolver</em>抽象类，所以它也是支持视图缓存的。<em>XmlViewResolver</em>需要给定一个<em>xml</em>配置文件，该文件将使用和<em>Spring</em>的<em>bean</em>工厂配置文件一样的<em>DTD</em>定义，所以其实该文件就是用来定义视图的<em>bean</em>对象的。在该文件中定义的每一个视图的<em>bean</em>对象都给定一个名字，然后<em>XmlViewResolver</em>将根据<em>Controller</em>处理器方法返回的逻辑视图名称到<em>XmlViewResolver</em>指定的配置文件中寻找对应名称的视图<em>bean</em>用于处理视图。该配置文件默认是*&#x2F;WEB-INF&#x2F;views.xml<em>文件，如果不使用默认值的时候可以在</em>XmlViewResolver<em>的</em>location<em>属性中指定它的位置。</em>XmlViewResolver<em>还实现了</em>Ordered<em>接口，因此我们可以通过其</em>order<em>属性来指定在</em>ViewResolver<em>链中它所处的位置，</em>order<em>的值越小优先级越高。以下是使用</em>XmlViewResolver*的一个示例：</p><p>（<em>1</em>）在<em>SpringMVC</em>的配置文件中加入<em>XmlViewResolver</em>的<em>bean</em>定义。使用<em>location</em>属性指定其配置文件所在的位置，<em>order</em>属性指定当有多个<em>ViewResolver</em>的时候其处理视图的优先级。关于<em>ViewResolver</em>链的问题将在后续内容中讲到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（<em>2</em>）在<em>XmlViewResolver</em>对应的配置文件中配置好所需要的视图定义。在下面的代码中我们就配置了一个名为<em>internalResource</em>的<em>InternalResourceView</em>，其<em>url</em>属性为“*&#x2F;index.jsp*”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（<em>3</em>）定义一个返回的逻辑视图名称为在<em>XmlViewResolver</em>配置文件中定义的视图名称——<em>internalResource</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/xmlViewResolver&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testXmlViewResolver</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;internalResource&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>4</em>）这样当我们访问到上面定义好的<em>testXmlViewResolver</em>处理器方法的时候返回的逻辑视图名称为“<em>internalResource</em>”，这时候<em>Spring</em>就会到定义好的<em>views.xml</em>中寻找<em>id</em>或<em>name</em>为“<em>internalResource</em>”的<em>bean</em>对象予以返回，这里<em>Spring</em>找到的是一个<em>url</em>为“*&#x2F;index.jsp<em>”的</em>InternalResourceView*对象。</p><h3 id="BeanNameViewResolver"><a href="#BeanNameViewResolver" class="headerlink" title="BeanNameViewResolver"></a>BeanNameViewResolver</h3><p><em><strong>BeanNameViewResolver</strong></em>：这个视图解析器跟<em>XmlViewResolver</em>有点类似，也是通过把返回的逻辑视图名称去匹配定义好的视图<em>bean</em>对象。不同点有二，一是<em>BeanNameViewResolver</em>要求视图<em>bean</em>对象都定义在<em>Spring</em>的<em>application context</em>(IOC容器中)中，而<em>XmlViewResolver</em>是在指定的配置文件中寻找视图<em>bean</em>对象，二是<em>BeanNameViewResolver</em>不会进行视图缓存。看一个例子，在<em>SpringMVC</em>的配置文件中定义了一个<em>BeanNameViewResolver</em>视图解析器和一个<em>id</em>为<em>test</em>的<em>InternalResourceview bean</em>对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样当返回的逻辑视图名称是 <em>test</em>的时候，就会解析为上面定义好<em>id</em>为<em>test</em>的<em>InternalResourceView</em>。</p><h3 id="ResourceBundleViewResolver"><a href="#ResourceBundleViewResolver" class="headerlink" title="ResourceBundleViewResolver"></a>ResourceBundleViewResolver</h3><p><em><strong>ResourceBundleViewResolver</strong></em>：它和<em>XmlViewResolver</em>一样，也是继承自<em>AbstractCachingViewResolver</em>，但是它缓存的不是视图，这个会在后面有说到。和<em>XmlViewResolver</em>一样它也需要有一个配置文件来定义逻辑视图名称和真正的<em>View</em>对象的对应关系，不同的是<em>ResourceBundleViewResolver</em>的配置文件是一个属性文件，而且必须是放在<em>classpath</em>路径下面的，默认情况下这个配置文件是在<em>classpath</em>根目录下的<em>views.properties</em>文件，如果不使用默认值的话，则可以通过属性<em>baseName</em>或<em>baseNames</em>来指定。<em>baseName</em>只是指定一个基名称，<em>Spring</em>会在指定的<em>classpath</em>根目录下寻找以指定的<em>baseName</em>开始的属性文件进行<em>View</em>解析，如指定的<em>baseName</em>是<em>base</em>，那么<em>base.properties</em>、<em>baseabc.properties</em>等等以<em>base</em>开始的属性文件都会被<em>Spring</em>当做<em>ResourceBundleViewResolver</em>解析视图的资源文件。<em>ResourceBundleViewResolver</em>使用的属性配置文件的内容类似于这样：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resourceBundle.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">resourceBundle.url</span>=<span class="string">/index.jsp</span></span><br><span class="line"><span class="attr">test.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">test.url</span>=<span class="string">/test.jsp</span></span><br></pre></td></tr></table></figure><p>在这个配置文件中我们定义了两个<em>InternalResourceView</em>对象，一个的名称是<em>resourceBundle</em>，对应<em>URL</em>是*&#x2F;index.jsp<em>，另一个名称是</em>test<em>，对应的</em>URL<em>是</em>&#x2F;test.jsp<em>。从这个定义来看我们可以知道</em>resourceBundle<em>是对应的视图名称，使用</em>resourceBundle.(class)*来指定它对应的视图类型，*resourceBundle.url*指定这个视图的*url<em>属性。会思考的读者看到这里可能会有这样一个问题：为什么</em>resourceBundle<em>的</em>class<em>属性要用小括号包起来，而它的</em>url<em>属性就不需要呢？这就需要从</em>ResourceBundleViewResolver<em>进行视图解析的方法来说了。</em>ResourceBundleViewResolver<em>还是通过</em>bean<em>工厂来获得对应视图名称的视图</em>bean<em>对象来解析视图的。那么这些</em>bean<em>从哪里来呢？就是从我们定义的</em>properties<em>属性文件中来。在</em>ResourceBundleViewResolver<em>第一次进行视图解析的时候会先</em>new<em>一个</em>BeanFactory<em>对象，然后把</em>properties<em>文件中定义好的属性按照它自身的规则生成一个个的</em>bean<em>对象注册到该</em>BeanFactory<em>中，之后会把该</em>BeanFactory<em>对象保存起来，所以</em>ResourceBundleViewResolver<em>缓存的是</em>BeanFactory<em>，而不是直接的缓存从</em>BeanFactory<em>中取出的视图</em>bean<em>。然后会从</em>bean<em>工厂中取出名称为逻辑视图名称的视图</em>bean<em>进行返回。接下来就讲讲</em>Spring<em>通过</em>properties<em>文件生成</em>bean<em>的规则。它会把</em>properties<em>文件中定义的属性名称按最后一个点“</em>.<em>”进行分割，把点前面的内容当做是</em>bean<em>名称，点后面的内容当做是</em>bean<em>的属性。这其中有几个特别的属性，</em>Spring<em>把它们用小括号包起来了，这些特殊的属性一般是对应的</em>attribute<em>，但不是</em>bean<em>对象所有的</em>attribute<em>都可以这样用。其中</em>(class)<em>是一个，除了</em>(class)<em>之外，还有</em>(scope)<em>、</em>(parent)<em>、</em>(abstract)<em>、</em>(lazy-init)<em>。而除了这些特殊的属性之外的其他属性，</em>Spring<em>会把它们当做</em>bean<em>对象的一般属性进行处理，就是</em>bean<em>对象对应的</em>property<em>。所以根据上面的属性配置文件将生成如下两个</em>bean*对象：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;resourceBundle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/test.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从<em>ResourceBundleViewResolver</em>使用的配置文件我们可以看出，它和<em>XmlViewResolver</em>一样可以解析多种不同类型的<em>View</em>，因为它们的<em>View</em>是通过配置的方式指定的，这也就意味着我们可以指定<em>A</em>视图是<em>InternalResourceView</em>，<em>B</em>视图是<em>JstlView</em>。</p><p>来看下面这个一个例子，我在<em>SpringMVC</em>的配置文件中定义了一个<em>ResourceBundleViewResolver</em>对象，指定其<em>baseName</em>为<em>views</em>，然后<em>order</em>为<em>1</em>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;views&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我在<em>classpath</em>的根目录下有两个属性文件，一个是<em>views.properties</em>，一个是<em>views_abc.properties</em>，它们的内容分别如下：</p><p><em>views.properties</em>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resourceBundle.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">resourceBundle.url</span>=<span class="string">/index.jsp</span></span><br><span class="line"><span class="attr">test.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">test.url</span>=<span class="string">/test.jsp</span></span><br></pre></td></tr></table></figure><p><em>views_abc.properties</em>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">abc.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">abc.url</span>=<span class="string">/abc.jsp</span></span><br></pre></td></tr></table></figure><p>定义了如下这样一个<em>Controller</em>，它有三个处理器方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;resourceBundle&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">resourceBundle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;resourceBundle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;testResourceBundle&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testResourceBundle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;abc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">abc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当我们请求*&#x2F;mytest&#x2F;resourceBundle的时候，<em>ResourceBundleViewResolver</em>会首先尝试着来解析该视图，这里<em>Controller</em>处理器方法返回的逻辑视图名称是<em>resourceBundle</em>，<em>ResourceBundleViewResolver</em>按照上面提到的解析方法进行解析，这个时候它发现它是可以解析的，然后就返回了一个<em>url</em>为*&#x2F;index.jsp<em>的</em>InternalResourceView<em>对象。同样，请求</em>mytest&#x2F;testResourceBundle<em>返回的逻辑视图</em>test<em>和</em>&#x2F;mytest&#x2F;abc.do<em>返回的逻辑视图</em>abc<em>它都可以解析。当我们把</em>basename<em>指定为包的形式，如“*com.tiantian.views*”，的时候</em>Spring<em>会按照点“</em>.<em>”划分为目录的形式，到</em>classpath<em>相应目录下去寻找</em>basename<em>开始的配置文件，如上面我们指定</em>basename<em>为“</em>com.tiantian.views<em>”，那么</em>spring<em>就会到</em>classpath<em>下的</em>com&#x2F;tiantian*目录下寻找文件名以views开始的properties文件作为解析视图的配置文件。</p><h3 id="FreeMakerViewResolver"><a href="#FreeMakerViewResolver" class="headerlink" title="FreeMakerViewResolver"></a>FreeMakerViewResolver</h3><p><em><strong>FreeMarkerViewResolver</strong></em>、<em><strong>VolocityViewResolver</strong></em>：这两个视图解析器都是<em>UrlBasedViewResolver</em>的子类。<em>FreeMarkerViewResolver</em>会把<em>Controller</em>处理方法返回的逻辑视图解析为<em>FreeMarkerView</em>，而<em>VolocityViewResolver</em>会把返回的逻辑视图解析为<em>VolocityView</em>。因为这两个视图解析器类似，所以这里我就只挑<em>FreeMarkerViewResolver</em>来做一个简单的讲解。<em>FreeMarkerViewResolver</em>和<em>VilocityViewResolver</em>都继承了<em>UrlBasedViewResolver</em>。</p><p>对于<em>FreeMarkerViewResolver</em>而言，它会按照<em>UrlBasedViewResolver</em>拼接<em>URL</em>的方式进行视图路径的解析。但是使用<em>FreeMarkerViewResolver</em>的时候不需要我们指定其<em>viewClass</em>，因为<em>FreeMarkerViewResolver</em>中已经把<em>viewClass</em>定死为<em>FreeMarkerView</em>了。</p><p>我们先在<em>SpringMVC</em>的配置文件里面定义一个<em>FreeMarkerViewResolver</em>视图解析器，并定义其解析视图的<em>order</em>顺序为<em>1</em>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMakerViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fm_&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.ftl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么当我们请求的处理器方法返回一个逻辑视图名称<em>viewName</em>的时候，就会被该视图处理器加上前后缀解析为一个<em>url</em>为“<em>fm_viewName.ftl</em>”的<em>FreeMarkerView</em>对象。对于<em>FreeMarkerView</em>我们需要给定一个<em>FreeMarkerConfig</em>的<em>bean</em>对象来定义<em>FreeMarker</em>的配置信息。<em>FreeMarkerConfig</em>是一个接口，<em>Spring</em>已经为我们提供了一个实现，它就是<em>FreeMarkerConfigurer</em>。我们可以通过在<em>SpringMVC</em>的配置文件里面定义该<em>bean</em>对象来定义<em>FreeMarker</em>的配置信息，该配置信息将会在<em>FreeMarkerView</em>进行渲染的时候使用到。对于<em>FreeMarkerConfigurer</em>而言，我们最简单的配置就是配置一个<em>templateLoaderPath</em>，告诉<em>Spring</em>应该到哪里寻找<em>FreeMarker</em>的模板文件。这个<em>templateLoaderPath</em>也支持使用“<em>classpath:<em>”和“</em>file:<em>”前缀。当</em>FreeMarker</em>的模板文件放在多个不同的路径下面的时候，我们可以使用<em>templateLoaderPaths</em>属性来指定多个路径。在这里我们指定模板文件是放在“*&#x2F;WEB-INF&#x2F;freemarker&#x2F;template*”下面的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMakerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateLoaderPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/freemarker/template&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们定义如下一个<em>Controller</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;freemarker&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">freemarker</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mav.addObject(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;gcc&quot;</span>);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;freemarker&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的定义我们可以看到这个<em>Controller</em>的处理器方法<em>freemarker</em>返回的逻辑视图名称是“<em>freemarker</em>”。那么如果我们需要把该<em>freemarker</em>视图交给<em>FreeMarkerViewResolver</em>来解析的话，我们就需要根据上面的定义，在模板路径下定义视图对应的模板，即在“*&#x2F;WEB-INF&#x2F;freemarker&#x2F;template<em>”目录下建立</em>fm_freemarker.ftl*模板文件。这里我们定义其内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FreeMarker<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        $&#123;hello&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过上面的定义当我们访问*&#x2F;mytest&#x2F;freemarker<em>的时候就会返回一个逻辑视图名称为“</em>freemarker<em>”的</em>ModelAndView<em>对象，根据定义好的视图解析的顺序，首先进行视图解析的是</em>FreeMarkerViewResolver<em>，这个时候</em>FreeMarkerViewResolver<em>会试着解析该视图，根据它自身的定义，它会先解析到该视图的</em>URL<em>为</em>fm_freemarker.ftl<em>，然后它会看是否能够实例化该视图对象，即在定义好的模板路径下是否有该模板存在，如果有则返回该模板对应的</em>FreeMarkerView<em>。在这里的话</em>&#x2F;WEB-INF&#x2F;freemarker&#x2F;template<em>目录下是存在模板文件</em>fm_freemarker.ftl<em>的，所以会返回一个</em>url<em>为</em>fm_freemarker.ftl<em>的</em>FreeMarkerView<em>对象。接着</em>FreeMarkerView*就可以利用该模板文件进行视图的渲染了。所以访问结果应该如下所示：</p><p>Hello World! gcc</p><h2 id="视图解析器链"><a href="#视图解析器链" class="headerlink" title="视图解析器链"></a>视图解析器链</h2><p>在<em>SpringMVC</em>中可以同时定义多个<em>ViewResolver</em>视图解析器，然后它们会组成一个<em>ViewResolver</em>链。当<em>Controller</em>处理器方法返回一个逻辑视图名称后，<em>ViewResolver</em>链将根据其中<em>ViewResolver</em>的优先级来进行处理。所有的<em>ViewResolver</em>都实现了<em>Ordered</em>接口，在<em>Spring</em>中实现了这个接口的类都是可以排序的。在<em>ViewResolver</em>中是通过<em>order</em>属性来指定顺序的，默认都是最大值。所以我们可以通过指定<em>ViewResolver</em>的<em>order</em>属性来实现<em>ViewResolver</em>的优先级，<em>order</em>属性是<em>Integer</em>类型，<em>order</em>越小，对应的<em>ViewResolver</em>将有越高的解析视图的权利，所以第一个进行解析的将是<em>ViewResolver</em>链中<em>order</em>值最小的那个。当一个<em>ViewResolver</em>在进行视图解析后返回的<em>View</em>对象是<em>null</em>的话就表示该<em>ViewResolver</em>不能解析该视图，这个时候如果还存在其他<em>order</em>值比它大的<em>ViewResolver</em>就会调用剩余的<em>ViewResolver</em>中的<em>order</em>值最小的那个来解析该视图，依此类推。当<em>ViewResolver</em>在进行视图解析后返回的是一个非空的<em>View</em>对象的时候，就表示该<em>ViewResolver</em>能够解析该视图，那么视图解析这一步就完成了，后续的<em>ViewResolver</em>将不会再用来解析该视图。当定义的所有<em>ViewResolver</em>都不能解析该视图的时候，<em>Spring</em>就会抛出一个异常。</p><p> 基于<em>Spring</em>支持的这种<em>ViewResolver</em>链模式，我们就可以在<em>SpringMVC</em>应用中同时定义多个<em>ViewResolver</em>，给定不同的<em>order</em>值，这样我们就可以对特定的视图特定处理，以此来支持同一应用中有多种视图类型。注意：像<em>InternalResourceViewResolver</em>这种能解析所有的视图，即永远能返回一个非空<em>View</em>对象的<em>ViewResolver</em>一定要把它放在<em>ViewResolver</em>链的最后面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/howeres/article/details/124941519">https://blog.csdn.net/howeres/article/details/124941519</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了更好地理解SpringMVC的工作流程，深入学习视图解析器是非常有必要的。希望这篇文章可以帮助大家更好地了解视图解析器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="视图解析器" scheme="https://gccforstudy.github.io/tags/%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-常用注解</title>
    <link href="https://gccforstudy.github.io/2022/08/26/SpringBoot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://gccforstudy.github.io/2022/08/26/SpringBoot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-08-26T08:25:07.000Z</published>
    <updated>2023-03-24T02:27:15.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot常用注解"><a href="#SpringBoot常用注解" class="headerlink" title="SpringBoot常用注解"></a>SpringBoot常用注解</h1><blockquote><p>本文主要介绍一些SpringBoot中常用的注解。由于本人的水平有限，不能很详细地进行讲解，只能带大家进行简单的了解。</p></blockquote><span id="more"></span><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在main方法入口类处，用于启动sping boot应用项目</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><ul><li><p>@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义注册到IoC容器。</p></li><li><p>@EnableAutoConfiguration会根据类路径中的jar依赖,为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p></li></ul><p>@EnableAutoConfiguration作为一个复合Annotation，其自身定义关键信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的注解是@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。</p><p><img src="@EnableAutoConfiguration.jpg"></p><p>SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</p><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p>加载xml配置，一般放在启动main类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:/spring/*.xml&quot;)</span>  单个</span><br><span class="line"></span><br><span class="line"><span class="meta">@ImportResource(&#123;&quot;classpath:/spring/1.xml&quot;,&quot;classpath*:/spring/2.xml&quot;&#125;)</span>   多个</span><br></pre></td></tr></table></figure><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>application.properties定义属性，直接使用@Value注入即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="meta">@Value(&quot;$&#123;push.start:0&#125;&quot;)</span>    如果缺失，默认值为<span class="number">0</span></span><br><span class="line">     <span class="keyword">private</span> Long  id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>将配置文件中指定前缀的属性注入到类中对应的属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name ;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">gcc</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><h2 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h2><p>你可以直接在使用@ConfigurationProperties注解使用@Bean注解，将组件注册到IOC容器中，也可以使用@EnableConfigurationProperties将被@ConfigurationProperties注解的类注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(EnableConfigurationPropertiesRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigurationProperties &#123;</span><br><span class="line"><span class="comment">//写被@ConfigurationProperties注解的类</span></span><br><span class="line">Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>组合@Controller和@ResponseBody，@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>用来映射web请求(访问路径和参数)、处理类和方法，可以注解在类或方法上。注解在方法上的路径会继承注解在类上的路径。</p><p>produces属性: 定制返回的response的媒体类型和字符集，或需返回值是json对象</p><p>consumes属性：要求请求中的媒体类型必须为某种特定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Narrows the primary mapping by media types that can be consumed by the mapped handler.</span></span><br><span class="line">String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Narrows the primary mapping by media types that can be produced by the mapped handler.</span></span><br><span class="line">String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>获取request请求体中的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/匹配路径&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam(value=&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(value=&quot;password&quot;)</span> String password)</span>&#123;</span><br><span class="line">    <span class="comment">//获取请求体中的username和password</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>支持将返回值放在response体内，而不是返回一个页面。比如Ajax接口，可以用此注解返回数据而不是页面。此注解可以放置在返回值前或方法前。</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>@Bean(name&#x3D;”bean的名字”,initMethod&#x3D;”初始化时调用方法名字”,destroyMethod&#x3D;”close”)</p><p>定义在方法上，在容器内初始化一个bean实例类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;close&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Bean <span class="title function_">registryBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p>用于标注业务层组件</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>用于标注控制层组件</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p>用于标注数据访问组件，即DAO组件</p><h2 id="Componet"><a href="#Componet" class="headerlink" title="@Componet"></a>@Componet</h2><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>用来获得请求url中的动态参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;  </span><br><span class="line"></span><br><span class="line">     <span class="meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)</span>  </span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getLogin</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> String userId,  </span></span><br><span class="line"><span class="params">         <span class="meta">@PathVariable(&quot;roleId&quot;)</span> String roleId)</span>&#123;</span><br><span class="line">           </span><br><span class="line">         System.out.println(<span class="string">&quot;User Id : &quot;</span> + userId);  </span><br><span class="line">         System.out.println(<span class="string">&quot;Role Id : &quot;</span> + roleId);  </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">     </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>注解会告知Spring扫描指定的包来初始化Spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.gcc.springboot&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>在默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。</p><p>当不能确定 Spring 容器中一定拥有某个类的 Bean 时，可以在需要自动注入该类 Bean 的地方可以使用 @Autowired(required &#x3D; false)，这等于告诉 Spring: 在找不到匹配 Bean 时也不报错</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>将被注解的类设置为配置类，该类中可以使用@Bean注解向IOC容器中放入组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(&quot;name&quot;)</span><span class="comment">//表示这是一个配置信息类,可以给这个配置类也起一个名称</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;spring4&quot;)</span><span class="comment">//类似于xml中的&lt;context:component-scan base-package=&quot;spring&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动注入，如果容器中有多个符合的bean时，需要进一步明确</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;compent&quot;)</span><span class="comment">//进一步指明注入bean名称为compent的bean</span></span><br><span class="line">    <span class="keyword">private</span> Compent compent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//类似于xml中的&lt;bean id=&quot;newbean&quot; class=&quot;spring.Compent&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> Compent <span class="title function_">newbean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Compent</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>@Import({xxx.class, xxxx.class})给容器中<strong>自动创建出这两个类型的组件</strong>、默认组件的名字就是全类名</p><h2 id="Order"><a href="#Order" class="headerlink" title="@Order"></a>@Order</h2><p>@Order注解主要用来控制配置类的加载顺序，值越小，优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Order &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int LOWEST_PRECEDENCE = Integer.MAX_VALUE;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression(&quot;$&#123;enabled:false&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigpipeConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OrderMessageMonitor <span class="title function_">orderMessageMonitor</span><span class="params">(ConfigContext configContext)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderMessageMonitor</span>(configContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解的value属性是SpEL（Spring表达式），如果为true才会加载组件，为false则不会加载组件。对SpEL表达式感兴趣的小伙伴可以自行查阅资料。</p><h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p>SpringBoot中有个注解@ConditionalOnProperty，这个注解能够控制某个configuration是否生效。具体操作是通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值，如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。</p><p>该注解中的value属性(等同于name属性)用来设置是否包含applicaiton.properties中的某个属性，prefix属性用来设置属性的前缀（例如acme.system.feature)，havingValue属性只有三个值，分别为true、false、foo，关于这个注解的详细解释大家可以自行查看源码。</p><h2 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h2><p>该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类</p><h2 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h2><p>如果存在它修饰的类的bean，则不需要再创建这个bean</p><h2 id="ConditionOnMissingBean"><a href="#ConditionOnMissingBean" class="headerlink" title="@ConditionOnMissingBean"></a>@ConditionOnMissingBean</h2><p>可以指定当IOC容器中没有何种类型或名字的组件时，@configuration或@Bean注解才会生效（即往IOC容器中放入对应的组件）</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot常用注解&quot;&gt;&lt;a href=&quot;#SpringBoot常用注解&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot常用注解&quot;&gt;&lt;/a&gt;SpringBoot常用注解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要介绍一些SpringBoot中常用的注解。由于本人的水平有限，不能很详细地进行讲解，只能带大家进行简单的了解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://gccforstudy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-devtools</title>
    <link href="https://gccforstudy.github.io/2022/08/21/SpringBoot-devtools/"/>
    <id>https://gccforstudy.github.io/2022/08/21/SpringBoot-devtools/</id>
    <published>2022-08-21T02:24:38.000Z</published>
    <updated>2022-09-04T02:54:57.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热部署工具devtools"><a href="#热部署工具devtools" class="headerlink" title="热部署工具devtools"></a>热部署工具devtools</h1><blockquote><p>SpringBoot开发调试中，如果我每行代码的修改都需要重启启动再调试，可能比较费时间；SpringBoot团队针对此问题提供了spring-boot-devtools（简称devtools）插件，它试图提升开发调试的效率。</p></blockquote><p>在讲解devtools开始之前，我们先来介绍一些前置知识。</p><span id="more"></span><h2 id="什么是热部署和热加载？"><a href="#什么是热部署和热加载？" class="headerlink" title="什么是热部署和热加载？"></a>什么是热部署和热加载？</h2><blockquote><p>热部署和热加载是在应用正在运行的时候，自动更新（重新加载或者替换class等）应用的一种能力。（PS：spring-boot-devtools提供的方案也是要重启的，只是无需手动重启能实现自动加载而已。）</p></blockquote><ul><li><p>热部署</p><ul><li>在服务器运行时重新部署项目</li><li>它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。</li></ul></li><li><p>热加载</p><ul><li><p>在运行时重新加载class，从而升级应用。</p></li><li><p>热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。</p></li><li><p>对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。</p></li></ul></li></ul><h2 id="什么是LiveLoad？"><a href="#什么是LiveLoad？" class="headerlink" title="什么是LiveLoad？"></a>什么是LiveLoad？</h2><p>LiveLoad是提供浏览器客户端自动加载更新的工具，分为LiveLoad服务器和Liveload浏览器插件两部分； devtools中已经集成了LiveLoad服务器，所以如果我们开发的是web应用，并且期望浏览器自动刷新， 这时候可以考虑LiveLoad。</p><p>同一时间只能运行一个LiveReload服务器。 开始应用程序之前，请确保没有其他LiveReload服务器正在运行。如果从IDE启动多个应用程序，则只有第一个应用程序将支持LiveReload。</p><h2 id="配置devtools实现热部署"><a href="#配置devtools实现热部署" class="headerlink" title="配置devtools实现热部署"></a>配置devtools实现热部署</h2><blockquote><p>我们通过如下配置来实现自动重启方式的热部署</p></blockquote><h3 id="POM配置"><a href="#POM配置" class="headerlink" title="POM配置"></a>POM配置</h3><p>添加spring-boot-devtools的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 可以防止将devtools依赖传递到其他模块中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h3><blockquote><p>如果你使用IDEA开发工具，通常有如下两种方式：</p></blockquote><ul><li>方式一：无需任何配置，手动触发重启更新（Ctrl + F9）</li></ul><p><img src="%E7%83%AD%E9%83%A8%E7%BD%B2.jpg"></p><ul><li>方式二：IDEA需开启运行时编译，自动重启更新</li></ul><p>File-&gt;Setting-&gt;Build,Execution,Deployment-&gt;Compile</p><p>勾选：Build project automatically</p><p><img src="%E7%83%AD%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E4%BA%8C.png"></p><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#设置开启热部署</span></span><br><span class="line">      <span class="attr">additional-paths:</span> <span class="string">src/main/java</span> <span class="comment">#重启目录</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">WEB-INF/**</span> <span class="comment">#静态资源更新，不要让服务器重启</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment">#使用Thymeleaf模板引擎，关闭缓存</span></span><br></pre></td></tr></table></figure><h2 id="使用LiveLoad"><a href="#使用LiveLoad" class="headerlink" title="使用LiveLoad"></a>使用LiveLoad</h2><p>spring-boot-devtools模块包含<strong>嵌入式LiveReload服务器</strong>，可以在资源更改时用于触发浏览器刷新。 LiveReload浏览器扩展程序支持Chrome，Firefox和Safari，你可以从livereload.com免费下载，或者从浏览器插件中心下载。</p><p><img src="LiveReload.jpg"></p><p>如果你不想在应用程序运行时启动LiveReload服务器，则可以将spring.devtools.livereload.enabled属性设置为false 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">devtools:</span></span><br><span class="line">   <span class="attr">livereload:</span></span><br><span class="line">     <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h2><blockquote><p>虽然一些开发者会使用devtool工具，但是很少有能够深入理解的；让我们理解如下几个问题，帮助你进一步理解。</p></blockquote><h3 id="devtool的原理？为何会自动重启？"><a href="#devtool的原理？为何会自动重启？" class="headerlink" title="devtool的原理？为何会自动重启？"></a>devtool的原理？为何会自动重启？</h3><blockquote><p>为什么同样是重启应用，为什么不手动重启，而是建议使用spring-boot-devtools进行热部署重启？</p></blockquote><p>spring-boot-devtools使用了两个类加载器ClassLoader，一个ClassLoader加载不会发生更改的类（第三方jar包），另一个ClassLoader（restart ClassLoader）加载会更改的类（自定义的类）。</p><p>后台启动一个<strong>文件监听线程（File Watcher）</strong>，<strong>监测的目录中的文件发生变动时， 原来的restart ClassLoader被丢弃，将会重新加载新的restart ClassLoader</strong>。</p><p>因为文件变动后，第三方jar包不再重新加载，只加载自定义的类，加载的类比较少，所以重启比较快。</p><p>这也是为什么，同样是重启应用，为什么不手动重启，建议使用spring-boot-devtools进行热部署重启。</p><p>在自动重启中有几点需要注意:</p><ul><li><strong>自动重启会记录日志</strong></li></ul><p>记录在什么情况下重启的日志</p><p>可以通过如下方式关闭：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">log-condition-evaluation-delta:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>排除一些不需要自动重启的资源</strong></li></ul><p>某些资源在更改时不一定需要触发重新启动。默认情况下，改变资源&#x2F;META-INF&#x2F;maven，&#x2F;META-INF&#x2F;resources，&#x2F;resources，&#x2F;static，&#x2F;public，或&#x2F;templates不触发重新启动，但确会触发现场重装。如果要自定义这些排除项，可以使用该spring.devtools.restart.exclude属性。例如，要仅排除&#x2F;static，&#x2F;public你将设置以下属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">&quot;static/**,public/**&quot;</span> <span class="comment">#默认在类路径下搜索</span></span><br><span class="line">      <span class="attr">additional-exclude:</span> <span class="string">&quot;xxxx&quot;</span> <span class="comment">#写新增的项</span></span><br></pre></td></tr></table></figure><p>如果要保留这些默认值并添加其他排除项，请改用该spring.devtools.restart.additional-exclude属性。</p><ul><li><strong>自定义重启类加载器</strong></li></ul><p>重启功能是通过使用两个类加载器来实现的。对于大多数应用程序，这种方法效果很好。但是，它有时会导致类加载问题。</p><p>默认情况下，IDE 中的任何打开项目都使用“重启”类加载器加载，任何常规.jar文件都使用“基本”类加载器加载。如果你处理一个多模块项目，并且不是每个模块都导入到你的 IDE 中，你可能需要自定义一些东西。为此，你可以创建一个META-INF&#x2F;spring-devtools.properties文件。</p><p>该spring-devtools.properties文件可以包含以restart.exclude和为前缀的属性restart.include。该include元素是应该被拉高到“重启”的类加载器的项目，以及exclude要素是应该向下推入“Base”类加载器的项目。该属性的值是应用于类路径的正则表达式模式，如以下示例所示：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">exclude</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">companycommonlibs</span>: <span class="string">&quot;/mycorp-common-[\\w\\d-\\.]+\\.jar&quot;</span></span><br><span class="line">  <span class="attr">include</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">projectcommon</span>: <span class="string">&quot;/mycorp-myproj-[\\w\\d-\\.]+\\.jar&quot;</span></span><br></pre></td></tr></table></figure><h3 id="devtool是否会被打包进Jar？"><a href="#devtool是否会被打包进Jar？" class="headerlink" title="devtool是否会被打包进Jar？"></a>devtool是否会被打包进Jar？</h3><blockquote><p>devtool原则上来说应该是只在开发调试的时候使用，而在生产环境运行jar包时是不需要的，所以Spring打包不会把它打进JAR包。</p></blockquote><ul><li><strong>默认情况下，不会被打包进JAR</strong></li></ul><p>运行打包的应用程序时，开发人员工具<strong>会自动禁用</strong>。如果你通过 java -jar或者其他特殊的类加载器进行启动时，都会被认为是“生产环境的应用”。</p><h3 id="devtool为何会默认禁用缓存选项？"><a href="#devtool为何会默认禁用缓存选项？" class="headerlink" title="devtool为何会默认禁用缓存选项？"></a>devtool为何会默认禁用缓存选项？</h3><blockquote><p> Spring Boot 支持的一些库<strong>使用缓存来提高性能</strong>。例如，模板引擎缓存已编译的模板以避免重复解析模板文件。此外，Spring MVC 可以在提供静态资源时向响应添加 HTTP 缓存标头。</p></blockquote><p>虽然缓存<strong>在生产中非常有益，但在开发过程中可能会适得其反</strong>，使你无法看到刚刚在应用程序中所做的更改。出于这个原因， spring-boot-devtools 默认禁用缓存选项。</p><p>比如Thymeleaf 提供了spring.thymeleaf.cache来设置模板引擎的缓存，使用spring-boot-devtools模块时是不需要手动设置这些属性的，因为spring-boot-devtools会自动进行设置。</p><p>在devtools-property-defaults.properties中你可以看到默认配置，你可以去jar包找到，方式如下：</p><p><img src="%E7%BC%93%E5%AD%98%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.png"></p><p>默认配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.error.include-binding-errors</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">server.error.include-message</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">server.error.include-stacktrace</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">server.servlet.jsp.init-parameters.development</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.servlet.session.persistent</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.freemarker.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.graphql.graphiql.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.groovy.template.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.h2.console.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mustache.servlet.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.mvc.log-resolved-exception</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.reactor.debug</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.template.provider.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.period</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.web.resources.chain.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>当然如果你不想被应用属性被spring-boot-devtools默认设置， 可以通过将spring.devtools.add-properties属性设置为false。</p><p>方式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该属性默认的值为true，也就是说如果你使用devtools，默认情况下使用上述properties文件中的缓存规则</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">  <span class="attr">add-properties:</span> <span class="literal">false</span> <span class="comment">#不使用devtools的默认配置</span></span><br></pre></td></tr></table></figure><h3 id="如果我不用devtool，还有什么选择？"><a href="#如果我不用devtool，还有什么选择？" class="headerlink" title="如果我不用devtool，还有什么选择？"></a>如果我不用devtool，还有什么选择？</h3><p>devtool本身基于重启方式，这种仍然不是真正的热替换方案，JRebel才是（它是收费的）</p><p>开发调试最重要的还是一种权衡</p><ul><li>自动重启的开销如果和手动重启没有什么太大差别，那么还不如手动重启（按需重启）</li><li>多数情况下，如果是<strong>方法内部的修改或者静态资源的修改</strong>，在IDEA中是可以通过Rebuild（Ctrl + Shift + F9）进行热更的</li></ul><p><img src="SpringBoot-devtools%5CRebuild.png"></p><ul><li>此外还有一个工具spring loaded， 可实现修改类文件的热部署，具体可看其<a href="https://github.com/spring-projects/spring-loaded">github地址</a>上的说明。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文记录了自己学习devtools的一些感悟，希望大家可以自己动手实践一下，毕竟编程需要多动手才能学好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools</a></p><p><a href="https://liayun.blog.csdn.net/article/details/116541775">https://liayun.blog.csdn.net/article/details/116541775</a></p><p><a href="https://pdai.tech/md/spring/springboot/springboot-x-hello-devtool.html">https://pdai.tech/md/spring/springboot/springboot-x-hello-devtool.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;热部署工具devtools&quot;&gt;&lt;a href=&quot;#热部署工具devtools&quot; class=&quot;headerlink&quot; title=&quot;热部署工具devtools&quot;&gt;&lt;/a&gt;热部署工具devtools&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;SpringBoot开发调试中，如果我每行代码的修改都需要重启启动再调试，可能比较费时间；SpringBoot团队针对此问题提供了spring-boot-devtools（简称devtools）插件，它试图提升开发调试的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在讲解devtools开始之前，我们先来介绍一些前置知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://gccforstudy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot简介</title>
    <link href="https://gccforstudy.github.io/2022/08/19/SpringBoot%E7%AE%80%E4%BB%8B/"/>
    <id>https://gccforstudy.github.io/2022/08/19/SpringBoot%E7%AE%80%E4%BB%8B/</id>
    <published>2022-08-19T08:35:00.000Z</published>
    <updated>2022-08-19T12:50:26.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><blockquote><p>尽管Spring的组件是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过<strong>开箱即用</strong>和<strong>约定大于配置</strong> 来解决配置重的问题的。</p></blockquote><span id="more"></span><h2 id="SpringFramework解决了什么问题，没有解决什么问题？"><a href="#SpringFramework解决了什么问题，没有解决什么问题？" class="headerlink" title="SpringFramework解决了什么问题，没有解决什么问题？"></a>SpringFramework解决了什么问题，没有解决什么问题？</h2><h3 id="SpringFramework解决了什么问题？"><a href="#SpringFramework解决了什么问题？" class="headerlink" title="SpringFramework解决了什么问题？"></a>SpringFramework解决了什么问题？</h3><ol><li>使用Spring的IOC容器,将对象之间的依赖关系交给Spring,降低组件之间的耦合性,让我们更专注于应用逻辑 。</li><li>可以提供众多服务,事务管理,WS等。 </li><li>对AOP有很好的支持,方便面向切面编程。 </li><li>对主流的框架提供了很好的集成支持,如Hibernate,Struts2,JPA等。 </li><li>Spring DI机制降低了业务对象替换的复杂性。 </li><li>Spring属于低侵入,代码污染极低。 </li><li>Spring的高度可开放性,并不强制依赖于Spring,开发者可以自由选择Spring部分或全部。</li></ol><h3 id="SpringFramework没有解决了什么问题？"><a href="#SpringFramework没有解决了什么问题？" class="headerlink" title="SpringFramework没有解决了什么问题？"></a>SpringFramework没有解决了什么问题？</h3><p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p><p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p><p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p><h2 id="SpringBoot的概述"><a href="#SpringBoot的概述" class="headerlink" title="SpringBoot的概述"></a>SpringBoot的概述</h2><h3 id="SpringBoot解决上述Spring的缺点"><a href="#SpringBoot解决上述Spring的缺点" class="headerlink" title="SpringBoot解决上述Spring的缺点"></a>SpringBoot解决上述Spring的缺点</h3><p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p><h3 id="SpringBoot的特点"><a href="#SpringBoot的特点" class="headerlink" title="SpringBoot的特点"></a>SpringBoot的特点</h3><ol><li>为基于Spring的开发提供更快的入门体验</li><li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li></ol><p>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</p><h3 id="SpringBoot的核心功能"><a href="#SpringBoot的核心功能" class="headerlink" title="SpringBoot的核心功能"></a>SpringBoot的核心功能</h3><ul><li><strong>起步依赖</strong> 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</li></ul><p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p><ul><li><strong>自动配置</strong></li></ul><p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><p><a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin">https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin</a></p><p><a href="https://www.jianshu.com/p/24add3c5fedb">https://www.jianshu.com/p/24add3c5fedb</a></p><p><a href="https://www.cnblogs.com/luzhanshi/p/10592209.html">https://www.cnblogs.com/luzhanshi/p/10592209.html</a></p><p><a href="https://pdai.tech/md/spring/springboot/springboot.html">https://pdai.tech/md/spring/springboot/springboot.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot简介&quot;&gt;&lt;a href=&quot;#SpringBoot简介&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot简介&quot;&gt;&lt;/a&gt;SpringBoot简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;尽管Spring的组件是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过&lt;strong&gt;开箱即用&lt;/strong&gt;和&lt;strong&gt;约定大于配置&lt;/strong&gt; 来解决配置重的问题的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://gccforstudy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Logger</title>
    <link href="https://gccforstudy.github.io/2022/08/19/Logger/"/>
    <id>https://gccforstudy.github.io/2022/08/19/Logger/</id>
    <published>2022-08-19T02:29:36.000Z</published>
    <updated>2022-08-21T00:25:58.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准Java日志框架"><a href="#标准Java日志框架" class="headerlink" title="标准Java日志框架"></a>标准Java日志框架</h2><p>每个Java程序员都很熟悉在有问题的代码中插入一些System.out.println方法调用来帮助自己观察程序的行为。当然，一旦发现问题的根源，就要将这些print语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用System.out.println方法的语句。日志API就是为了解决这个问题而设计的。</p><span id="more"></span><p>本文只介绍标准Java日志框架，因为学习这个框架的API可以让我们准备好去理解其他框架。（比如Log4J2、Logback其他日志框架，SLF4J和Commons Logging日志门面）</p><h3 id="基本日志"><a href="#基本日志" class="headerlink" title="基本日志"></a>基本日志</h3><p>要想生成简单的日志记录，可以使用全局日志记录器（global logger）并调用info方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">&quot;gccwd&quot;</span>);</span><br></pre></td></tr></table></figure><p>在默认情况下，会在控制台打印如下记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">八月 <span class="number">19</span>, <span class="number">2022</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">10</span> 上午 com.gcc.mvc.bean.FortTest main</span><br><span class="line">信息: gccwd</span><br></pre></td></tr></table></figure><p>但是，如果在info方法之前调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().setLevel(Level.OFF);</span><br></pre></td></tr></table></figure><p>将会取消所有日志。</p><h3 id="高级日志"><a href="#高级日志" class="headerlink" title="高级日志"></a>高级日志</h3><p>在一个专业的应用程序中，你肯定不想将所有的日志都记录到一个全局日志记录器中。你可以定义自己的日志记录器。</p><p>可以调用getLogger方法来获取日志记录器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">myLogger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>提示：为了防止日志记录器被垃圾回收，需要用静态变量存储日志记录器的引用。</p></blockquote><p>与包名类似，日志记录器名也具有层次结构。对于包来说，子包与父包之间没有语义关系，但是日志记录器的父与子之间将共享某些属性。例如，如果对日志记录器”com.mycompany”设置了日志级别，它的子日志记录器也会继承这个级别。</p><p>通常，有以下7个日志级别（级别从高到低）：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>在默认情况下，只记录前三个级别。也可以设置不同的级别，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logger是日志记录器</span></span><br><span class="line">logger.setLevel(Level.FINE);</span><br></pre></td></tr></table></figure><p>现在，FINE及所有更高级别的日志都会被记录。</p><p>另外，还可以使用Level.ALL来开启所以级别的日志记录，或者使用Level.OFF关闭所有级别的日志记录。</p><p>所有级别都有日志记录方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logger.warning(message);</span><br><span class="line">logger.fine(message);</span><br><span class="line"><span class="comment">//或者，还可以使用log方法并指定级别</span></span><br><span class="line">logger.log(Level.FINE, message);</span><br></pre></td></tr></table></figure><p>默认的日志纪律将显示根据调用堆栈得出的包含日志调用的类名和方法名。不过，如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以使用logp方法获得调用类和方法的确切位置，这个方法的签名为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">logp</span><span class="params">(Level level, String sourceClass, String sourceMethod, String msg)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//另外，有一些用来跟踪执行流的便利方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Log a method entry, with an array of parameters.</span></span><br><span class="line"><span class="comment">This is a convenience method that can be used to log entry to a method. A LogRecord with message &quot;ENTRY&quot; (followed by a format &#123;N&#125; indicator for each entry in the parameter array), log level FINER, and the given sourceMethod, sourceClass, and parameters is logged.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">entering</span><span class="params">(String sourceClass, String sourceMethod, Object params[])</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Log a method return, with result object.</span></span><br><span class="line"><span class="comment">This is a convenience method that can be used to log returning from a method. A LogRecord with message &quot;RETURN &#123;0&#125;&quot;, log level FINER, and the gives sourceMethod, sourceClass, and result object is logged.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exiting</span><span class="params">(String sourceClass, String sourceMethod, Object result)</span></span><br></pre></td></tr></table></figure><p>这些调用将生成FINER级别而且以字符串ENTRY和RETURN开头的日志记录。（用来记录方法的开始和方法的结尾）</p><p>记录日志的常见用途是记录那些预料之外的异常。可以使用下面两个便利方法在日志记录包含异常的描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Log throwing an exception.</span></span><br><span class="line"><span class="comment">This is a convenience method to log that a method is terminating by throwing an exception. The logging is done using the FINER level.</span></span><br><span class="line"><span class="comment">If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord&#x27;s message is set to &quot;THROW&quot;.</span></span><br><span class="line"><span class="comment">Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">throwing</span><span class="params">(String sourceClass, String sourceMethod, Throwable thrown)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Log a message, with associated Throwable information.</span></span><br><span class="line"><span class="comment">If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</span></span><br><span class="line"><span class="comment">Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String msg, Throwable thrown)</span></span><br></pre></td></tr></table></figure><p>throwing调用可以记录一条FINER级别的日志记录和一条以THROW开始的消息。</p><h3 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h3><p>可以通过编辑配置文件来修改日志系统的各个属性。在默认情况下，配置文件位于：</p><p>jdk&#x2F;conf&#x2F;logging.properties(在Java9之前，位于jdk&#x2F;jre&#x2F;lib&#x2F;logging.properties)</p><p>要想修改默认的日志级别，就需要编辑配置文件，并修改以下命令行</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default global logging level.</span></span><br><span class="line"><span class="comment"># This specifies which kinds of events are logged across</span></span><br><span class="line"><span class="comment"># all loggers.  For any given facility this global level</span></span><br><span class="line"><span class="comment"># can be overriden by a facility specific level</span></span><br><span class="line"><span class="comment"># Note that the ConsoleHandler also has a separate level</span></span><br><span class="line"><span class="comment"># setting to limit messages printed to the console.</span></span><br><span class="line"><span class="attr">.level</span> = <span class="string">INFO</span></span><br></pre></td></tr></table></figure><p>可以通过添加下面这一行来指定自定义日志记录器的日志级别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.mycompany.myapp.level</span> = <span class="string">FINE</span></span><br></pre></td></tr></table></figure><p>稍后可以看到，日志记录器并不将消息发送到控制台，那是处理器的任务。处理器也有运行级别，要想在控制台上看到FINE级别的消息，就需要进行以下设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java.util.logging.ConsoleHandler.level</span> = <span class="string">FINE</span></span><br></pre></td></tr></table></figure><blockquote><p>注释：日志属性文件由java.util.logging.LogManager类处理。有关LogManager类的更多信息请参看API文档。</p></blockquote><blockquote><p>​补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个接口在看Java核心技术卷1日志部分的时候可以需要用到，大家可以看看</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>在默认情况下，日志记录器将记录发送到ConsoleHandler，并由它输出到System.err流。</p><p>与日志记录器一样，处理器也有日志级别。对于一个要记录的日志记录，它的日志级别必须高于日志记录器和处理器二者的阈值。日志管理器配置文件将默认的控制台处理器的日志级别设置为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Limit the message that are printed on the console to INFO and above.</span></span><br><span class="line"><span class="attr">java.util.logging.ConsoleHandler.level</span> = <span class="string">INFO</span></span><br></pre></td></tr></table></figure><p>要想记录FINE级别的日志，就必须修改配置文件中的默认日志记录器级别和处理级别。另外，还可以绕过配置文件，安装你自己的处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br><span class="line">logger.setLevel(Level.FINE);</span><br><span class="line">logger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line"><span class="type">ConsoleHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line">handler.setLevel(Level.FINE);</span><br><span class="line">logger.addHandler(handler);</span><br></pre></td></tr></table></figure><p>这里为什么关闭父日志处理器呢？因为所有的控制台处理器都会将日志发送到祖日志处理器中，再由祖日志处理器将日志发送到控制台进行显示。如果不关闭父日志处理器，就会发送两次相同的日志。</p><p>如果想把日志记录到其他地方，就要添加其他类型的处理器。日志API提供了两个很有用的处理器，一个是FileHandler；另一个是SocketHandler。SocketHandler将记录发送到指定的主机和端口。更令人感兴趣的是FileHandler，它可以将日志记录收集到文件中。</p><p>可以通过如下方式将记录发送到默认文件处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line">logger.addHandler(handler);</span><br></pre></td></tr></table></figure><p>这些记录被发送到用户主目录的javan.log文件中，n是保证文件唯一的一个编号。默认情况下，记录会格式化为XML。一个典型的日志记录形式如下：</p><p><img src="xml%E6%A0%BC%E5%BC%8F%E6%97%A5%E5%BF%97.png"></p><p>可以通过设置日志管理器配置文件中的不同参数，如下表：</p><p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png"></p><p>也有可能不想使用默认的日志文件名，因此，应该使用另一种模式，例如%h&#x2F;myapp.log。模式变量如下：</p><p><img src="%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F.png"></p><p>循环日志的意思是当超过限制后，最老的文件就会被删除，用新生成的文件代替，以此类推。</p><p>当然，你也可以定义自己的处理器，你可以通过扩展Handler类或StreamHandler类的方式来实现，感兴趣的小伙伴可以自行学习。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>在默认情况下，会根据日志记录的级别进行过滤。每个日志记录器和处理器都有一个可选的过滤器来完成附加的过滤。要定义一个过滤器，需要实现Filter接口并定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Filter can be used to provide fine grain control over</span></span><br><span class="line"><span class="comment"> * what is logged, beyond the control provided by log levels.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Each Logger and each Handler can have a filter associated with it.</span></span><br><span class="line"><span class="comment"> * The Logger or Handler will call the isLoggable method to check</span></span><br><span class="line"><span class="comment"> * if a given LogRecord should be published.  If isLoggable returns</span></span><br><span class="line"><span class="comment"> * false, the LogRecord will be discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check if a given log record should be published.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record  a LogRecord</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the log record should be published.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(LogRecord record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以了。注意，同一时刻最多只能有一个过滤器。</p><h3 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h3><p>格式化器大家了解一下即可</p><p><img src="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.logging;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Formatter provides support for formatting LogRecords.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Typically each logging Handler will have a Formatter associated</span></span><br><span class="line"><span class="comment"> * with it.  The Formatter takes a LogRecord and converts it to</span></span><br><span class="line"><span class="comment"> * a string.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Some formatters (such as the XMLFormatter) need to wrap head</span></span><br><span class="line"><span class="comment"> * and tail strings around a set of formatted records. The getHeader</span></span><br><span class="line"><span class="comment"> * and getTail methods can be used to obtain these strings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new formatter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Formatter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Format the given log record and return the formatted string.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The resulting formatted String will normally include a</span></span><br><span class="line"><span class="comment">     * localized and formatted version of the LogRecord&#x27;s message field.</span></span><br><span class="line"><span class="comment">     * It is recommended to use the &#123;<span class="doctag">@link</span> Formatter#formatMessage&#125;</span></span><br><span class="line"><span class="comment">     * convenience method to localize and format the message field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the log record to be formatted.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the formatted log record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">format</span><span class="params">(LogRecord record)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the header string for a set of formatted records.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This base class returns an empty string, but this may be</span></span><br><span class="line"><span class="comment">     * overridden by subclasses.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   h  The target handler (can be null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  header string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHead</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the tail string for a set of formatted records.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This base class returns an empty string, but this may be</span></span><br><span class="line"><span class="comment">     * overridden by subclasses.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   h  The target handler (can be null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  tail string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTail</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Localize and format the message string from a log record.  This</span></span><br><span class="line"><span class="comment">     * method is provided as a convenience for Formatter subclasses to</span></span><br><span class="line"><span class="comment">     * use when they are performing formatting.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The message string is first localized to a format string using</span></span><br><span class="line"><span class="comment">     * the record&#x27;s ResourceBundle.  (If there is no ResourceBundle,</span></span><br><span class="line"><span class="comment">     * or if the message key is not found, then the key is used as the</span></span><br><span class="line"><span class="comment">     * format string.)  The format String uses java.text style</span></span><br><span class="line"><span class="comment">     * formatting.</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If there are no parameters, no formatter is used.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Otherwise, if the string contains &quot;&#123;0&quot; then</span></span><br><span class="line"><span class="comment">     *     java.text.MessageFormat  is used to format the string.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Otherwise no formatting is performed.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  record  the log record containing the raw message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   a localized and formatted message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">formatMessage</span><span class="params">(LogRecord record)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> record.getMessage();</span><br><span class="line">        java.util.<span class="type">ResourceBundle</span> <span class="variable">catalog</span> <span class="operator">=</span> record.getResourceBundle();</span><br><span class="line">        <span class="keyword">if</span> (catalog != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                format = catalog.getString(record.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.util.MissingResourceException ex) &#123;</span><br><span class="line">                <span class="comment">// Drop through.  Use record message as format</span></span><br><span class="line">                format = record.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do the formatting.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object parameters[] = record.getParameters();</span><br><span class="line">            <span class="keyword">if</span> (parameters == <span class="literal">null</span> || parameters.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No parameters.  Just return format string.</span></span><br><span class="line">                <span class="keyword">return</span> format;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Is it a java.text style format?</span></span><br><span class="line">            <span class="comment">// Ideally we could match with</span></span><br><span class="line">            <span class="comment">// Pattern.compile(&quot;\\&#123;\\d&quot;).matcher(format).find())</span></span><br><span class="line">            <span class="comment">// However the cost is 14% higher, so we cheaply check for</span></span><br><span class="line">            <span class="comment">// 1 of the first 4 parameters</span></span><br><span class="line">            <span class="keyword">if</span> (format.indexOf(<span class="string">&quot;&#123;0&quot;</span>) &gt;= <span class="number">0</span> || format.indexOf(<span class="string">&quot;&#123;1&quot;</span>) &gt;=<span class="number">0</span> ||</span><br><span class="line">                        format.indexOf(<span class="string">&quot;&#123;2&quot;</span>) &gt;=<span class="number">0</span>|| format.indexOf(<span class="string">&quot;&#123;3&quot;</span>) &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> java.text.MessageFormat.format(format, parameters);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Formatting failed: use localized format string.</span></span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志技巧"><a href="#日志技巧" class="headerlink" title="日志技巧"></a>日志技巧</h3><p>面对日志记录如此多的选项，很容易让人忘记最基本的东西。下面的技巧总结了一些最常用的操作。</p><p>1、对一个简单的应用，选择一个日志记录器。可以把日志记录器命名为与主应用包一样的名字，例如，com.mycompany.myprog，这是一个好主意。总是可以通过调用以下方法得到日志记录器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany,myprog&quot;</span>);</span><br><span class="line"><span class="comment">//为了方便起见，你可能希望为有大量日志记录活动的类增加静态字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany,myprog&quot;</span>);</span><br></pre></td></tr></table></figure><p>2 、默认的日志配置会把级别等于或高于INFO的所有消息记录到控制台。用户可以覆盖这个默认配置。如是正如前面所述，改变配置的过程有些复杂，最好在你的应用中安装一个更合适的默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码确保将所有的消息记录到应用特定的一个文件中，可以将这段代码放置在应用程序的main方法中</span></span><br><span class="line"> <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;java.util.logging.config.class&quot;</span>) == <span class="literal">null</span> &amp;&amp; System.getProperty(<span class="string">&quot;java.util.logging.config.file&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Logger.getLogger(<span class="string">&quot;&quot;</span>).setLevel(Level.ALL);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOG_ROTATION_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">                <span class="type">FileHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>(<span class="string">&quot;%h&quot;</span>, <span class="number">0</span>, LOG_ROTATION_COUNT);</span><br><span class="line">                Logger.getLogger(<span class="string">&quot;&quot;</span>).addHandler(handler);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                myLogger.log(Level.SEVERE, <span class="string">&quot;Can&#x27;t create log file handler&quot;</span>,e);<span class="comment">//private static final Logger myLogger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>3、现在，可以记录自己想要的内容了。但需要牢记：所有级别为INFO、WARNING和SEVERE的消息都将显示到控制台上。因此，最好只将对程序用户有意的消息设置为这几个级别。将程序员想要的日志消息设定为FINE级别是一个很好的选择。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文参考了Java核心技术卷1的日志部分，如果想要详细了解，小伙伴们应该去阅读原书。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;标准Java日志框架&quot;&gt;&lt;a href=&quot;#标准Java日志框架&quot; class=&quot;headerlink&quot; title=&quot;标准Java日志框架&quot;&gt;&lt;/a&gt;标准Java日志框架&lt;/h2&gt;&lt;p&gt;每个Java程序员都很熟悉在有问题的代码中插入一些System.out.println方法调用来帮助自己观察程序的行为。当然，一旦发现问题的根源，就要将这些print语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用System.out.println方法的语句。日志API就是为了解决这个问题而设计的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日志" scheme="https://gccforstudy.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Filter</title>
    <link href="https://gccforstudy.github.io/2022/08/18/Filter/"/>
    <id>https://gccforstudy.github.io/2022/08/18/Filter/</id>
    <published>2022-08-18T11:41:07.000Z</published>
    <updated>2022-08-21T00:26:18.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter(过滤器)是JavaWeb三大组件之一，为了后续可以更好地掌握SpringMVC框架，仔细学习一下过滤器的基础知识是很有必要的。</p><span id="more"></span> <h3 id="过滤器的三要素"><a href="#过滤器的三要素" class="headerlink" title="过滤器的三要素"></a>过滤器的三要素</h3><p>1、拦截</p><p>​过滤器之所以能够对请求进行预处理，关键是对请求进行拦截，把请求拦截下来才能够做后续的操作。而且对于一个具体的过滤器，它必须明确它要拦截的请求，而不是所有请求都拦截。</p><p>2、过滤</p><p>​根据业务功能实际的需求，看看在把请求拦截到之后，需要做什么检查或什么操作，写对应的代码即可。</p><p>3、放行</p><p>​过滤器完成自己的任务或者是检测到当前请求符合过滤规则，那么可以将请求放行。所谓放行，就是让请求继续去访问它原本要访问的资源。</p><h3 id="过滤器工作流程及实验"><a href="#过滤器工作流程及实验" class="headerlink" title="过滤器工作流程及实验"></a>过滤器工作流程及实验</h3><h4 id="过滤器工作流程图"><a href="#过滤器工作流程图" class="headerlink" title="过滤器工作流程图"></a>过滤器工作流程图</h4><p><img src="%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg"></p><h4 id="Filter接口源码"><a href="#Filter接口源码" class="headerlink" title="Filter接口源码"></a>Filter接口源码</h4><p>为了实现上述的工作流程，需要创建Filter接口的实现类，为了更好地理解Filter，我们来简单地看一下该接口的源码，Filter接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A filter is an object that performs filtering tasks on either the</span></span><br><span class="line"><span class="comment"> * request to a resource (a servlet or static content), or on the response</span></span><br><span class="line"><span class="comment"> * from a resource, or both.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Filters perform filtering in the &lt;code&gt;doFilter&lt;/code&gt; method.</span></span><br><span class="line"><span class="comment"> * Every Filter has access to a FilterConfig object from which it can obtain</span></span><br><span class="line"><span class="comment"> * its initialization parameters, and a reference to the ServletContext which</span></span><br><span class="line"><span class="comment"> * it can use, for example, to load resources needed for filtering tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Filters are configured in the deployment descriptor of a web</span></span><br><span class="line"><span class="comment"> * application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Examples that have been identified for this design are:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Authentication Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Logging and Auditing Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Image conversion Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Data compression Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Encryption Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Tokenizing Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Filters that trigger resource access events</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;XSL/T filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Mime-type chain Filter</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Servlet 2.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Called by the web container to indicate to a filter that it is</span></span><br><span class="line"><span class="comment">     * being placed into service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The servlet container calls the init</span></span><br><span class="line"><span class="comment">     * method exactly once after instantiating the filter. The init</span></span><br><span class="line"><span class="comment">     * method must complete successfully before the filter is asked to do any</span></span><br><span class="line"><span class="comment">     * filtering work.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The web container cannot place the filter into service if the init</span></span><br><span class="line"><span class="comment">     * method either</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Throws a ServletException</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Does not return within a time period defined by the web container</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &lt;code&gt;doFilter&lt;/code&gt; method of the Filter is called by the</span></span><br><span class="line"><span class="comment">     * container each time a request/response pair is passed through the</span></span><br><span class="line"><span class="comment">     * chain due to a client request for a resource at the end of the chain.</span></span><br><span class="line"><span class="comment">     * The FilterChain passed in to this method allows the Filter to pass</span></span><br><span class="line"><span class="comment">     * on the request and response to the next entity in the chain.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A typical implementation of this method would follow the following</span></span><br><span class="line"><span class="comment">     * pattern:</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Examine the request</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Optionally wrap the request object with a custom implementation to</span></span><br><span class="line"><span class="comment">     * filter content or headers for input filtering</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Optionally wrap the response object with a custom implementation to</span></span><br><span class="line"><span class="comment">     * filter content or headers for output filtering</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&lt;strong&gt;Either&lt;/strong&gt; invoke the next entity in the chain</span></span><br><span class="line"><span class="comment">     * using the FilterChain object</span></span><br><span class="line"><span class="comment">     * (&lt;code&gt;chain.doFilter()&lt;/code&gt;),</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&lt;strong&gt;or&lt;/strong&gt; not pass on the request/response pair to</span></span><br><span class="line"><span class="comment">     * the next entity in the filter chain to</span></span><br><span class="line"><span class="comment">     * block the request processing</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Directly set headers on the response after invocation of the</span></span><br><span class="line"><span class="comment">     * next entity in the filter chain.</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                         FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the web container to indicate to a filter that it is being</span></span><br><span class="line"><span class="comment">     * taken out of service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is only called once all threads within the filter&#x27;s</span></span><br><span class="line"><span class="comment">     * doFilter method have exited or after a timeout period has passed.</span></span><br><span class="line"><span class="comment">     * After the web container calls this method, it will not call the</span></span><br><span class="line"><span class="comment">     * doFilter method again on this instance of the filter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method gives the filter an opportunity to clean up any</span></span><br><span class="line"><span class="comment">     * resources that are being held (for example, memory, file handles,</span></span><br><span class="line"><span class="comment">     * threads) and make sure that any persistent state is synchronized</span></span><br><span class="line"><span class="comment">     * with the filter&#x27;s current state in memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们在初学阶段可以不用过分在意细节，上述源码的版本是3.1.0。通过上述源码我们得知，该接口中只有三个方法，分别是init初始化方法、doFilter方法(执行过滤代码的方法)、destroy销毁方法。</p><p>提示</p><blockquote><p>小伙伴们可以注意一下doFilter方法中的chain参数，稍后会讲这个参数是起什么作用的</p></blockquote><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>接下来我们需要创建Filter，创建步骤如下：</p><ol><li>实现javax.servlet.Filter接口</li><li>在doFilter()方法中执行过滤</li><li>如果满足过滤条件使用 chain.doFilter(request, response)放行</li><li>如果不满足过滤条件转发或重定向请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target01Filter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">//初始化方法可以不具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.打印一句话表明Filter执行了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器执行：Target01Filter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.检查是否满足过滤条件</span></span><br><span class="line">        <span class="comment">// 人为设定一个过滤条件：请求参数message是否等于gcc</span></span><br><span class="line">        <span class="comment">// 等于：放行</span></span><br><span class="line">        <span class="comment">// 不等于：将请求交给另一个Servlet处理</span></span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②检查请求参数是否等于monster</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;gcc&quot;</span>.equals(message)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行放行</span></span><br><span class="line">            <span class="comment">// FilterChain对象代表过滤器链</span></span><br><span class="line">            <span class="comment">// chain.doFilter(request, response)方法效果：将请求放行到下一个Filter，</span></span><br><span class="line">            <span class="comment">// 如果当前Filter已经是最后一个Filter了，那么就将请求放行到原本要访问的目标资源</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足过滤条件，交给另一个Servlet处理</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/SpecialServlet?method=toSpecialPage&quot;</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//销毁方法可以不具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提，我们只写上述代码过滤器是不会起作用的，要想让过滤器起作用，还需要在web.xml文件中注册该过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Target01Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Filter的友好名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target01Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Filter的全类名，便于Servlet容器创建Filter对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.gcc.filter.Target01Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Filter要拦截的目标资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定这个mapping对应的Filter名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target01Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过请求地址模式来设置要拦截的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Target01Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h3><table><thead><tr><th>生命周期阶段</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>Web应用启动时</td><td>一次</td></tr><tr><td>初始化</td><td>创建对象后</td><td>一次</td></tr><tr><td>拦截请求</td><td>接收到匹配的请求</td><td>多次</td></tr><tr><td>销毁</td><td>Web应用卸载前</td><td>一次</td></tr></tbody></table><h3 id="Filter过滤规则详述"><a href="#Filter过滤规则详述" class="headerlink" title="Filter过滤规则详述"></a>Filter过滤规则详述</h3><p>本节要探讨的是在filter-mapping中如何将Filter同它要拦截的资源关联起来。</p><h4 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h4><p>指定被拦截资源的完整路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Filter要拦截的目标资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定这个mapping对应的Filter名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target01Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过请求地址模式来设置要拦截的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Target01Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>相比较精确匹配，使用模糊匹配可以让我们创建一个Filter就能够覆盖很多目标资源，不必专门为每一个目标资源都创建Filter。</p><h5 id="前杠后星"><a href="#前杠后星" class="headerlink" title="前杠后星"></a>前杠后星</h5><p>在我们配置了url-pattern为&#x2F;user&#x2F;*之后，请求地址只要是&#x2F;user开头的那么就会被匹配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target02Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模糊匹配：前杠后星 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        /user/Target02Servlet</span></span><br><span class="line"><span class="comment">        /user/Target03Servlet</span></span><br><span class="line"><span class="comment">        /user/Target04Servlet</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>极端情况：&#x2F;*匹配所有请求</p><h5 id="前星后缀"><a href="#前星后缀" class="headerlink" title="前星后缀"></a>前星后缀</h5><p>可以匹配所有后缀为某个特定值的请求，举例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target03Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.gcc.filter.Target04Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target03Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.png<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该过滤可以拦截所有后缀为png的请求</p><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>多个Filter的<strong>拦截范围</strong>如果存在<strong>重合部分</strong>，那么这些Filter会形成<strong>Filter链</strong>。</li><li>浏览器请求重合部分对应的目标资源时，会<strong>依次经过</strong>Filter链中的每一个Filter。</li><li>Filter链中每一个Filter执行的<strong>顺序是由web.xml中filter-mapping配置的顺序决定</strong>的。</li></ul><p><img src="%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>创建超链接访问一个普通的Servlet即可</li><li>创建多个Filter拦截Servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/testServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/testServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="FilterChainh%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为一个Java后端初学者，本人水平有限，只能从Filter的应用层面给出自己的见解。如果小伙伴们需要更加深入地学习Filter这个组件，建议观看源码，毕竟源码之下没有秘密，愿开源精神永存。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文参考尚硅谷的JavaWeb教程，有兴趣的朋友可以去看看（b站直接搜索即可）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h2&gt;&lt;p&gt;Filter(过滤器)是JavaWeb三大组件之一，为了后续可以更好地掌握SpringMVC框架，仔细学习一下过滤器的基础知识是很有必要的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="过滤器" scheme="https://gccforstudy.github.io/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://gccforstudy.github.io/2022/08/16/hello-world/"/>
    <id>https://gccforstudy.github.io/2022/08/16/hello-world/</id>
    <published>2022-08-16T13:35:21.740Z</published>
    <updated>2022-08-18T13:44:38.790Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
