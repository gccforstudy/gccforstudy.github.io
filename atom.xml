<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gcc的博客</title>
  
  <subtitle>永远保持对技术的热爱</subtitle>
  <link href="https://gccforstudy.github.io/atom.xml" rel="self"/>
  
  <link href="https://gccforstudy.github.io/"/>
  <updated>2022-09-04T02:53:36.390Z</updated>
  <id>https://gccforstudy.github.io/</id>
  
  <author>
    <name>gcc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://gccforstudy.github.io/2022/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://gccforstudy.github.io/2022/09/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-04T02:49:16.000Z</published>
    <updated>2022-09-04T02:53:36.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="Pattern和Matcher类介绍"><a href="#Pattern和Matcher类介绍" class="headerlink" title="Pattern和Matcher类介绍"></a>Pattern和Matcher类介绍</h2><p>Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象。匹配结果保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象。</p><span id="more"></span><h3 id="Pattern-类的常用方法"><a href="#Pattern-类的常用方法" class="headerlink" title="Pattern 类的常用方法"></a>Pattern 类的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个字符串编译成 Pattern 对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*c&quot;</span>);</span><br><span class="line"><span class="comment">// 使用 Pattern 对象创建 Matcher 对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aac&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> m.matches();</span><br></pre></td></tr></table></figure><p>上面定义的 Pattern 对象可以多次重复使用。如果某个正则表达式仅需一次使用，则可直接使用 Pattern 类的静态 <code>matches()</code>方法，此方法自动把指定字符串编译成匿名的 Pattern 对象，并执行匹配，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Pattern.matches (<span class="string">&quot;a*c&quot;</span>,<span class="string">&quot;aac&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Matcher-类的常用方法"><a href="#Matcher-类的常用方法" class="headerlink" title="Matcher 类的常用方法"></a>Matcher 类的常用方法</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>find()</td><td>返回目标字符串中是否包含与 Pattern 匹配的子串</td></tr><tr><td>group()</td><td>返回上一次与 Pattern 匹配的子串</td></tr><tr><td>start()</td><td>返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置</td></tr><tr><td>end()</td><td>返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加 1</td></tr><tr><td>lookingAt()</td><td>返回目标字符串前面部分与 Pattern 是否匹配</td></tr><tr><td>matches()</td><td>返回整个目标字符串与 Pattern 是否匹配</td></tr><tr><td>reset()</td><td>将现有的 Matcher 对象应用于一个新的字符序列。</td></tr></tbody></table><h4 id="find-和-group-方法"><a href="#find-和-group-方法" class="headerlink" title="find()和 group()方法"></a>find()和 group()方法</h4><p>通过 Matcher 类的 <code>find()</code> 和 <code>group()</code> 方法可以从目标字符串中依次取出特定子串（匹配正则表达式的子串），例如互联网的网络爬虫，它们可以自动从网页中识别出所有的电话号码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字符串模拟从网络上得到的网页源码</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;出售JAVA教程，联系电话：13600000001&quot;</span> + <span class="string">&quot;毕业代做，联系电话：13600000002&quot;</span> + <span class="string">&quot;出售二手电脑，联系电话：15800000001&quot;</span>;</span><br><span class="line">   <span class="comment">// 创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line">   <span class="comment">// 该正则表达式只抓取13X和15X段的手机号</span></span><br><span class="line">   <span class="comment">// 实际要抓取哪些电话号码，只要修改正则表达式即可</span></span><br><span class="line">   <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;((13\\d)|(15\\d))\\d&#123;8&#125;&quot;</span>).matcher(str);</span><br><span class="line">   <span class="comment">// 将所有符合正则表达式的子串（电话号码）全部输出</span></span><br><span class="line">   <span class="keyword">while</span> (m.find())</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(m.group());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面运行结果可以看出，<code>find()</code> 方法依次查找字符串中与 Pattern 匹配的子串，一旦找到对应的子串，下次调用 <code>find()</code> 方法时将接着向下查找。</p><h4 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start()和 end()方法"></a>start()和 end()方法</h4><p><code>find()</code> 方法还可以传入一个 int 类型的参数，带 int 参数的 <code>find()</code> 方法将从该 int 索引处向下搜索。<code>start()</code> 和 <code>end() </code>方法主要用于确定子串在目标字符串中的位置，如下程序所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;Java is very easy!&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;目标字符串是：&quot;</span> + regStr);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>).matcher(regStr);</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(m.group() + <span class="string">&quot;子串的起始位置：&quot;</span> + m.start() + <span class="string">&quot;，其结束位置：&quot;</span> + m.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序使用 <code>find()</code>、<code>group()</code> 方法逐项取出目标字符串中与指定正则表达式匹配的子串，并使用<code>start()</code>、<code>end()</code> 方法返回子串在目标字符串中的位置。运行上面程序，看到如下运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目标字符串是：Java is very easy!</span><br><span class="line">Java子串的起始位置：<span class="number">0</span>，其结束位置：<span class="number">4</span></span><br><span class="line">is子串的起始位置：<span class="number">5</span>，其结束位置：<span class="number">7</span></span><br><span class="line">very子串的起始位置：<span class="number">8</span>，其结束位置：<span class="number">12</span></span><br><span class="line">easy子串的起始位置：<span class="number">13</span>，其结束位置：<span class="number">17</span></span><br></pre></td></tr></table></figure><h4 id="matches-和-lookingAt-方法"><a href="#matches-和-lookingAt-方法" class="headerlink" title="matches() 和 lookingAt() 方法"></a>matches() 和 lookingAt() 方法</h4><p><code>matches()</code> 和 <code>lookingAt()</code> 方法有点相似，只是 <code>matches()</code> 方法要求整个字符串和 Pattern 完全匹配时才返回 <code>true</code>，而 <code>lookingAt()</code> 只要字符串以 Pattern 开头就会返回 <code>true</code>。<code>reset()</code> 方法可将现有的 Matcher 对象应用于新的字符序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String[] mails =</span><br><span class="line">       &#123; <span class="string">&quot;mymail@163.com&quot;</span>, <span class="string">&quot;mymail@gmail.com&quot;</span>, <span class="string">&quot;mymail@myweb.org&quot;</span>, <span class="string">&quot;mymail@abc.xx&quot;</span> &#125;;</span><br><span class="line">       <span class="type">String</span> <span class="variable">mailRegEx</span> <span class="operator">=</span> <span class="string">&quot;\\w&#123;3,20&#125;@\\w+\\.(com|org|cn|net|gov)&quot;</span>;</span><br><span class="line">       <span class="type">Pattern</span> <span class="variable">mailPattern</span> <span class="operator">=</span> Pattern.compile(mailRegEx);</span><br><span class="line">       <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (String mail : mails)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (matcher == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               matcher = mailPattern.matcher(mail);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               matcher.reset(mail);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mail + (matcher.matches() ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;不是&quot;</span>) + <span class="string">&quot;一个有效的邮件地址！&quot;</span>;</span><br><span class="line">           System.out.println(result);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>上面程序创建了一个邮件地址的 Pattern，接着用这个 Pattern 与多个邮件地址进行匹配。当程序中的 Matcher 为 <code>null</code> 时，程序调用 <code>matcher()</code> 方法来创建一个 Matcher 对象，一旦 Matcher 对象被创建，程序就调用 Matcher 的 <code>reset()</code> 方法将该 Matcher 应用于新的字符序列。</p><p>从某个角度来看，Matcher 的 <code>matches()</code>、<code>lookingAt()</code> 和 String 类的 <code>equals()</code> 有点相似。区别是 String 类的 <code>equals()</code> 都是与字符串进行比较，而 Matcher 的 <code>matches()</code> 和 <code>lookingAt()</code> 则是与正则表达式进行匹配。</p><p>事实上，String 类里也提供了 <code>matches()</code> 方法，该方法返回该字符串是否匹配指定的正则表达式。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;mymail@163.com&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,20&#125;@\\w+\\.(com|org|cn|net|gov)&quot;</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在Matcher类中，<code>matches()</code>是必须全部匹配；<code>lookingAt()</code>匹配的字符必须要在字符串的最前面；<code>find()</code>匹配的字符可以在字符串的任意的地方。</p><p><code>start()</code>、<code>end()</code>、<code>group()</code>这三个方法必须是在有字符匹配到的条件下才能够调用，否则会报错。<code>start()</code>返回匹配到的子字符串在字符串中的索引位置，<code>end()</code>返回匹配到的子字符串的最后一个字符在字符串中的索引位置，<code>group()</code>返回匹配到的子字符串。另外，<code>start()</code>、<code>end()</code>、<code>group()</code>均有一个重载方法它们是<code>start(int group)</code>、<code>end(int group)</code>、<code>group(int group)</code>专用于分组操作。最后，Mathcer类还有一个<code>groupCount()</code>用于返回有多少组。</p><blockquote><p>举个例子来说明一下什么是分组：下面这个matcher对象有5个分组，每对括号就代表一个分组，并且groupCount()不会把整个正则表达式记录在内即group(0)不会被记录在内。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;([a-zA-Z0-9]+)([\\s]+)([a-zA-Z ]+)([\\s]+)([0-9]+)&quot;</span>);</span><br><span class="line">       <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       System.out.println(matcher.groupCount());</span><br></pre></td></tr></table></figure><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><table><thead><tr><th align="center">元字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">将下一个字符标记符、或一个向后引用、或一个八进制转义符。</td></tr><tr><td align="center">^</td><td align="center">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td align="center">$</td><td align="center">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td align="center">*</td><td align="center">匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，“zo”以及“zoo”。</em>等价于{0,}</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次(大于等于1次)。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td align="center">?</td><td align="center">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td align="center">{n}</td><td align="center">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td align="center">{n,}</td><td align="center">n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td align="center">{n,m}</td><td align="center">m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="center">x|y</td><td align="center">匹配x或y。</td></tr><tr><td align="center">[xyz]</td><td align="center">字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td align="center">[^xyz]</td><td align="center">负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td align="center">[a-z]</td><td align="center">字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td></tr><tr><td align="center">[^a-z]</td><td align="center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td align="center">.</td><td align="center">可以匹配任何字符</td></tr><tr><td align="center">\d</td><td align="center">匹配一个数字字符。等价于[0-9]</td></tr><tr><td align="center">\D</td><td align="center">匹配一个非数字字符。等价于[^0-9]</td></tr><tr><td align="center">\s</td><td align="center">匹配所有的空白字符，包括空格、制表符、换页符、换行符、回车符 等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td align="center">\S</td><td align="center">匹配所有的非空白字符</td></tr></tbody></table><p>大家可以去<a href="https://jex.im/regulex/#!flags=&re=">正则表达式可视化工具</a>测试一下</p><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><p><strong>.</strong>  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；</p><p><strong>.</strong>  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。</p><p>正则表达式一般是区分大小写的，但是也有些实现是不区分。</p><p>正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nam.</span><br></pre></td></tr></table></figure><p>匹配结果：</p><p><img src="%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6.png"></p><h2 id="匹配一组字符"><a href="#匹配一组字符" class="headerlink" title="匹配一组字符"></a>匹配一组字符</h2><p><strong>[ ]</strong>  定义一个字符集合；</p><p>0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。</p><p><strong>-</strong>  只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；</p><p><strong>^</strong>  在 [ ] 中是取非操作。</p><p>匹配以 abc 为开头，并且最后一个字母不为数字的字符串:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc[^<span class="number">0</span>-<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>匹配结果：</p><p><img src="%E5%8C%B9%E9%85%8D%E4%B8%80%E7%BB%84%E5%AD%97%E7%AC%A6.png"></p><h2 id="使用元字符"><a href="#使用元字符" class="headerlink" title="使用元字符"></a>使用元字符</h2><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[\b]</td><td align="center">回退(删除)一个字符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr></tbody></table><p>\r\n 是 Windows 中的文本行结束标签，在 Unix&#x2F;Linux 则是 \n。</p><p>\r\n\r\n 可以匹配 Windows 下的空白行，因为它将匹配两个连续的行尾标签，而这正是两条记录之间的空白行；</p><h3 id="匹配特定的字符类别"><a href="#匹配特定的字符类别" class="headerlink" title="匹配特定的字符类别"></a>匹配特定的字符类别</h3><h4 id="数字元字符"><a href="#数字元字符" class="headerlink" title="数字元字符"></a>数字元字符</h4><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\d</td><td align="center">数字字符，等价于 [0-9]</td></tr><tr><td align="center">\D</td><td align="center">非数字字符，等价于 [^0-9]</td></tr></tbody></table><h4 id="字母数字元字符"><a href="#字母数字元字符" class="headerlink" title="字母数字元字符"></a>字母数字元字符</h4><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\w</td><td align="center">大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]</td></tr><tr><td align="center">\W</td><td align="center">对 \w 取非</td></tr></tbody></table><h4 id="空白字符元字符"><a href="#空白字符元字符" class="headerlink" title="空白字符元字符"></a>空白字符元字符</h4><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\s</td><td align="center">任何一个空白字符，等价于 [\f\n\r\t\v]</td></tr><tr><td align="center">\S</td><td align="center">对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10，等价于 \n。</p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><ul><li><strong>+</strong> 匹配 1 个或者多个字符</li><li><strong>*</strong> 匹配 0 个或者多个</li><li><strong>?</strong> 匹配 0 个或者 1 个</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\w.]+@\w+\.\w+</span><br></pre></td></tr></table></figure><p>[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；</p><p>匹配结果：</p><p><img src="%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D.png"></p><ul><li><strong>{n}</strong> 匹配 n 个字符</li><li><strong>{m, n}</strong> 匹配 m~n 个字符</li><li><strong>{m,}</strong> 至少匹配 m 个字符</li></ul><p>* 和 + 都是贪婪型元字符，会匹配最多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.+c</span><br></pre></td></tr></table></figure><p>由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。</p><p>匹配结果：</p><p><img src="%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D.png"></p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="单词的边界"><a href="#单词的边界" class="headerlink" title="单词的边界"></a>单词的边界</h3><p><strong>\b</strong> 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong> 匹配一个不是单词边界的位置。（即\w和\w或\W和\W之间的位置）</p><p>\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。</p><p>详细解释大家可以查阅<a href="https://www.cnblogs.com/tnt-33/p/10676473.html">这篇文章</a></p><h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a>字符串边界</h3><p><strong>^</strong> 匹配整个字符串的开头，**$** 匹配结尾。</p><p>^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。</p><p>分行匹配模式(multiline)下，换行被当做字符串的边界。</p><h2 id="使用子表达式"><a href="#使用子表达式" class="headerlink" title="使用子表达式"></a>使用子表达式</h2><p>使用 <strong>( )</strong> 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。</p><p>子表达式可以嵌套，但是嵌套层次过深会变得很难理解。</p><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ab)&#123;<span class="number">2</span>,&#125;</span><br></pre></td></tr></table></figure><p>匹配结果：ababab…</p><p><strong>|</strong> 是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">19</span>|<span class="number">20</span>)\d&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>匹配结果：1900、2010</p><h2 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h2><p>回溯引用使用 <strong>\n</strong> 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。</p><p>应用：匹配 HTML 中合法的标题元素。</p><p>正则表达式：</p><p>\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(h[<span class="number">1</span>-<span class="number">6</span>])&gt;\w*?&lt;\/\<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>匹配结果：</p><p><img src="%E5%9B%9E%E6%BA%AF%E5%BC%95%E7%94%A8.png"></p><p>顺便提一下，如果你不清楚?的作用，那么你需要回看一下重复匹配这节内容。</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>需要用到两个正则表达式。</p><p>举例如下：</p><p>查找正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;<span class="number">3</span>&#125;)(-)(\d&#123;<span class="number">3</span>&#125;)(-)(\d&#123;<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><p>替换正则表达式:</p><p>在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($<span class="number">1</span>) $<span class="number">3</span>-$<span class="number">5</span></span><br></pre></td></tr></table></figure><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;313-555-1234&quot;</span>.replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)(-)(\\d&#123;3&#125;)(-)(\\d&#123;4&#125;)&quot;</span>, <span class="string">&quot;($1) $3-$5&quot;</span>);</span><br><span class="line">       System.out.println(s);</span><br></pre></td></tr></table></figure><p>结果：(313) 555-1234</p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\l</td><td align="center">把下个字符转换为小写</td></tr><tr><td align="center">\u</td><td align="center">把下个字符转换为大写</td></tr><tr><td align="center">\L</td><td align="center">把\L 和\E 之间的字符全部转换为小写</td></tr><tr><td align="center">\U</td><td align="center">把\U 和\E 之间的字符全部转换为大写</td></tr><tr><td align="center">\E</td><td align="center">结束\L 或者\U</td></tr></tbody></table><p>举例如下：</p><p>文本</p><p>abcd</p><p>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w)(\w&#123;<span class="number">2</span>&#125;)(\w)</span><br></pre></td></tr></table></figure><p>替换</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1\U$2\E$3</span><br></pre></td></tr></table></figure><p>结果</p><p>aBCd</p><h2 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h2><p>前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用  <strong>?&#x3D;</strong>  来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?&#x3D; 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;&#x3D; 定义(注: javaScript 不支持向后匹配, java 对其支持也不完善)。</p><p>举例如下：</p><p>查找出邮件地址 @ 字符前面的部分。</p><p>文本</p><p>abc @qq.com</p><p>正则表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\w+(?=@)</span><br></pre></td></tr></table></figure><p><strong>abc</strong> @qq.com</p><p>对向前和向后查找取非，只要把 &#x3D; 替换成 ! 即可，比如 (?&#x3D;) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容</p><h2 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h2><h3 id="回溯引用条件"><a href="#回溯引用条件" class="headerlink" title="回溯引用条件"></a>回溯引用条件</h3><p>条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。</p><p>正则表达式</p><p>子表达式 (() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\()?abc(?(<span class="number">1</span>)\))</span><br></pre></td></tr></table></figure><p>结果：（abc）匹配、abc匹配、（abc不匹配</p><h3 id="前后查找条件"><a href="#前后查找条件" class="headerlink" title="前后查找条件"></a>前后查找条件</h3><p>条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。</p><p>正则表达式</p><p>?(?&#x3D;-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;<span class="number">5</span>&#125;(?(?=-)-\d&#123;<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><p>结果：11111匹配、22222-不匹配、33333-4444匹配</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.</li><li><a href="https://pdai.tech/md/develop/regex/dev-regex-all.html">https://pdai.tech/md/develop/regex/dev-regex-all.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;Pattern和Matcher类介绍&quot;&gt;&lt;a href=&quot;#Pattern和Matcher类介绍&quot; class=&quot;headerlink&quot; title=&quot;Pattern和Matcher类介绍&quot;&gt;&lt;/a&gt;Pattern和Matcher类介绍&lt;/h2&gt;&lt;p&gt;Pattern 对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象。匹配结果保留在 Matcher 对象中，多个 Matcher 对象可共享同一个 Pattern 对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="正则表达式" scheme="https://gccforstudy.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>log4j2配置详解</title>
    <link href="https://gccforstudy.github.io/2022/09/02/log4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://gccforstudy.github.io/2022/09/02/log4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-09-02T08:23:50.000Z</published>
    <updated>2022-09-04T02:51:43.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="log4j2配置详解"><a href="#log4j2配置详解" class="headerlink" title="log4j2配置详解"></a>log4j2配置详解</h1><h2 id="log4j2介绍"><a href="#log4j2介绍" class="headerlink" title="log4j2介绍"></a>log4j2介绍</h2><p>log4j2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,”.json”或者”.jsn”。<br>配置文件的格式：log2j配置文件可以是xml格式的，也可以是json格式的。<br>配置文件的位置：log4j2默认会在classpath目录下寻找log4j2.xml、log4j.json、log4j.jsn等名称的文件。<br>系统选择配置文件的优先级(从先到后)如下：<br>　　(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件.<br>　　(2).classpath下的名为log4j2-test.xml的文件.<br>　　(3).classpath下名为log4j2.json 或者log4j2.jsn的文件.<br>　　(4).classpath下名为log4j2.xml的文件.<br>　　我们一般默认使用log4j2.xml进行命名。</p><span id="more"></span><h2 id="配置文件节点解析"><a href="#配置文件节点解析" class="headerlink" title="配置文件节点解析"></a>配置文件节点解析</h2><p>根节点Configuration有两个属性：</p><ul><li>status：用来指定log4j本身的打印日志的级别</li><li>monitorinterval：用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s</li></ul><p>两个子节点:</p><ul><li>Appenders</li><li>Loggers(表明可以定义多个Appender和Logger).</li></ul><h3 id="Appenders节点"><a href="#Appenders节点" class="headerlink" title="Appenders节点"></a>Appenders节点</h3><p>常见的有三种子节点:Console、RollingFile、File。Console节点用来定义输出到控制台的Appender。</p><h4 id="Console节点"><a href="#Console节点" class="headerlink" title="Console节点"></a>Console节点</h4><p>Console节点用来定义输出到控制台的Appender</p><ul><li>name:指定Appender的名字.</li><li>target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.</li><li>PatternLayout:输出格式，不设置默认为:%m%n.</li></ul><h4 id="File节点"><a href="#File节点" class="headerlink" title="File节点"></a>File节点</h4><p>File节点用来定义输出到指定位置的文件的Appender。</p><ul><li>name:指定Appender的名字.</li><li>fileName:指定输出日志的目的文件带全路径的文件名.</li><li>PatternLayout:输出格式，不设置默认为:%m%n.</li></ul><h4 id="RollingFile节点"><a href="#RollingFile节点" class="headerlink" title="RollingFile节点"></a>RollingFile节点</h4><p>RollingFile节点用来定义超过指定条件自动删除旧的创建新的Appender。</p><ul><li>name:指定Appender的名字.</li><li>fileName:指定输出日志的目的文件带全路径的文件名.</li><li>PatternLayout:输出格式，不设置默认为:%m%n.</li><li>filePattern : 指定当发生Rolling时，文件的转移和重命名规则.</li><li>Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志.</li><li>TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate&#x3D;true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am.</li><li>SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小.</li><li>DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。</li></ul><h3 id="Loggers节点"><a href="#Loggers节点" class="headerlink" title="Loggers节点"></a>Loggers节点</h3><p>Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</p><ul><li>Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。</li><li>level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.</li><li>name:用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点.</li><li>AppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity&#x3D;”false”只在自定义的Appender中进行输出。</li></ul><h2 id="配置参数解释"><a href="#配置参数解释" class="headerlink" title="配置参数解释"></a>配置参数解释</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>trace</td><td>追踪，就是程序推进一下，可以写个trace输出</td></tr><tr><td>debug</td><td>调试，一般作为最低级别，trace基本不用。</td></tr><tr><td>info</td><td>输出重要的信息，使用较多</td></tr><tr><td>warn</td><td>警告，有些信息不是错误信息，但也要给程序员一些提示。</td></tr><tr><td>error</td><td>错误信息。用的也很多。</td></tr><tr><td>fatal</td><td>致命错误</td></tr></tbody></table><h3 id="输出源"><a href="#输出源" class="headerlink" title="输出源"></a>输出源</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>CONSOLE</td><td>输出到控制台</td></tr><tr><td>FILE</td><td>输出到文件</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>SimpleLayout</td><td>以简单的形式显示</td></tr><tr><td>HTMLLayout</td><td>以HTML表格显示</td></tr><tr><td>PatternLayout</td><td>自定义形式显示</td></tr></tbody></table><p>PatternLayout自定义日志布局：</p><table><thead><tr><th align="center">格式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%d{HH:mm:ss.SSS}</td><td align="center">表示输出到毫秒的时间</td></tr><tr><td align="center">%t</td><td align="center">输出当前线程名称</td></tr><tr><td align="center">%-5level</td><td align="center">输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0</td></tr><tr><td align="center">%logger</td><td align="center">输出logger名称</td></tr><tr><td align="center">%msg</td><td align="center">日志文本</td></tr><tr><td align="center">%n</td><td align="center">换行</td></tr><tr><td align="center">%F</td><td align="center">输出所在的类文件名，如Log4j2Test.java</td></tr><tr><td align="center">%L</td><td align="center">输出行号</td></tr><tr><td align="center">%M</td><td align="center">输出所在方法名</td></tr><tr><td align="center">%l</td><td align="center">输出语句所在的行数, 包括类名、方法名、文件名、行数</td></tr></tbody></table><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--变量配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的日志路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的项目名&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;Filelog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/test.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileInfo&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/info.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileWarn&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/warn.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileError&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/error.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--监控系统信息--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Filelog&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileWarn&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileError&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/8mEU5ofwQPWA14JbtmQNrw">https://mp.weixin.qq.com/s/8mEU5ofwQPWA14JbtmQNrw</a></li><li><a href="https://www.cnblogs.com/keeya/p/10101547.html">https://www.cnblogs.com/keeya/p/10101547.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;log4j2配置详解&quot;&gt;&lt;a href=&quot;#log4j2配置详解&quot; class=&quot;headerlink&quot; title=&quot;log4j2配置详解&quot;&gt;&lt;/a&gt;log4j2配置详解&lt;/h1&gt;&lt;h2 id=&quot;log4j2介绍&quot;&gt;&lt;a href=&quot;#log4j2介绍&quot; class=&quot;headerlink&quot; title=&quot;log4j2介绍&quot;&gt;&lt;/a&gt;log4j2介绍&lt;/h2&gt;&lt;p&gt;log4j2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,”.json”或者”.jsn”。&lt;br&gt;配置文件的格式：log2j配置文件可以是xml格式的，也可以是json格式的。&lt;br&gt;配置文件的位置：log4j2默认会在classpath目录下寻找log4j2.xml、log4j.json、log4j.jsn等名称的文件。&lt;br&gt;系统选择配置文件的优先级(从先到后)如下：&lt;br&gt;　　(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件.&lt;br&gt;　　(2).classpath下的名为log4j2-test.xml的文件.&lt;br&gt;　　(3).classpath下名为log4j2.json 或者log4j2.jsn的文件.&lt;br&gt;　　(4).classpath下名为log4j2.xml的文件.&lt;br&gt;　　我们一般默认使用log4j2.xml进行命名。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日志" scheme="https://gccforstudy.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>JSON</title>
    <link href="https://gccforstudy.github.io/2022/08/31/JSON/"/>
    <id>https://gccforstudy.github.io/2022/08/31/JSON/</id>
    <published>2022-08-31T06:04:19.000Z</published>
    <updated>2022-08-31T06:05:39.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><ul><li>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</li><li>JSON 是轻量级的文本数据交换格式</li><li>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</li><li>JSON 具有自我描述性，更易理解</li></ul><span id="more"></span><h2 id="结构与类型"><a href="#结构与类型" class="headerlink" title="结构与类型"></a>结构与类型</h2><ul><li>只有两种结构：对象内的键值对集合结构和数组，对象用{}表示、内部是”key”:”value”，数组用[]表示，不同值用逗号分开</li><li>基本数值有7个： false &#x2F; null &#x2F; true &#x2F; object &#x2F; array &#x2F; number &#x2F; string</li><li>再加上结构可以嵌套，进而可以用来表达复杂的数据</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span>  <span class="number">800</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">600</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;Title&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;Thumbnail&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;Url&quot;</span><span class="punctuation">:</span>    <span class="string">&quot;http://www.example.com/image/481989943&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">125</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;100&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;IDs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116</span><span class="punctuation">,</span> <span class="number">943</span><span class="punctuation">,</span> <span class="number">234</span><span class="punctuation">,</span> <span class="number">38793</span><span class="punctuation">]</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JSON优秀资源"><a href="#JSON优秀资源" class="headerlink" title="JSON优秀资源"></a>JSON优秀资源</h2><p><a href="https://github.com/burningtree/awesome-json">awesom-json</a></p><h2 id="JSON类库"><a href="#JSON类库" class="headerlink" title="JSON类库"></a>JSON类库</h2><p>Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。</p><p>下面是几个常用的 JSON 解析类库：</p><ul><li>FastJson: 阿里巴巴开发的 JSON 库，性能优秀。</li><li>Jackson: 社区十分活跃且更新速度很快。</li><li>Gson: 谷歌开发的 JSON 库，功能十分全面。</li></ul><p>下面将详细介绍Jackson和Gson，不推荐使用FastJson，对FastJson感兴趣的小伙伴可以自行查阅资料。</p><h2 id="JackSon"><a href="#JackSon" class="headerlink" title="JackSon"></a>JackSon</h2><h3 id="JackSon简介"><a href="#JackSon简介" class="headerlink" title="JackSon简介"></a>JackSon简介</h3><ul><li><a href="https://github.com/FasterXML/jackson">Jackson Github </a> </li><li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson Wiki </a></li><li><a href="https://github.com/FasterXML/jackson-docs">Jackson 文档 </a></li></ul><h3 id="JackSon组件"><a href="#JackSon组件" class="headerlink" title="JackSon组件"></a>JackSon组件</h3><ul><li><strong>Streaming</strong>: jackson-core jar，定义了底层的streaming API和实现了Json特性。</li><li><strong>Annotations</strong>: jackson-annotations jar，包含了标准的Jackson注解。本文暂不介绍。</li><li><strong>Databind</strong>: jackson-databind jar，实现了数据绑定和对象序列化，它依赖于streaming和annotations的包。</li></ul><h3 id="JackSon的使用"><a href="#JackSon的使用" class="headerlink" title="JackSon的使用"></a>JackSon的使用</h3><p>引用maven jar包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本自选--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="序列化一个对象成JSON字符串"><a href="#序列化一个对象成JSON字符串" class="headerlink" title="序列化一个对象成JSON字符串"></a>序列化一个对象成JSON字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;gcc&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;JSON:&quot;</span> + jsonStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：JSON:&#123;&quot;username&quot;:&quot;gcc&quot;,&quot;password&quot;:&quot;admin&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="反序列化一个JSON字符串成Java对象"><a href="#反序列化一个JSON字符串成Java对象" class="headerlink" title="反序列化一个JSON字符串成Java对象"></a>反序列化一个JSON字符串成Java对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toObj</span><span class="params">()</span> <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputJsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;gcc\&quot;,\&quot;password\&quot;:\&quot;admin\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.readValue(inputJsonStr, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user info:&quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果JSON字符串中有无法对应的字段，readValue方法会抛出JsonMappingException异常</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a>@JsonProperty</h4><p>@JsonProperty注解主要用于实体类的属性上,作用可以简单的理解为在反序列化的时候给属性重命名(多一个名字来识别)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty(&quot;user_name&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username; <span class="comment">//这时可以在反序列化时写user_name，同样会映射到username字段</span></span><br></pre></td></tr></table></figure><h4 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h4><p>@JsonIgnore注解被用来标注在某个属性上，在序列化时，被标注的属性会被忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanWithIgnore</span> &#123;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在序列化时id字段不会被序列化</p><h4 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a>@JsonInclude</h4><p>@JsonInclude注解可以用来在序列化时，排除掉某些属性，即不序列化某些属性</p><p>@JsonInclude注解有两个很重要的属性，源码如下(只列出了一分部源码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonInclude</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inclusion rule to use for instances (values) of types (Classes) or</span></span><br><span class="line"><span class="comment">     * properties annotated; defaults to &#123;<span class="doctag">@link</span> Include#ALWAYS&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Include <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Include.ALWAYS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inclusion rule to use for entries (&quot;content&quot;) of annotated</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.util.Map&#125;s and referential types (like</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.util.concurrent.atomic.AtomicReference&#125;);</span></span><br><span class="line"><span class="comment">     * defaults to &#123;<span class="doctag">@link</span> Include#ALWAYS&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Include <span class="title function_">content</span><span class="params">()</span> <span class="keyword">default</span> Include.ALWAYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value属性用来定义排除规则，content属性用来定义map集合中entry的排除规则（排除规则在@JsonInclude源码的枚举类Include中，大家可以自行查阅），如果你想对map集合进行排除规则的设置，你既需要设置value，也需要设置content。因为value仅可以设置对map集合本身的排除规则，而content可以设置对map集合中entry的排除规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span> &#123;</span><br><span class="line">    <span class="meta">@JsonInclude(value=Include.NON_EMPTY, content=Include.NON_NULL)</span></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String,String&gt; entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的@JsonInclude注解表示，只有当entries不为空，才序列化entries集合中的不为null的entry。</p><h4 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h4><p>可以定制某个字段使用自定义的字段转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要被序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventWithSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonSerialize(using = CustomDateSerializer.class)</span></span><br><span class="line">    <span class="keyword">public</span> Date eventDate;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">EventWithSerializer</span><span class="params">(String name, Date evenDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.evenDate = evenDate;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制化的序列器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDateSerializer</span> <span class="keyword">extends</span> <span class="title class_">StdSerializer</span>&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">formatter</span> </span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateSerializer</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateSerializer</span><span class="params">(Class&lt;Date&gt; t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(t); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(</span></span><br><span class="line"><span class="params">      Date value, JsonGenerator gen, SerializerProvider arg2)</span> </span><br><span class="line">      <span class="keyword">throws</span> IOException, JsonProcessingException &#123;</span><br><span class="line">        gen.writeString(formatter.format(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenSerializingUsingJsonSerialize_thenCorrect</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> JsonProcessingException, ParseException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">df</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">toParse</span> <span class="operator">=</span> <span class="string">&quot;20-12-2014 02:30:00&quot;</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(toParse);</span><br><span class="line">    <span class="type">EventWithSerializer</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventWithSerializer</span>(<span class="string">&quot;party&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(event);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：{“name”:”party”,”evenDate”:”20-12-2014 02:30:00”}</p><p>我们发现evenDate字段在序列化的时候是按照CustomDateSerializer的formatter格式化的。</p><h4 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h4><p>与@JsonSerialize注解的操作大致是一样的，可以指定某个属性在反序列化时，使用特定的Deserializer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventWithSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonDeserialize(using = CustomDateDeserializer.class)</span></span><br><span class="line">    <span class="keyword">public</span> Date eventDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义的deserializer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomDateDeserializer</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">StdDeserializer</span>&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">formatter</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateDeserializer</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomDateDeserializer</span><span class="params">(Class&lt;?&gt; vc)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(vc); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">deserialize</span><span class="params">(</span></span><br><span class="line"><span class="params">      JsonParser jsonparser, DeserializationContext context)</span> </span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> jsonparser.getText();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> formatter.parse(date);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenDeserializingUsingJsonDeserialize_thenCorrect</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span></span><br><span class="line">      <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>name<span class="string">&quot;:&quot;</span>party<span class="string">&quot;,&quot;</span>eventDate<span class="string">&quot;:&quot;</span><span class="number">20</span>-<span class="number">12</span>-<span class="number">2014</span> <span class="number">02</span>:<span class="number">30</span>:<span class="number">00</span><span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">df</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;dd-MM-yyyy hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">EventWithSerializer</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>()</span><br><span class="line">      .readerFor(EventWithSerializer.class)</span><br><span class="line">      .readValue(json);</span><br><span class="line">    </span><br><span class="line">    assertEquals(</span><br><span class="line">      <span class="string">&quot;20-12-2014 02:30:00&quot;</span>, df.format(event.eventDate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h4><p>@JsonAutoDetect可以标注在类上，覆盖类中属性的可见性。比如你可以通过在类上标注@JsonAutoDetect(fieldVisibility &#x3D; Visibility.ANY)来序列化类中的所有属性，因为私有的属性在默认情况下不会被序列化。（默认情况下只有public属性才会被序列化）</p><h4 id="JsonRawValue"><a href="#JsonRawValue" class="headerlink" title="@JsonRawValue"></a>@JsonRawValue</h4><p>被@JsonRawValue标注的属性可以被原封不动的输出，原封不动指的是直接输出字符串中的内容且进行转义（不包括字符串的双引号），如果不加@JsonRawValue注解，输出的字符串内部不会转义也不会去掉最外部的双引号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如有字符串&quot;\&quot;hello: \&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加@JsonRawValue时，序列化的输出为&quot;hello: &quot;world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不加@JsonRawValue时，序列化的输出为 &quot;\&quot;hello: \&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JsonValue"><a href="#JsonValue" class="headerlink" title="@JsonValue"></a>@JsonValue</h4><p>@JsonValue用在方法上，序列化时用该方法序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TypeEnumWithValue</span> &#123;</span><br><span class="line">    TYPE1(<span class="number">1</span>, <span class="string">&quot;Type A&quot;</span>), TYPE2(<span class="number">2</span>, <span class="string">&quot;Type 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    TypeEnumWithValue(<span class="type">int</span> i, String s) &#123;</span><br><span class="line">        id = i;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException, ParseException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">enumAsString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>()</span><br><span class="line">                .writeValueAsString(TypeEnumWithValue.TYPE1);</span><br><span class="line"></span><br><span class="line">        System.out.println(enumAsString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出为：”Type A”</p><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><h3 id="Gson介绍"><a href="#Gson介绍" class="headerlink" title="Gson介绍"></a>Gson介绍</h3><p>Gson是这样一个Java类库，它可以将Java对象转换为相应的JSON形式，也可以将JSON字符串转换为对应的Java对象。 Gson可以使用任意Java对象，包括哪些预先存在的、不在你的源代码中的对象（因此，你并不知道对象的属性）。</p><ul><li><a href="https://www.jianshu.com/p/1e20b28c39d1">Gson用户指南（中文翻译）</a></li></ul><h3 id="Gson的使用"><a href="#Gson的使用" class="headerlink" title="Gson的使用"></a>Gson的使用</h3><p>使用Gson的首要类是Gson类，你可以仅仅通过new Gson()的方式创建它。你也可以通过GsonBuilder类去创建Gson实例，这个类允许你进行一系列配置，例如版本控制等等。</p><p>Gson实例不会保存任何进行Json操作时的状态。因此，你可以自由的复用相同的Gson对象进行诸多的Json序列化和反序列化操作。</p><p>引用maven jar包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多关于Gson序列化和反序列化的操作，大家可以参考<a href="https://www.jianshu.com/p/1e20b28c39d1">Gson用户指南</a>或<a href="https://link.jianshu.com/?t=https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a></li><li><a href="https://www.runoob.com/w3cnote/fastjson-intro.htm">https://www.runoob.com/w3cnote/fastjson-intro.htm</a></li><li><a href="https://blog.csdn.net/m0_37076574/article/details/81317403">https://blog.csdn.net/m0_37076574/article/details/81317403</a></li><li><a href="https://blog.csdn.net/blueheart20/article/details/52212221">https://blog.csdn.net/blueheart20/article/details/52212221</a></li><li><a href="https://blog.csdn.net/gjb724332682/article/details/51586701">https://blog.csdn.net/gjb724332682/article/details/51586701</a></li><li><a href="https://www.jianshu.com/p/1e20b28c39d1">https://www.jianshu.com/p/1e20b28c39d1</a></li><li><a href="https://www.jianshu.com/p/923a9fe78108">https://www.jianshu.com/p/923a9fe78108</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h1&gt;&lt;h2 id=&quot;JSON是什么&quot;&gt;&lt;a href=&quot;#JSON是什么&quot; class=&quot;headerlink&quot; title=&quot;JSON是什么&quot;&gt;&lt;/a&gt;JSON是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）&lt;/li&gt;
&lt;li&gt;JSON 是轻量级的文本数据交换格式&lt;/li&gt;
&lt;li&gt;JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。&lt;/li&gt;
&lt;li&gt;JSON 具有自我描述性，更易理解&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="JSON" scheme="https://gccforstudy.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC视图解析器</title>
    <link href="https://gccforstudy.github.io/2022/08/28/SpringMVC%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>https://gccforstudy.github.io/2022/08/28/SpringMVC%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/</id>
    <published>2022-08-28T03:28:42.000Z</published>
    <updated>2022-08-28T03:37:49.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更好地理解SpringMVC的工作流程，深入学习视图解析器是非常有必要的。希望这篇文章可以帮助大家更好地了解视图解析器。</p><span id="more"></span><p>当我们对<a href="https://so.csdn.net/so/search?q=SpringMVC&spm=1001.2101.3001.7020">SpringMVC</a>控制的资源发起请求时，这些请求都会被SpringMVC的DispatcherServlet处理，接着Spring会分析看哪一个HandlerMapping定义的所有请求映射中存在对该请求的最合理的映射。然后通过该HandlerMapping取得其对应的Handler，接着再通过相应的HandlerAdapter处理该Handler。HandlerAdapter在对Handler进行处理之后会返回一个ModelAndView对象。在获得了ModelAndView对象之后，Spring就需要把该View渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是ViewResolver和View。当Handler返回的ModelAndView中不包含真正的视图，只返回一个逻辑视图名称的时候，ViewResolver就会把该逻辑视图名称解析为真正的视图View对象。View是真正进行视图渲染，把结果返回给浏览器的。</p><h2 id="ViewResolver和View"><a href="#ViewResolver和View" class="headerlink" title="ViewResolver和View"></a>ViewResolver和View</h2><p><em>SpringMVC</em>用于处理视图最重要的两个接口是<em>ViewResolver</em>和<em>View</em>。<em>ViewResolver</em>的主要作用是把一个逻辑上的视图名称解析为一个真正的视图，<em>SpringMVC</em>中用于把<em>View</em>对象呈现给客户端的是<em>View</em>对象本身，而<em>ViewResolver</em>只是把逻辑视图名称解析为对象的<em>View</em>对象。<em>View</em>接口的主要作用是用于处理视图，然后返回给客户端。</p><p><em>Spring</em>为我们提供了非常多的视图解析器，下面将列举一些视图解析器。</p><h3 id="AbstractCachingViewResolver"><a href="#AbstractCachingViewResolver" class="headerlink" title="AbstractCachingViewResolver"></a>AbstractCachingViewResolver</h3><p><em><strong>AbstractCachingViewResolver</strong></em>：这是一个抽象类，这种视图解析器会把它曾经解析过的视图保存起来，然后每次要解析视图的时候先从缓存里面找，如果找到了对应的视图就直接返回，如果没有就创建一个新的视图对象，然后把它放到一个用于缓存的<em>map</em>中，接着再把新建的视图返回。使用这种视图缓存的方式可以把解析视图的性能问题降到最低。</p><h3 id="UrlBasedViewResolver"><a href="#UrlBasedViewResolver" class="headerlink" title="UrlBasedViewResolver"></a>UrlBasedViewResolver</h3><p><em><strong>UrlBasedViewResolver</strong></em>：它是对<em>ViewResolver</em>的一种简单实现，而且继承了<em>AbstractCachingViewResolver</em>，主要就是提供的一种拼接<em>URL</em>的方式来解析视图，它可以让我们通过<em>prefix</em>属性指定一个指定的前缀，通过<em>suffix</em>属性指定一个指定的后缀，然后把返回的逻辑视图名称加上指定的前缀和后缀就是指定的视图<em>URL</em>了。如<em>prefix&#x3D;&#x2F;WEB-INF&#x2F;jsps&#x2F;<em>，</em>suffix&#x3D;.jsp</em>，返回的视图名称<em>viewName&#x3D;test&#x2F;indx</em>，则<em>UrlBasedViewResolver</em>解析出来的视图<em>URL</em>就是*&#x2F;WEB-INF&#x2F;jsps&#x2F;test&#x2F;index.jsp<em>。默认的</em>prefix<em>和</em>suffix<em>都是空串。</em>URLBasedViewResolver<em>支持返回的视图名称中包含</em>redirect:*前缀，这样就可以支持*URL<em>在客户端的跳转，如当返回的视图名称是</em>”redirect:test.do”<em>的时候，</em>URLBasedViewResolver<em>发现返回的视图名称包含</em>”redirect:”<em>前缀，于是把返回的视图名称前缀</em>”redirect:”<em>去掉，取后面的</em>test.do<em>组成一个</em>RedirectView<em>，</em>RedirectView<em>中将把请求返回的模型属性组合成查询参数的形式组合到</em>redirect<em>的</em>URL<em>后面，然后调用</em>HttpServletResponse<em>对象的</em>sendRedirect<em>方法进行重定向。同样</em>URLBasedViewResolver<em>还支持</em>forword:<em>前缀，对于视图名称中包含</em>forword:<em>前缀的视图名称将会被封装成一个</em>InternalResourceView<em>对象，然后在服务器端利用</em>RequestDispatcher<em>的</em>forword<em>方式跳转到指定的地址。使用</em>UrlBasedViewResolver<em>的时候必须指定属性</em>viewClass<em>，表示解析成哪种视图，一般使用较多的就是</em>InternalResourceView<em>，利用它来展现</em>jsp<em>，但是当我们使用</em>JSTL<em>的时候我们必须使用</em>JstlView<em>。下面是一段</em>UrlBasedViewResolver<em>的定义，根据该定义，当返回的逻辑视图名称是</em>test<em>的时候，</em>UrlBasedViewResolver<em>将把逻辑视图名称加上定义好的前缀和后缀，即“</em>&#x2F;WEB-INF&#x2F;test.jsp<em>”，然后新建一个</em>viewClass<em>属性指定的视图类型予以返回，即返回一个</em>url<em>为“</em>&#x2F;WEB-INF&#x2F;test.jsp<em>”的</em>InternalResourceView*对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="InternalResourceViewResolver"><a href="#InternalResourceViewResolver" class="headerlink" title="InternalResourceViewResolver"></a>InternalResourceViewResolver</h3><p><em><strong>InternalResourceViewResolver</strong></em>：它是<em>URLBasedViewResolver</em>的子类，所以<em>URLBasedViewResolver</em>支持的特性它都支持。在实际应用中<em>InternalResourceViewResolver</em>也是使用的最广泛的一个视图解析器。那么<em>InternalResourceViewResolver</em>有什么自己独有的特性呢？单从字面意思来看，我们可以把<em>InternalResourceViewResolver</em>解释为内部资源视图解析器，这就是<em>InternalResourceViewResolver</em>的一个特性。<em>InternalResourceViewResolver</em>会把返回的视图名称都解析为<em>InternalResourceView</em>对象，<em>InternalResourceView</em>会把<em>Controller</em>处理器方法返回的模型属性都存放到对应的<em>request</em>属性中，然后通过<em>RequestDispatcher</em>在服务器端把请求<em>forword</em>转发到目标<em>URL</em>。比如在<em>InternalResourceViewResolver</em>中定义了<em>prefix&#x3D;&#x2F;WEB-INF&#x2F;<em>，</em>suffix&#x3D;.jsp</em>，然后请求的<em>Controller</em>处理器方法返回的视图名称为<em>test</em>，那么这个时候<em>InternalResourceViewResolver</em>就会把<em>test</em>解析为一个<em>InternalResourceView</em>对象，先把返回的模型属性都存放到对应的<em>HttpServletRequest</em>属性中，然后利用<em>RequestDispatcher</em>在服务器端把请求<em>forword</em>到*&#x2F;WEB-INF&#x2F;test.jsp<em>。这就是</em>InternalResourceViewResolver<em>一个非常重要的特性，我们都知道存放在</em>&#x2F;WEB-INF&#x2F;<em>下面的内容是不能直接通过</em>request<em>请求的方式请求到的，为了安全性考虑，我们通常会把</em>jsp<em>文件放在</em>WEB-INF<em>目录下，而</em>InternalResourceView<em>在服务器端跳转的方式可以很好的解决这个问题。下面是一个</em>InternalResourceViewResolver<em>的定义，根据该定义当返回的逻辑视图名称是</em>test<em>的时候，</em>InternalResourceViewResolver<em>会给它加上定义好的前缀和后缀，组成“</em>&#x2F;WEB-INF&#x2F;test.jsp<em>”的形式，然后把它当做一个</em>InternalResourceView<em>的</em>url<em>新建一个</em>InternalResourceView*对象返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XmlViewResolver"><a href="#XmlViewResolver" class="headerlink" title="XmlViewResolver"></a>XmlViewResolver</h3><p><em><strong>XmlViewResolver</strong></em>：它继承自<em>AbstractCachingViewResolver</em>抽象类，所以它也是支持视图缓存的。<em>XmlViewResolver</em>需要给定一个<em>xml</em>配置文件，该文件将使用和<em>Spring</em>的<em>bean</em>工厂配置文件一样的<em>DTD</em>定义，所以其实该文件就是用来定义视图的<em>bean</em>对象的。在该文件中定义的每一个视图的<em>bean</em>对象都给定一个名字，然后<em>XmlViewResolver</em>将根据<em>Controller</em>处理器方法返回的逻辑视图名称到<em>XmlViewResolver</em>指定的配置文件中寻找对应名称的视图<em>bean</em>用于处理视图。该配置文件默认是*&#x2F;WEB-INF&#x2F;views.xml<em>文件，如果不使用默认值的时候可以在</em>XmlViewResolver<em>的</em>location<em>属性中指定它的位置。</em>XmlViewResolver<em>还实现了</em>Ordered<em>接口，因此我们可以通过其</em>order<em>属性来指定在</em>ViewResolver<em>链中它所处的位置，</em>order<em>的值越小优先级越高。以下是使用</em>XmlViewResolver*的一个示例：</p><p>（<em>1</em>）在<em>SpringMVC</em>的配置文件中加入<em>XmlViewResolver</em>的<em>bean</em>定义。使用<em>location</em>属性指定其配置文件所在的位置，<em>order</em>属性指定当有多个<em>ViewResolver</em>的时候其处理视图的优先级。关于<em>ViewResolver</em>链的问题将在后续内容中讲到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（<em>2</em>）在<em>XmlViewResolver</em>对应的配置文件中配置好所需要的视图定义。在下面的代码中我们就配置了一个名为<em>internalResource</em>的<em>InternalResourceView</em>，其<em>url</em>属性为“*&#x2F;index.jsp*”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（<em>3</em>）定义一个返回的逻辑视图名称为在<em>XmlViewResolver</em>配置文件中定义的视图名称——<em>internalResource</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/xmlViewResolver&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testXmlViewResolver</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;internalResource&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>4</em>）这样当我们访问到上面定义好的<em>testXmlViewResolver</em>处理器方法的时候返回的逻辑视图名称为“<em>internalResource</em>”，这时候<em>Spring</em>就会到定义好的<em>views.xml</em>中寻找<em>id</em>或<em>name</em>为“<em>internalResource</em>”的<em>bean</em>对象予以返回，这里<em>Spring</em>找到的是一个<em>url</em>为“*&#x2F;index.jsp<em>”的</em>InternalResourceView*对象。</p><h3 id="BeanNameViewResolver"><a href="#BeanNameViewResolver" class="headerlink" title="BeanNameViewResolver"></a>BeanNameViewResolver</h3><p><em><strong>BeanNameViewResolver</strong></em>：这个视图解析器跟<em>XmlViewResolver</em>有点类似，也是通过把返回的逻辑视图名称去匹配定义好的视图<em>bean</em>对象。不同点有二，一是<em>BeanNameViewResolver</em>要求视图<em>bean</em>对象都定义在<em>Spring</em>的<em>application context</em>(IOC容器中)中，而<em>XmlViewResolver</em>是在指定的配置文件中寻找视图<em>bean</em>对象，二是<em>BeanNameViewResolver</em>不会进行视图缓存。看一个例子，在<em>SpringMVC</em>的配置文件中定义了一个<em>BeanNameViewResolver</em>视图解析器和一个<em>id</em>为<em>test</em>的<em>InternalResourceview bean</em>对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样当返回的逻辑视图名称是 <em>test</em>的时候，就会解析为上面定义好<em>id</em>为<em>test</em>的<em>InternalResourceView</em>。</p><h3 id="ResourceBundleViewResolver"><a href="#ResourceBundleViewResolver" class="headerlink" title="ResourceBundleViewResolver"></a>ResourceBundleViewResolver</h3><p><em><strong>ResourceBundleViewResolver</strong></em>：它和<em>XmlViewResolver</em>一样，也是继承自<em>AbstractCachingViewResolver</em>，但是它缓存的不是视图，这个会在后面有说到。和<em>XmlViewResolver</em>一样它也需要有一个配置文件来定义逻辑视图名称和真正的<em>View</em>对象的对应关系，不同的是<em>ResourceBundleViewResolver</em>的配置文件是一个属性文件，而且必须是放在<em>classpath</em>路径下面的，默认情况下这个配置文件是在<em>classpath</em>根目录下的<em>views.properties</em>文件，如果不使用默认值的话，则可以通过属性<em>baseName</em>或<em>baseNames</em>来指定。<em>baseName</em>只是指定一个基名称，<em>Spring</em>会在指定的<em>classpath</em>根目录下寻找以指定的<em>baseName</em>开始的属性文件进行<em>View</em>解析，如指定的<em>baseName</em>是<em>base</em>，那么<em>base.properties</em>、<em>baseabc.properties</em>等等以<em>base</em>开始的属性文件都会被<em>Spring</em>当做<em>ResourceBundleViewResolver</em>解析视图的资源文件。<em>ResourceBundleViewResolver</em>使用的属性配置文件的内容类似于这样：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resourceBundle.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">resourceBundle.url</span>=<span class="string">/index.jsp</span></span><br><span class="line"><span class="attr">test.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">test.url</span>=<span class="string">/test.jsp</span></span><br></pre></td></tr></table></figure><p>在这个配置文件中我们定义了两个<em>InternalResourceView</em>对象，一个的名称是<em>resourceBundle</em>，对应<em>URL</em>是*&#x2F;index.jsp<em>，另一个名称是</em>test<em>，对应的</em>URL<em>是</em>&#x2F;test.jsp<em>。从这个定义来看我们可以知道</em>resourceBundle<em>是对应的视图名称，使用</em>resourceBundle.(class)*来指定它对应的视图类型，*resourceBundle.url*指定这个视图的*url<em>属性。会思考的读者看到这里可能会有这样一个问题：为什么</em>resourceBundle<em>的</em>class<em>属性要用小括号包起来，而它的</em>url<em>属性就不需要呢？这就需要从</em>ResourceBundleViewResolver<em>进行视图解析的方法来说了。</em>ResourceBundleViewResolver<em>还是通过</em>bean<em>工厂来获得对应视图名称的视图</em>bean<em>对象来解析视图的。那么这些</em>bean<em>从哪里来呢？就是从我们定义的</em>properties<em>属性文件中来。在</em>ResourceBundleViewResolver<em>第一次进行视图解析的时候会先</em>new<em>一个</em>BeanFactory<em>对象，然后把</em>properties<em>文件中定义好的属性按照它自身的规则生成一个个的</em>bean<em>对象注册到该</em>BeanFactory<em>中，之后会把该</em>BeanFactory<em>对象保存起来，所以</em>ResourceBundleViewResolver<em>缓存的是</em>BeanFactory<em>，而不是直接的缓存从</em>BeanFactory<em>中取出的视图</em>bean<em>。然后会从</em>bean<em>工厂中取出名称为逻辑视图名称的视图</em>bean<em>进行返回。接下来就讲讲</em>Spring<em>通过</em>properties<em>文件生成</em>bean<em>的规则。它会把</em>properties<em>文件中定义的属性名称按最后一个点“</em>.<em>”进行分割，把点前面的内容当做是</em>bean<em>名称，点后面的内容当做是</em>bean<em>的属性。这其中有几个特别的属性，</em>Spring<em>把它们用小括号包起来了，这些特殊的属性一般是对应的</em>attribute<em>，但不是</em>bean<em>对象所有的</em>attribute<em>都可以这样用。其中</em>(class)<em>是一个，除了</em>(class)<em>之外，还有</em>(scope)<em>、</em>(parent)<em>、</em>(abstract)<em>、</em>(lazy-init)<em>。而除了这些特殊的属性之外的其他属性，</em>Spring<em>会把它们当做</em>bean<em>对象的一般属性进行处理，就是</em>bean<em>对象对应的</em>property<em>。所以根据上面的属性配置文件将生成如下两个</em>bean*对象：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;resourceBundle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/test.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从<em>ResourceBundleViewResolver</em>使用的配置文件我们可以看出，它和<em>XmlViewResolver</em>一样可以解析多种不同类型的<em>View</em>，因为它们的<em>View</em>是通过配置的方式指定的，这也就意味着我们可以指定<em>A</em>视图是<em>InternalResourceView</em>，<em>B</em>视图是<em>JstlView</em>。</p><p>来看下面这个一个例子，我在<em>SpringMVC</em>的配置文件中定义了一个<em>ResourceBundleViewResolver</em>对象，指定其<em>baseName</em>为<em>views</em>，然后<em>order</em>为<em>1</em>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;views&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我在<em>classpath</em>的根目录下有两个属性文件，一个是<em>views.properties</em>，一个是<em>views_abc.properties</em>，它们的内容分别如下：</p><p><em>views.properties</em>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resourceBundle.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">resourceBundle.url</span>=<span class="string">/index.jsp</span></span><br><span class="line"><span class="attr">test.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">test.url</span>=<span class="string">/test.jsp</span></span><br></pre></td></tr></table></figure><p><em>views_abc.properties</em>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">abc.(class)</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceView</span></span><br><span class="line"><span class="attr">abc.url</span>=<span class="string">/abc.jsp</span></span><br></pre></td></tr></table></figure><p>定义了如下这样一个<em>Controller</em>，它有三个处理器方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;resourceBundle&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">resourceBundle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;resourceBundle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;testResourceBundle&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testResourceBundle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;abc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">abc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当我们请求*&#x2F;mytest&#x2F;resourceBundle的时候，<em>ResourceBundleViewResolver</em>会首先尝试着来解析该视图，这里<em>Controller</em>处理器方法返回的逻辑视图名称是<em>resourceBundle</em>，<em>ResourceBundleViewResolver</em>按照上面提到的解析方法进行解析，这个时候它发现它是可以解析的，然后就返回了一个<em>url</em>为*&#x2F;index.jsp<em>的</em>InternalResourceView<em>对象。同样，请求</em>mytest&#x2F;testResourceBundle<em>返回的逻辑视图</em>test<em>和</em>&#x2F;mytest&#x2F;abc.do<em>返回的逻辑视图</em>abc<em>它都可以解析。当我们把</em>basename<em>指定为包的形式，如“*com.tiantian.views*”，的时候</em>Spring<em>会按照点“</em>.<em>”划分为目录的形式，到</em>classpath<em>相应目录下去寻找</em>basename<em>开始的配置文件，如上面我们指定</em>basename<em>为“</em>com.tiantian.views<em>”，那么</em>spring<em>就会到</em>classpath<em>下的</em>com&#x2F;tiantian*目录下寻找文件名以views开始的properties文件作为解析视图的配置文件。</p><h3 id="FreeMakerViewResolver"><a href="#FreeMakerViewResolver" class="headerlink" title="FreeMakerViewResolver"></a>FreeMakerViewResolver</h3><p><em><strong>FreeMarkerViewResolver</strong></em>、<em><strong>VolocityViewResolver</strong></em>：这两个视图解析器都是<em>UrlBasedViewResolver</em>的子类。<em>FreeMarkerViewResolver</em>会把<em>Controller</em>处理方法返回的逻辑视图解析为<em>FreeMarkerView</em>，而<em>VolocityViewResolver</em>会把返回的逻辑视图解析为<em>VolocityView</em>。因为这两个视图解析器类似，所以这里我就只挑<em>FreeMarkerViewResolver</em>来做一个简单的讲解。<em>FreeMarkerViewResolver</em>和<em>VilocityViewResolver</em>都继承了<em>UrlBasedViewResolver</em>。</p><p>对于<em>FreeMarkerViewResolver</em>而言，它会按照<em>UrlBasedViewResolver</em>拼接<em>URL</em>的方式进行视图路径的解析。但是使用<em>FreeMarkerViewResolver</em>的时候不需要我们指定其<em>viewClass</em>，因为<em>FreeMarkerViewResolver</em>中已经把<em>viewClass</em>定死为<em>FreeMarkerView</em>了。</p><p>我们先在<em>SpringMVC</em>的配置文件里面定义一个<em>FreeMarkerViewResolver</em>视图解析器，并定义其解析视图的<em>order</em>顺序为<em>1</em>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMakerViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fm_&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.ftl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么当我们请求的处理器方法返回一个逻辑视图名称<em>viewName</em>的时候，就会被该视图处理器加上前后缀解析为一个<em>url</em>为“<em>fm_viewName.ftl</em>”的<em>FreeMarkerView</em>对象。对于<em>FreeMarkerView</em>我们需要给定一个<em>FreeMarkerConfig</em>的<em>bean</em>对象来定义<em>FreeMarker</em>的配置信息。<em>FreeMarkerConfig</em>是一个接口，<em>Spring</em>已经为我们提供了一个实现，它就是<em>FreeMarkerConfigurer</em>。我们可以通过在<em>SpringMVC</em>的配置文件里面定义该<em>bean</em>对象来定义<em>FreeMarker</em>的配置信息，该配置信息将会在<em>FreeMarkerView</em>进行渲染的时候使用到。对于<em>FreeMarkerConfigurer</em>而言，我们最简单的配置就是配置一个<em>templateLoaderPath</em>，告诉<em>Spring</em>应该到哪里寻找<em>FreeMarker</em>的模板文件。这个<em>templateLoaderPath</em>也支持使用“<em>classpath:<em>”和“</em>file:<em>”前缀。当</em>FreeMarker</em>的模板文件放在多个不同的路径下面的时候，我们可以使用<em>templateLoaderPaths</em>属性来指定多个路径。在这里我们指定模板文件是放在“*&#x2F;WEB-INF&#x2F;freemarker&#x2F;template*”下面的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMakerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateLoaderPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/freemarker/template&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们定义如下一个<em>Controller</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mytest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;freemarker&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">freemarker</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mav.addObject(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;gcc&quot;</span>);</span><br><span class="line">        mav.setViewName(<span class="string">&quot;freemarker&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的定义我们可以看到这个<em>Controller</em>的处理器方法<em>freemarker</em>返回的逻辑视图名称是“<em>freemarker</em>”。那么如果我们需要把该<em>freemarker</em>视图交给<em>FreeMarkerViewResolver</em>来解析的话，我们就需要根据上面的定义，在模板路径下定义视图对应的模板，即在“*&#x2F;WEB-INF&#x2F;freemarker&#x2F;template<em>”目录下建立</em>fm_freemarker.ftl*模板文件。这里我们定义其内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FreeMarker<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        $&#123;hello&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过上面的定义当我们访问*&#x2F;mytest&#x2F;freemarker<em>的时候就会返回一个逻辑视图名称为“</em>freemarker<em>”的</em>ModelAndView<em>对象，根据定义好的视图解析的顺序，首先进行视图解析的是</em>FreeMarkerViewResolver<em>，这个时候</em>FreeMarkerViewResolver<em>会试着解析该视图，根据它自身的定义，它会先解析到该视图的</em>URL<em>为</em>fm_freemarker.ftl<em>，然后它会看是否能够实例化该视图对象，即在定义好的模板路径下是否有该模板存在，如果有则返回该模板对应的</em>FreeMarkerView<em>。在这里的话</em>&#x2F;WEB-INF&#x2F;freemarker&#x2F;template<em>目录下是存在模板文件</em>fm_freemarker.ftl<em>的，所以会返回一个</em>url<em>为</em>fm_freemarker.ftl<em>的</em>FreeMarkerView<em>对象。接着</em>FreeMarkerView*就可以利用该模板文件进行视图的渲染了。所以访问结果应该如下所示：</p><p>Hello World! gcc</p><h2 id="视图解析器链"><a href="#视图解析器链" class="headerlink" title="视图解析器链"></a>视图解析器链</h2><p>在<em>SpringMVC</em>中可以同时定义多个<em>ViewResolver</em>视图解析器，然后它们会组成一个<em>ViewResolver</em>链。当<em>Controller</em>处理器方法返回一个逻辑视图名称后，<em>ViewResolver</em>链将根据其中<em>ViewResolver</em>的优先级来进行处理。所有的<em>ViewResolver</em>都实现了<em>Ordered</em>接口，在<em>Spring</em>中实现了这个接口的类都是可以排序的。在<em>ViewResolver</em>中是通过<em>order</em>属性来指定顺序的，默认都是最大值。所以我们可以通过指定<em>ViewResolver</em>的<em>order</em>属性来实现<em>ViewResolver</em>的优先级，<em>order</em>属性是<em>Integer</em>类型，<em>order</em>越小，对应的<em>ViewResolver</em>将有越高的解析视图的权利，所以第一个进行解析的将是<em>ViewResolver</em>链中<em>order</em>值最小的那个。当一个<em>ViewResolver</em>在进行视图解析后返回的<em>View</em>对象是<em>null</em>的话就表示该<em>ViewResolver</em>不能解析该视图，这个时候如果还存在其他<em>order</em>值比它大的<em>ViewResolver</em>就会调用剩余的<em>ViewResolver</em>中的<em>order</em>值最小的那个来解析该视图，依此类推。当<em>ViewResolver</em>在进行视图解析后返回的是一个非空的<em>View</em>对象的时候，就表示该<em>ViewResolver</em>能够解析该视图，那么视图解析这一步就完成了，后续的<em>ViewResolver</em>将不会再用来解析该视图。当定义的所有<em>ViewResolver</em>都不能解析该视图的时候，<em>Spring</em>就会抛出一个异常。</p><p> 基于<em>Spring</em>支持的这种<em>ViewResolver</em>链模式，我们就可以在<em>SpringMVC</em>应用中同时定义多个<em>ViewResolver</em>，给定不同的<em>order</em>值，这样我们就可以对特定的视图特定处理，以此来支持同一应用中有多种视图类型。注意：像<em>InternalResourceViewResolver</em>这种能解析所有的视图，即永远能返回一个非空<em>View</em>对象的<em>ViewResolver</em>一定要把它放在<em>ViewResolver</em>链的最后面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/howeres/article/details/124941519">https://blog.csdn.net/howeres/article/details/124941519</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为了更好地理解SpringMVC的工作流程，深入学习视图解析器是非常有必要的。希望这篇文章可以帮助大家更好地了解视图解析器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="视图解析器" scheme="https://gccforstudy.github.io/tags/%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-常用注解</title>
    <link href="https://gccforstudy.github.io/2022/08/26/SpringBoot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://gccforstudy.github.io/2022/08/26/SpringBoot-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-08-26T08:25:07.000Z</published>
    <updated>2022-09-04T02:55:45.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot常用注解"><a href="#SpringBoot常用注解" class="headerlink" title="SpringBoot常用注解"></a>SpringBoot常用注解</h1><blockquote><p>本文主要介绍一些SpringBoot中常用的注解。由于本人的水平有限，不能很详细地进行讲解，只能带大家进行简单的了解。</p></blockquote><span id="more"></span><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在main方法入口类处，用于启动sping boot应用项目</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><ul><li><p>@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义注册到IoC容器。</p></li><li><p>@EnableAutoConfiguration会根据类路径中的jar依赖,为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p></li></ul><p>@EnableAutoConfiguration作为一个复合Annotation，其自身定义关键信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的注解是@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。</p><p><img src="@EnableAutoConfiguration.jpg"></p><p>SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</p><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p>加载xml配置，一般放在启动main类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:/spring/*.xml&quot;)</span>  单个</span><br><span class="line"></span><br><span class="line"><span class="meta">@ImportResource(&#123;&quot;classpath:/spring/1.xml&quot;,&quot;classpath*:/spring/2.xml&quot;&#125;)</span>   多个</span><br></pre></td></tr></table></figure><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>application.properties定义属性，直接使用@Value注入即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="meta">@Value(&quot;$&#123;push.start:0&#125;&quot;)</span>    如果缺失，默认值为<span class="number">0</span></span><br><span class="line">     <span class="keyword">private</span> Long  id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>将配置文件中指定前缀的属性注入到类中对应的属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name ;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">gcc</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><h2 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h2><p>你可以直接在使用@ConfigurationProperties注解使用@Bean注解，将组件注册到IOC容器中，也可以使用@EnableConfigurationProperties将被@ConfigurationProperties注解的类注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(EnableConfigurationPropertiesRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigurationProperties &#123;</span><br><span class="line"><span class="comment">//写被@ConfigurationProperties注解的类</span></span><br><span class="line">Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>组合@Controller和@ResponseBody，@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>用来映射web请求(访问路径和参数)、处理类和方法，可以注解在类或方法上。注解在方法上的路径会继承注解在类上的路径。</p><p>produces属性: 定制返回的response的媒体类型和字符集，或需返回值是json对象</p><p>consumes属性：要求请求中的媒体类型必须为某种特定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Narrows the primary mapping by media types that can be consumed by the mapped handler.</span></span><br><span class="line">String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Narrows the primary mapping by media types that can be produced by the mapped handler.</span></span><br><span class="line">String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>获取request请求体中的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/匹配路径&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam(value=&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(value=&quot;password&quot;)</span> String password)</span>&#123;</span><br><span class="line">    <span class="comment">//获取请求体中的username和password</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>支持将返回值放在response体内，而不是返回一个页面。比如Ajax接口，可以用此注解返回数据而不是页面。此注解可以放置在返回值前或方法前。</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>@Bean(name&#x3D;”bean的名字”,initMethod&#x3D;”初始化时调用方法名字”,destroyMethod&#x3D;”close”)</p><p>定义在方法上，在容器内初始化一个bean实例类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;close&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Bean <span class="title function_">registryBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p>用于标注业务层组件</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>用于标注控制层组件</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p>用于标注数据访问组件，即DAO组件</p><h2 id="Componet"><a href="#Componet" class="headerlink" title="@Componet"></a>@Componet</h2><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>用来获得请求url中的动态参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;  </span><br><span class="line"></span><br><span class="line">     <span class="meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)</span>  </span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getLogin</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> String userId,  </span></span><br><span class="line"><span class="params">         <span class="meta">@PathVariable(&quot;roleId&quot;)</span> String roleId)</span>&#123;</span><br><span class="line">           </span><br><span class="line">         System.out.println(<span class="string">&quot;User Id : &quot;</span> + userId);  </span><br><span class="line">         System.out.println(<span class="string">&quot;Role Id : &quot;</span> + roleId);  </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">     </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>注解会告知Spring扫描指定的包来初始化Spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.gcc.springboot&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>在默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。</p><p>当不能确定 Spring 容器中一定拥有某个类的 Bean 时，可以在需要自动注入该类 Bean 的地方可以使用 @Autowired(required &#x3D; false)，这等于告诉 Spring: 在找不到匹配 Bean 时也不报错</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>将被注解的类设置为配置类，该类中可以使用@Bean注解向IOC容器中放入组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(&quot;name&quot;)</span><span class="comment">//表示这是一个配置信息类,可以给这个配置类也起一个名称</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;spring4&quot;)</span><span class="comment">//类似于xml中的&lt;context:component-scan base-package=&quot;spring&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动注入，如果容器中有多个符合的bean时，需要进一步明确</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;compent&quot;)</span><span class="comment">//进一步指明注入bean名称为compent的bean</span></span><br><span class="line">    <span class="keyword">private</span> Compent compent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//类似于xml中的&lt;bean id=&quot;newbean&quot; class=&quot;spring.Compent&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> Compent <span class="title function_">newbean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Compent</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>@Import({xxx.class, xxxx.class})给容器中<strong>自动创建出这两个类型的组件</strong>、默认组件的名字就是全类名</p><h2 id="Order"><a href="#Order" class="headerlink" title="@Order"></a>@Order</h2><p>@Order注解主要用来控制配置类的加载顺序，值越小，优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Order &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int LOWEST_PRECEDENCE = Integer.MAX_VALUE;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression(&quot;$&#123;enabled:false&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigpipeConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OrderMessageMonitor <span class="title function_">orderMessageMonitor</span><span class="params">(ConfigContext configContext)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderMessageMonitor</span>(configContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解的value属性是SpEL（Spring表达式），如果为true才会加载组件，为false则不会加载组件。对SpEL表达式感兴趣的小伙伴可以自行查阅资料。</p><h2 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h2><p>SpringBoot中有个注解@ConditionalOnProperty，这个注解能够控制某个configuration是否生效。具体操作是通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值，如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。</p><p>该注解中的value属性(等同于name属性)用来设置是否包含applicaiton.properties中的某个属性，prefix属性用来设置属性的前缀（例如acme.system.feature)，havingValue属性只有三个值，分别为true、false、foo，关于这个注解的详细解释大家可以自行查看源码。</p><h2 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h2><p>该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类</p><h2 id="ConditionalOnMisssingClass"><a href="#ConditionalOnMisssingClass" class="headerlink" title="@ConditionalOnMisssingClass"></a>@ConditionalOnMisssingClass</h2><p>如果存在它修饰的类的bean，则不需要再创建这个bean</p><h2 id="ConditionOnMissingBean"><a href="#ConditionOnMissingBean" class="headerlink" title="@ConditionOnMissingBean"></a>@ConditionOnMissingBean</h2><p>可以指定当IOC容器中没有何种类型或名字的组件时，@configuration或@Bean注解才会生效（即往IOC容器中放入对应的组件）</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot常用注解&quot;&gt;&lt;a href=&quot;#SpringBoot常用注解&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot常用注解&quot;&gt;&lt;/a&gt;SpringBoot常用注解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要介绍一些SpringBoot中常用的注解。由于本人的水平有限，不能很详细地进行讲解，只能带大家进行简单的了解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://gccforstudy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-devtools</title>
    <link href="https://gccforstudy.github.io/2022/08/21/SpringBoot-devtools/"/>
    <id>https://gccforstudy.github.io/2022/08/21/SpringBoot-devtools/</id>
    <published>2022-08-21T02:24:38.000Z</published>
    <updated>2022-09-04T02:54:57.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热部署工具devtools"><a href="#热部署工具devtools" class="headerlink" title="热部署工具devtools"></a>热部署工具devtools</h1><blockquote><p>SpringBoot开发调试中，如果我每行代码的修改都需要重启启动再调试，可能比较费时间；SpringBoot团队针对此问题提供了spring-boot-devtools（简称devtools）插件，它试图提升开发调试的效率。</p></blockquote><p>在讲解devtools开始之前，我们先来介绍一些前置知识。</p><span id="more"></span><h2 id="什么是热部署和热加载？"><a href="#什么是热部署和热加载？" class="headerlink" title="什么是热部署和热加载？"></a>什么是热部署和热加载？</h2><blockquote><p>热部署和热加载是在应用正在运行的时候，自动更新（重新加载或者替换class等）应用的一种能力。（PS：spring-boot-devtools提供的方案也是要重启的，只是无需手动重启能实现自动加载而已。）</p></blockquote><ul><li><p>热部署</p><ul><li>在服务器运行时重新部署项目</li><li>它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。</li></ul></li><li><p>热加载</p><ul><li><p>在运行时重新加载class，从而升级应用。</p></li><li><p>热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。</p></li><li><p>对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。</p></li></ul></li></ul><h2 id="什么是LiveLoad？"><a href="#什么是LiveLoad？" class="headerlink" title="什么是LiveLoad？"></a>什么是LiveLoad？</h2><p>LiveLoad是提供浏览器客户端自动加载更新的工具，分为LiveLoad服务器和Liveload浏览器插件两部分； devtools中已经集成了LiveLoad服务器，所以如果我们开发的是web应用，并且期望浏览器自动刷新， 这时候可以考虑LiveLoad。</p><p>同一时间只能运行一个LiveReload服务器。 开始应用程序之前，请确保没有其他LiveReload服务器正在运行。如果从IDE启动多个应用程序，则只有第一个应用程序将支持LiveReload。</p><h2 id="配置devtools实现热部署"><a href="#配置devtools实现热部署" class="headerlink" title="配置devtools实现热部署"></a>配置devtools实现热部署</h2><blockquote><p>我们通过如下配置来实现自动重启方式的热部署</p></blockquote><h3 id="POM配置"><a href="#POM配置" class="headerlink" title="POM配置"></a>POM配置</h3><p>添加spring-boot-devtools的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 可以防止将devtools依赖传递到其他模块中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h3><blockquote><p>如果你使用IDEA开发工具，通常有如下两种方式：</p></blockquote><ul><li>方式一：无需任何配置，手动触发重启更新（Ctrl + F9）</li></ul><p><img src="%E7%83%AD%E9%83%A8%E7%BD%B2.jpg"></p><ul><li>方式二：IDEA需开启运行时编译，自动重启更新</li></ul><p>File-&gt;Setting-&gt;Build,Execution,Deployment-&gt;Compile</p><p>勾选：Build project automatically</p><p><img src="%E7%83%AD%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E4%BA%8C.png"></p><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#设置开启热部署</span></span><br><span class="line">      <span class="attr">additional-paths:</span> <span class="string">src/main/java</span> <span class="comment">#重启目录</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">WEB-INF/**</span> <span class="comment">#静态资源更新，不要让服务器重启</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment">#使用Thymeleaf模板引擎，关闭缓存</span></span><br></pre></td></tr></table></figure><h2 id="使用LiveLoad"><a href="#使用LiveLoad" class="headerlink" title="使用LiveLoad"></a>使用LiveLoad</h2><p>spring-boot-devtools模块包含<strong>嵌入式LiveReload服务器</strong>，可以在资源更改时用于触发浏览器刷新。 LiveReload浏览器扩展程序支持Chrome，Firefox和Safari，你可以从livereload.com免费下载，或者从浏览器插件中心下载。</p><p><img src="LiveReload.jpg"></p><p>如果你不想在应用程序运行时启动LiveReload服务器，则可以将spring.devtools.livereload.enabled属性设置为false 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">devtools:</span></span><br><span class="line">   <span class="attr">livereload:</span></span><br><span class="line">     <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h2><blockquote><p>虽然一些开发者会使用devtool工具，但是很少有能够深入理解的；让我们理解如下几个问题，帮助你进一步理解。</p></blockquote><h3 id="devtool的原理？为何会自动重启？"><a href="#devtool的原理？为何会自动重启？" class="headerlink" title="devtool的原理？为何会自动重启？"></a>devtool的原理？为何会自动重启？</h3><blockquote><p>为什么同样是重启应用，为什么不手动重启，而是建议使用spring-boot-devtools进行热部署重启？</p></blockquote><p>spring-boot-devtools使用了两个类加载器ClassLoader，一个ClassLoader加载不会发生更改的类（第三方jar包），另一个ClassLoader（restart ClassLoader）加载会更改的类（自定义的类）。</p><p>后台启动一个<strong>文件监听线程（File Watcher）</strong>，<strong>监测的目录中的文件发生变动时， 原来的restart ClassLoader被丢弃，将会重新加载新的restart ClassLoader</strong>。</p><p>因为文件变动后，第三方jar包不再重新加载，只加载自定义的类，加载的类比较少，所以重启比较快。</p><p>这也是为什么，同样是重启应用，为什么不手动重启，建议使用spring-boot-devtools进行热部署重启。</p><p>在自动重启中有几点需要注意:</p><ul><li><strong>自动重启会记录日志</strong></li></ul><p>记录在什么情况下重启的日志</p><p>可以通过如下方式关闭：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">log-condition-evaluation-delta:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><strong>排除一些不需要自动重启的资源</strong></li></ul><p>某些资源在更改时不一定需要触发重新启动。默认情况下，改变资源&#x2F;META-INF&#x2F;maven，&#x2F;META-INF&#x2F;resources，&#x2F;resources，&#x2F;static，&#x2F;public，或&#x2F;templates不触发重新启动，但确会触发现场重装。如果要自定义这些排除项，可以使用该spring.devtools.restart.exclude属性。例如，要仅排除&#x2F;static，&#x2F;public你将设置以下属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">&quot;static/**,public/**&quot;</span> <span class="comment">#默认在类路径下搜索</span></span><br><span class="line">      <span class="attr">additional-exclude:</span> <span class="string">&quot;xxxx&quot;</span> <span class="comment">#写新增的项</span></span><br></pre></td></tr></table></figure><p>如果要保留这些默认值并添加其他排除项，请改用该spring.devtools.restart.additional-exclude属性。</p><ul><li><strong>自定义重启类加载器</strong></li></ul><p>重启功能是通过使用两个类加载器来实现的。对于大多数应用程序，这种方法效果很好。但是，它有时会导致类加载问题。</p><p>默认情况下，IDE 中的任何打开项目都使用“重启”类加载器加载，任何常规.jar文件都使用“基本”类加载器加载。如果你处理一个多模块项目，并且不是每个模块都导入到你的 IDE 中，你可能需要自定义一些东西。为此，你可以创建一个META-INF&#x2F;spring-devtools.properties文件。</p><p>该spring-devtools.properties文件可以包含以restart.exclude和为前缀的属性restart.include。该include元素是应该被拉高到“重启”的类加载器的项目，以及exclude要素是应该向下推入“Base”类加载器的项目。该属性的值是应用于类路径的正则表达式模式，如以下示例所示：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">exclude</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">companycommonlibs</span>: <span class="string">&quot;/mycorp-common-[\\w\\d-\\.]+\\.jar&quot;</span></span><br><span class="line">  <span class="attr">include</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">projectcommon</span>: <span class="string">&quot;/mycorp-myproj-[\\w\\d-\\.]+\\.jar&quot;</span></span><br></pre></td></tr></table></figure><h3 id="devtool是否会被打包进Jar？"><a href="#devtool是否会被打包进Jar？" class="headerlink" title="devtool是否会被打包进Jar？"></a>devtool是否会被打包进Jar？</h3><blockquote><p>devtool原则上来说应该是只在开发调试的时候使用，而在生产环境运行jar包时是不需要的，所以Spring打包不会把它打进JAR包。</p></blockquote><ul><li><strong>默认情况下，不会被打包进JAR</strong></li></ul><p>运行打包的应用程序时，开发人员工具<strong>会自动禁用</strong>。如果你通过 java -jar或者其他特殊的类加载器进行启动时，都会被认为是“生产环境的应用”。</p><h3 id="devtool为何会默认禁用缓存选项？"><a href="#devtool为何会默认禁用缓存选项？" class="headerlink" title="devtool为何会默认禁用缓存选项？"></a>devtool为何会默认禁用缓存选项？</h3><blockquote><p> Spring Boot 支持的一些库<strong>使用缓存来提高性能</strong>。例如，模板引擎缓存已编译的模板以避免重复解析模板文件。此外，Spring MVC 可以在提供静态资源时向响应添加 HTTP 缓存标头。</p></blockquote><p>虽然缓存<strong>在生产中非常有益，但在开发过程中可能会适得其反</strong>，使你无法看到刚刚在应用程序中所做的更改。出于这个原因， spring-boot-devtools 默认禁用缓存选项。</p><p>比如Thymeleaf 提供了spring.thymeleaf.cache来设置模板引擎的缓存，使用spring-boot-devtools模块时是不需要手动设置这些属性的，因为spring-boot-devtools会自动进行设置。</p><p>在devtools-property-defaults.properties中你可以看到默认配置，你可以去jar包找到，方式如下：</p><p><img src="%E7%BC%93%E5%AD%98%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.png"></p><p>默认配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.error.include-binding-errors</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">server.error.include-message</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">server.error.include-stacktrace</span>=<span class="string">always</span></span><br><span class="line"><span class="attr">server.servlet.jsp.init-parameters.development</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.servlet.session.persistent</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.freemarker.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.graphql.graphiql.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.groovy.template.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.h2.console.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mustache.servlet.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.mvc.log-resolved-exception</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.reactor.debug</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.template.provider.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.period</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.web.resources.chain.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>当然如果你不想被应用属性被spring-boot-devtools默认设置， 可以通过将spring.devtools.add-properties属性设置为false。</p><p>方式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该属性默认的值为true，也就是说如果你使用devtools，默认情况下使用上述properties文件中的缓存规则</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">  <span class="attr">add-properties:</span> <span class="literal">false</span> <span class="comment">#不使用devtools的默认配置</span></span><br></pre></td></tr></table></figure><h3 id="如果我不用devtool，还有什么选择？"><a href="#如果我不用devtool，还有什么选择？" class="headerlink" title="如果我不用devtool，还有什么选择？"></a>如果我不用devtool，还有什么选择？</h3><p>devtool本身基于重启方式，这种仍然不是真正的热替换方案，JRebel才是（它是收费的）</p><p>开发调试最重要的还是一种权衡</p><ul><li>自动重启的开销如果和手动重启没有什么太大差别，那么还不如手动重启（按需重启）</li><li>多数情况下，如果是<strong>方法内部的修改或者静态资源的修改</strong>，在IDEA中是可以通过Rebuild（Ctrl + Shift + F9）进行热更的</li></ul><p><img src="SpringBoot-devtools%5CRebuild.png"></p><ul><li>此外还有一个工具spring loaded， 可实现修改类文件的热部署，具体可看其<a href="https://github.com/spring-projects/spring-loaded">github地址</a>上的说明。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文记录了自己学习devtools的一些感悟，希望大家可以自己动手实践一下，毕竟编程需要多动手才能学好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools</a></p><p><a href="https://liayun.blog.csdn.net/article/details/116541775">https://liayun.blog.csdn.net/article/details/116541775</a></p><p><a href="https://pdai.tech/md/spring/springboot/springboot-x-hello-devtool.html">https://pdai.tech/md/spring/springboot/springboot-x-hello-devtool.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;热部署工具devtools&quot;&gt;&lt;a href=&quot;#热部署工具devtools&quot; class=&quot;headerlink&quot; title=&quot;热部署工具devtools&quot;&gt;&lt;/a&gt;热部署工具devtools&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;SpringBoot开发调试中，如果我每行代码的修改都需要重启启动再调试，可能比较费时间；SpringBoot团队针对此问题提供了spring-boot-devtools（简称devtools）插件，它试图提升开发调试的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在讲解devtools开始之前，我们先来介绍一些前置知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://gccforstudy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot简介</title>
    <link href="https://gccforstudy.github.io/2022/08/19/SpringBoot%E7%AE%80%E4%BB%8B/"/>
    <id>https://gccforstudy.github.io/2022/08/19/SpringBoot%E7%AE%80%E4%BB%8B/</id>
    <published>2022-08-19T08:35:00.000Z</published>
    <updated>2022-08-19T12:50:26.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><blockquote><p>尽管Spring的组件是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过<strong>开箱即用</strong>和<strong>约定大于配置</strong> 来解决配置重的问题的。</p></blockquote><span id="more"></span><h2 id="SpringFramework解决了什么问题，没有解决什么问题？"><a href="#SpringFramework解决了什么问题，没有解决什么问题？" class="headerlink" title="SpringFramework解决了什么问题，没有解决什么问题？"></a>SpringFramework解决了什么问题，没有解决什么问题？</h2><h3 id="SpringFramework解决了什么问题？"><a href="#SpringFramework解决了什么问题？" class="headerlink" title="SpringFramework解决了什么问题？"></a>SpringFramework解决了什么问题？</h3><ol><li>使用Spring的IOC容器,将对象之间的依赖关系交给Spring,降低组件之间的耦合性,让我们更专注于应用逻辑 。</li><li>可以提供众多服务,事务管理,WS等。 </li><li>对AOP有很好的支持,方便面向切面编程。 </li><li>对主流的框架提供了很好的集成支持,如Hibernate,Struts2,JPA等。 </li><li>Spring DI机制降低了业务对象替换的复杂性。 </li><li>Spring属于低侵入,代码污染极低。 </li><li>Spring的高度可开放性,并不强制依赖于Spring,开发者可以自由选择Spring部分或全部。</li></ol><h3 id="SpringFramework没有解决了什么问题？"><a href="#SpringFramework没有解决了什么问题？" class="headerlink" title="SpringFramework没有解决了什么问题？"></a>SpringFramework没有解决了什么问题？</h3><p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p><p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p><p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p><h2 id="SpringBoot的概述"><a href="#SpringBoot的概述" class="headerlink" title="SpringBoot的概述"></a>SpringBoot的概述</h2><h3 id="SpringBoot解决上述Spring的缺点"><a href="#SpringBoot解决上述Spring的缺点" class="headerlink" title="SpringBoot解决上述Spring的缺点"></a>SpringBoot解决上述Spring的缺点</h3><p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p><h3 id="SpringBoot的特点"><a href="#SpringBoot的特点" class="headerlink" title="SpringBoot的特点"></a>SpringBoot的特点</h3><ol><li>为基于Spring的开发提供更快的入门体验</li><li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li></ol><p>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</p><h3 id="SpringBoot的核心功能"><a href="#SpringBoot的核心功能" class="headerlink" title="SpringBoot的核心功能"></a>SpringBoot的核心功能</h3><ul><li><strong>起步依赖</strong> 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</li></ul><p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p><ul><li><strong>自动配置</strong></li></ul><p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><p><a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin">https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin</a></p><p><a href="https://www.jianshu.com/p/24add3c5fedb">https://www.jianshu.com/p/24add3c5fedb</a></p><p><a href="https://www.cnblogs.com/luzhanshi/p/10592209.html">https://www.cnblogs.com/luzhanshi/p/10592209.html</a></p><p><a href="https://pdai.tech/md/spring/springboot/springboot.html">https://pdai.tech/md/spring/springboot/springboot.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot简介&quot;&gt;&lt;a href=&quot;#SpringBoot简介&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot简介&quot;&gt;&lt;/a&gt;SpringBoot简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;尽管Spring的组件是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过&lt;strong&gt;开箱即用&lt;/strong&gt;和&lt;strong&gt;约定大于配置&lt;/strong&gt; 来解决配置重的问题的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="https://gccforstudy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Logger</title>
    <link href="https://gccforstudy.github.io/2022/08/19/Logger/"/>
    <id>https://gccforstudy.github.io/2022/08/19/Logger/</id>
    <published>2022-08-19T02:29:36.000Z</published>
    <updated>2022-08-21T00:25:58.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准Java日志框架"><a href="#标准Java日志框架" class="headerlink" title="标准Java日志框架"></a>标准Java日志框架</h2><p>每个Java程序员都很熟悉在有问题的代码中插入一些System.out.println方法调用来帮助自己观察程序的行为。当然，一旦发现问题的根源，就要将这些print语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用System.out.println方法的语句。日志API就是为了解决这个问题而设计的。</p><span id="more"></span><p>本文只介绍标准Java日志框架，因为学习这个框架的API可以让我们准备好去理解其他框架。（比如Log4J2、Logback其他日志框架，SLF4J和Commons Logging日志门面）</p><h3 id="基本日志"><a href="#基本日志" class="headerlink" title="基本日志"></a>基本日志</h3><p>要想生成简单的日志记录，可以使用全局日志记录器（global logger）并调用info方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">&quot;gccwd&quot;</span>);</span><br></pre></td></tr></table></figure><p>在默认情况下，会在控制台打印如下记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">八月 <span class="number">19</span>, <span class="number">2022</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">10</span> 上午 com.gcc.mvc.bean.FortTest main</span><br><span class="line">信息: gccwd</span><br></pre></td></tr></table></figure><p>但是，如果在info方法之前调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().setLevel(Level.OFF);</span><br></pre></td></tr></table></figure><p>将会取消所有日志。</p><h3 id="高级日志"><a href="#高级日志" class="headerlink" title="高级日志"></a>高级日志</h3><p>在一个专业的应用程序中，你肯定不想将所有的日志都记录到一个全局日志记录器中。你可以定义自己的日志记录器。</p><p>可以调用getLogger方法来获取日志记录器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">myLogger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>提示：为了防止日志记录器被垃圾回收，需要用静态变量存储日志记录器的引用。</p></blockquote><p>与包名类似，日志记录器名也具有层次结构。对于包来说，子包与父包之间没有语义关系，但是日志记录器的父与子之间将共享某些属性。例如，如果对日志记录器”com.mycompany”设置了日志级别，它的子日志记录器也会继承这个级别。</p><p>通常，有以下7个日志级别（级别从高到低）：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>在默认情况下，只记录前三个级别。也可以设置不同的级别，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logger是日志记录器</span></span><br><span class="line">logger.setLevel(Level.FINE);</span><br></pre></td></tr></table></figure><p>现在，FINE及所有更高级别的日志都会被记录。</p><p>另外，还可以使用Level.ALL来开启所以级别的日志记录，或者使用Level.OFF关闭所有级别的日志记录。</p><p>所有级别都有日志记录方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logger.warning(message);</span><br><span class="line">logger.fine(message);</span><br><span class="line"><span class="comment">//或者，还可以使用log方法并指定级别</span></span><br><span class="line">logger.log(Level.FINE, message);</span><br></pre></td></tr></table></figure><p>默认的日志纪律将显示根据调用堆栈得出的包含日志调用的类名和方法名。不过，如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以使用logp方法获得调用类和方法的确切位置，这个方法的签名为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">logp</span><span class="params">(Level level, String sourceClass, String sourceMethod, String msg)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//另外，有一些用来跟踪执行流的便利方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Log a method entry, with an array of parameters.</span></span><br><span class="line"><span class="comment">This is a convenience method that can be used to log entry to a method. A LogRecord with message &quot;ENTRY&quot; (followed by a format &#123;N&#125; indicator for each entry in the parameter array), log level FINER, and the given sourceMethod, sourceClass, and parameters is logged.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">entering</span><span class="params">(String sourceClass, String sourceMethod, Object params[])</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Log a method return, with result object.</span></span><br><span class="line"><span class="comment">This is a convenience method that can be used to log returning from a method. A LogRecord with message &quot;RETURN &#123;0&#125;&quot;, log level FINER, and the gives sourceMethod, sourceClass, and result object is logged.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exiting</span><span class="params">(String sourceClass, String sourceMethod, Object result)</span></span><br></pre></td></tr></table></figure><p>这些调用将生成FINER级别而且以字符串ENTRY和RETURN开头的日志记录。（用来记录方法的开始和方法的结尾）</p><p>记录日志的常见用途是记录那些预料之外的异常。可以使用下面两个便利方法在日志记录包含异常的描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Log throwing an exception.</span></span><br><span class="line"><span class="comment">This is a convenience method to log that a method is terminating by throwing an exception. The logging is done using the FINER level.</span></span><br><span class="line"><span class="comment">If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord&#x27;s message is set to &quot;THROW&quot;.</span></span><br><span class="line"><span class="comment">Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">throwing</span><span class="params">(String sourceClass, String sourceMethod, Throwable thrown)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Log a message, with associated Throwable information.</span></span><br><span class="line"><span class="comment">If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</span></span><br><span class="line"><span class="comment">Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String msg, Throwable thrown)</span></span><br></pre></td></tr></table></figure><p>throwing调用可以记录一条FINER级别的日志记录和一条以THROW开始的消息。</p><h3 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h3><p>可以通过编辑配置文件来修改日志系统的各个属性。在默认情况下，配置文件位于：</p><p>jdk&#x2F;conf&#x2F;logging.properties(在Java9之前，位于jdk&#x2F;jre&#x2F;lib&#x2F;logging.properties)</p><p>要想修改默认的日志级别，就需要编辑配置文件，并修改以下命令行</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default global logging level.</span></span><br><span class="line"><span class="comment"># This specifies which kinds of events are logged across</span></span><br><span class="line"><span class="comment"># all loggers.  For any given facility this global level</span></span><br><span class="line"><span class="comment"># can be overriden by a facility specific level</span></span><br><span class="line"><span class="comment"># Note that the ConsoleHandler also has a separate level</span></span><br><span class="line"><span class="comment"># setting to limit messages printed to the console.</span></span><br><span class="line"><span class="attr">.level</span> = <span class="string">INFO</span></span><br></pre></td></tr></table></figure><p>可以通过添加下面这一行来指定自定义日志记录器的日志级别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.mycompany.myapp.level</span> = <span class="string">FINE</span></span><br></pre></td></tr></table></figure><p>稍后可以看到，日志记录器并不将消息发送到控制台，那是处理器的任务。处理器也有运行级别，要想在控制台上看到FINE级别的消息，就需要进行以下设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java.util.logging.ConsoleHandler.level</span> = <span class="string">FINE</span></span><br></pre></td></tr></table></figure><blockquote><p>注释：日志属性文件由java.util.logging.LogManager类处理。有关LogManager类的更多信息请参看API文档。</p></blockquote><blockquote><p>​补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个接口在看Java核心技术卷1日志部分的时候可以需要用到，大家可以看看</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>在默认情况下，日志记录器将记录发送到ConsoleHandler，并由它输出到System.err流。</p><p>与日志记录器一样，处理器也有日志级别。对于一个要记录的日志记录，它的日志级别必须高于日志记录器和处理器二者的阈值。日志管理器配置文件将默认的控制台处理器的日志级别设置为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Limit the message that are printed on the console to INFO and above.</span></span><br><span class="line"><span class="attr">java.util.logging.ConsoleHandler.level</span> = <span class="string">INFO</span></span><br></pre></td></tr></table></figure><p>要想记录FINE级别的日志，就必须修改配置文件中的默认日志记录器级别和处理级别。另外，还可以绕过配置文件，安装你自己的处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br><span class="line">logger.setLevel(Level.FINE);</span><br><span class="line">logger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line"><span class="type">ConsoleHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line">handler.setLevel(Level.FINE);</span><br><span class="line">logger.addHandler(handler);</span><br></pre></td></tr></table></figure><p>这里为什么关闭父日志处理器呢？因为所有的控制台处理器都会将日志发送到祖日志处理器中，再由祖日志处理器将日志发送到控制台进行显示。如果不关闭父日志处理器，就会发送两次相同的日志。</p><p>如果想把日志记录到其他地方，就要添加其他类型的处理器。日志API提供了两个很有用的处理器，一个是FileHandler；另一个是SocketHandler。SocketHandler将记录发送到指定的主机和端口。更令人感兴趣的是FileHandler，它可以将日志记录收集到文件中。</p><p>可以通过如下方式将记录发送到默认文件处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line">logger.addHandler(handler);</span><br></pre></td></tr></table></figure><p>这些记录被发送到用户主目录的javan.log文件中，n是保证文件唯一的一个编号。默认情况下，记录会格式化为XML。一个典型的日志记录形式如下：</p><p><img src="xml%E6%A0%BC%E5%BC%8F%E6%97%A5%E5%BF%97.png"></p><p>可以通过设置日志管理器配置文件中的不同参数，如下表：</p><p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png"></p><p>也有可能不想使用默认的日志文件名，因此，应该使用另一种模式，例如%h&#x2F;myapp.log。模式变量如下：</p><p><img src="%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F.png"></p><p>循环日志的意思是当超过限制后，最老的文件就会被删除，用新生成的文件代替，以此类推。</p><p>当然，你也可以定义自己的处理器，你可以通过扩展Handler类或StreamHandler类的方式来实现，感兴趣的小伙伴可以自行学习。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>在默认情况下，会根据日志记录的级别进行过滤。每个日志记录器和处理器都有一个可选的过滤器来完成附加的过滤。要定义一个过滤器，需要实现Filter接口并定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Filter can be used to provide fine grain control over</span></span><br><span class="line"><span class="comment"> * what is logged, beyond the control provided by log levels.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Each Logger and each Handler can have a filter associated with it.</span></span><br><span class="line"><span class="comment"> * The Logger or Handler will call the isLoggable method to check</span></span><br><span class="line"><span class="comment"> * if a given LogRecord should be published.  If isLoggable returns</span></span><br><span class="line"><span class="comment"> * false, the LogRecord will be discarded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check if a given log record should be published.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record  a LogRecord</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the log record should be published.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(LogRecord record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以了。注意，同一时刻最多只能有一个过滤器。</p><h3 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h3><p>格式化器大家了解一下即可</p><p><img src="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.logging;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Formatter provides support for formatting LogRecords.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Typically each logging Handler will have a Formatter associated</span></span><br><span class="line"><span class="comment"> * with it.  The Formatter takes a LogRecord and converts it to</span></span><br><span class="line"><span class="comment"> * a string.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Some formatters (such as the XMLFormatter) need to wrap head</span></span><br><span class="line"><span class="comment"> * and tail strings around a set of formatted records. The getHeader</span></span><br><span class="line"><span class="comment"> * and getTail methods can be used to obtain these strings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new formatter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Formatter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Format the given log record and return the formatted string.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The resulting formatted String will normally include a</span></span><br><span class="line"><span class="comment">     * localized and formatted version of the LogRecord&#x27;s message field.</span></span><br><span class="line"><span class="comment">     * It is recommended to use the &#123;<span class="doctag">@link</span> Formatter#formatMessage&#125;</span></span><br><span class="line"><span class="comment">     * convenience method to localize and format the message field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record the log record to be formatted.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the formatted log record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">format</span><span class="params">(LogRecord record)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the header string for a set of formatted records.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This base class returns an empty string, but this may be</span></span><br><span class="line"><span class="comment">     * overridden by subclasses.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   h  The target handler (can be null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  header string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHead</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the tail string for a set of formatted records.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This base class returns an empty string, but this may be</span></span><br><span class="line"><span class="comment">     * overridden by subclasses.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   h  The target handler (can be null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  tail string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTail</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Localize and format the message string from a log record.  This</span></span><br><span class="line"><span class="comment">     * method is provided as a convenience for Formatter subclasses to</span></span><br><span class="line"><span class="comment">     * use when they are performing formatting.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The message string is first localized to a format string using</span></span><br><span class="line"><span class="comment">     * the record&#x27;s ResourceBundle.  (If there is no ResourceBundle,</span></span><br><span class="line"><span class="comment">     * or if the message key is not found, then the key is used as the</span></span><br><span class="line"><span class="comment">     * format string.)  The format String uses java.text style</span></span><br><span class="line"><span class="comment">     * formatting.</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If there are no parameters, no formatter is used.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Otherwise, if the string contains &quot;&#123;0&quot; then</span></span><br><span class="line"><span class="comment">     *     java.text.MessageFormat  is used to format the string.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Otherwise no formatting is performed.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  record  the log record containing the raw message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>   a localized and formatted message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">formatMessage</span><span class="params">(LogRecord record)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> record.getMessage();</span><br><span class="line">        java.util.<span class="type">ResourceBundle</span> <span class="variable">catalog</span> <span class="operator">=</span> record.getResourceBundle();</span><br><span class="line">        <span class="keyword">if</span> (catalog != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                format = catalog.getString(record.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.util.MissingResourceException ex) &#123;</span><br><span class="line">                <span class="comment">// Drop through.  Use record message as format</span></span><br><span class="line">                format = record.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do the formatting.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object parameters[] = record.getParameters();</span><br><span class="line">            <span class="keyword">if</span> (parameters == <span class="literal">null</span> || parameters.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No parameters.  Just return format string.</span></span><br><span class="line">                <span class="keyword">return</span> format;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Is it a java.text style format?</span></span><br><span class="line">            <span class="comment">// Ideally we could match with</span></span><br><span class="line">            <span class="comment">// Pattern.compile(&quot;\\&#123;\\d&quot;).matcher(format).find())</span></span><br><span class="line">            <span class="comment">// However the cost is 14% higher, so we cheaply check for</span></span><br><span class="line">            <span class="comment">// 1 of the first 4 parameters</span></span><br><span class="line">            <span class="keyword">if</span> (format.indexOf(<span class="string">&quot;&#123;0&quot;</span>) &gt;= <span class="number">0</span> || format.indexOf(<span class="string">&quot;&#123;1&quot;</span>) &gt;=<span class="number">0</span> ||</span><br><span class="line">                        format.indexOf(<span class="string">&quot;&#123;2&quot;</span>) &gt;=<span class="number">0</span>|| format.indexOf(<span class="string">&quot;&#123;3&quot;</span>) &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> java.text.MessageFormat.format(format, parameters);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Formatting failed: use localized format string.</span></span><br><span class="line">            <span class="keyword">return</span> format;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志技巧"><a href="#日志技巧" class="headerlink" title="日志技巧"></a>日志技巧</h3><p>面对日志记录如此多的选项，很容易让人忘记最基本的东西。下面的技巧总结了一些最常用的操作。</p><p>1、对一个简单的应用，选择一个日志记录器。可以把日志记录器命名为与主应用包一样的名字，例如，com.mycompany.myprog，这是一个好主意。总是可以通过调用以下方法得到日志记录器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany,myprog&quot;</span>);</span><br><span class="line"><span class="comment">//为了方便起见，你可能希望为有大量日志记录活动的类增加静态字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany,myprog&quot;</span>);</span><br></pre></td></tr></table></figure><p>2 、默认的日志配置会把级别等于或高于INFO的所有消息记录到控制台。用户可以覆盖这个默认配置。如是正如前面所述，改变配置的过程有些复杂，最好在你的应用中安装一个更合适的默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码确保将所有的消息记录到应用特定的一个文件中，可以将这段代码放置在应用程序的main方法中</span></span><br><span class="line"> <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;java.util.logging.config.class&quot;</span>) == <span class="literal">null</span> &amp;&amp; System.getProperty(<span class="string">&quot;java.util.logging.config.file&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Logger.getLogger(<span class="string">&quot;&quot;</span>).setLevel(Level.ALL);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOG_ROTATION_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">                <span class="type">FileHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>(<span class="string">&quot;%h&quot;</span>, <span class="number">0</span>, LOG_ROTATION_COUNT);</span><br><span class="line">                Logger.getLogger(<span class="string">&quot;&quot;</span>).addHandler(handler);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                myLogger.log(Level.SEVERE, <span class="string">&quot;Can&#x27;t create log file handler&quot;</span>,e);<span class="comment">//private static final Logger myLogger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>3、现在，可以记录自己想要的内容了。但需要牢记：所有级别为INFO、WARNING和SEVERE的消息都将显示到控制台上。因此，最好只将对程序用户有意的消息设置为这几个级别。将程序员想要的日志消息设定为FINE级别是一个很好的选择。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文参考了Java核心技术卷1的日志部分，如果想要详细了解，小伙伴们应该去阅读原书。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;标准Java日志框架&quot;&gt;&lt;a href=&quot;#标准Java日志框架&quot; class=&quot;headerlink&quot; title=&quot;标准Java日志框架&quot;&gt;&lt;/a&gt;标准Java日志框架&lt;/h2&gt;&lt;p&gt;每个Java程序员都很熟悉在有问题的代码中插入一些System.out.println方法调用来帮助自己观察程序的行为。当然，一旦发现问题的根源，就要将这些print语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用System.out.println方法的语句。日志API就是为了解决这个问题而设计的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日志" scheme="https://gccforstudy.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Filter</title>
    <link href="https://gccforstudy.github.io/2022/08/18/Filter/"/>
    <id>https://gccforstudy.github.io/2022/08/18/Filter/</id>
    <published>2022-08-18T11:41:07.000Z</published>
    <updated>2022-08-21T00:26:18.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter(过滤器)是JavaWeb三大组件之一，为了后续可以更好地掌握SpringMVC框架，仔细学习一下过滤器的基础知识是很有必要的。</p><span id="more"></span> <h3 id="过滤器的三要素"><a href="#过滤器的三要素" class="headerlink" title="过滤器的三要素"></a>过滤器的三要素</h3><p>1、拦截</p><p>​过滤器之所以能够对请求进行预处理，关键是对请求进行拦截，把请求拦截下来才能够做后续的操作。而且对于一个具体的过滤器，它必须明确它要拦截的请求，而不是所有请求都拦截。</p><p>2、过滤</p><p>​根据业务功能实际的需求，看看在把请求拦截到之后，需要做什么检查或什么操作，写对应的代码即可。</p><p>3、放行</p><p>​过滤器完成自己的任务或者是检测到当前请求符合过滤规则，那么可以将请求放行。所谓放行，就是让请求继续去访问它原本要访问的资源。</p><h3 id="过滤器工作流程及实验"><a href="#过滤器工作流程及实验" class="headerlink" title="过滤器工作流程及实验"></a>过滤器工作流程及实验</h3><h4 id="过滤器工作流程图"><a href="#过滤器工作流程图" class="headerlink" title="过滤器工作流程图"></a>过滤器工作流程图</h4><p><img src="%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg"></p><h4 id="Filter接口源码"><a href="#Filter接口源码" class="headerlink" title="Filter接口源码"></a>Filter接口源码</h4><p>为了实现上述的工作流程，需要创建Filter接口的实现类，为了更好地理解Filter，我们来简单地看一下该接口的源码，Filter接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A filter is an object that performs filtering tasks on either the</span></span><br><span class="line"><span class="comment"> * request to a resource (a servlet or static content), or on the response</span></span><br><span class="line"><span class="comment"> * from a resource, or both.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Filters perform filtering in the &lt;code&gt;doFilter&lt;/code&gt; method.</span></span><br><span class="line"><span class="comment"> * Every Filter has access to a FilterConfig object from which it can obtain</span></span><br><span class="line"><span class="comment"> * its initialization parameters, and a reference to the ServletContext which</span></span><br><span class="line"><span class="comment"> * it can use, for example, to load resources needed for filtering tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Filters are configured in the deployment descriptor of a web</span></span><br><span class="line"><span class="comment"> * application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Examples that have been identified for this design are:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Authentication Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Logging and Auditing Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Image conversion Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Data compression Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Encryption Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Tokenizing Filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Filters that trigger resource access events</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;XSL/T filters</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Mime-type chain Filter</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Servlet 2.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Called by the web container to indicate to a filter that it is</span></span><br><span class="line"><span class="comment">     * being placed into service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The servlet container calls the init</span></span><br><span class="line"><span class="comment">     * method exactly once after instantiating the filter. The init</span></span><br><span class="line"><span class="comment">     * method must complete successfully before the filter is asked to do any</span></span><br><span class="line"><span class="comment">     * filtering work.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The web container cannot place the filter into service if the init</span></span><br><span class="line"><span class="comment">     * method either</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Throws a ServletException</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Does not return within a time period defined by the web container</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &lt;code&gt;doFilter&lt;/code&gt; method of the Filter is called by the</span></span><br><span class="line"><span class="comment">     * container each time a request/response pair is passed through the</span></span><br><span class="line"><span class="comment">     * chain due to a client request for a resource at the end of the chain.</span></span><br><span class="line"><span class="comment">     * The FilterChain passed in to this method allows the Filter to pass</span></span><br><span class="line"><span class="comment">     * on the request and response to the next entity in the chain.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A typical implementation of this method would follow the following</span></span><br><span class="line"><span class="comment">     * pattern:</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Examine the request</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Optionally wrap the request object with a custom implementation to</span></span><br><span class="line"><span class="comment">     * filter content or headers for input filtering</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Optionally wrap the response object with a custom implementation to</span></span><br><span class="line"><span class="comment">     * filter content or headers for output filtering</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&lt;strong&gt;Either&lt;/strong&gt; invoke the next entity in the chain</span></span><br><span class="line"><span class="comment">     * using the FilterChain object</span></span><br><span class="line"><span class="comment">     * (&lt;code&gt;chain.doFilter()&lt;/code&gt;),</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;&lt;strong&gt;or&lt;/strong&gt; not pass on the request/response pair to</span></span><br><span class="line"><span class="comment">     * the next entity in the filter chain to</span></span><br><span class="line"><span class="comment">     * block the request processing</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Directly set headers on the response after invocation of the</span></span><br><span class="line"><span class="comment">     * next entity in the filter chain.</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                         FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the web container to indicate to a filter that it is being</span></span><br><span class="line"><span class="comment">     * taken out of service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is only called once all threads within the filter&#x27;s</span></span><br><span class="line"><span class="comment">     * doFilter method have exited or after a timeout period has passed.</span></span><br><span class="line"><span class="comment">     * After the web container calls this method, it will not call the</span></span><br><span class="line"><span class="comment">     * doFilter method again on this instance of the filter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method gives the filter an opportunity to clean up any</span></span><br><span class="line"><span class="comment">     * resources that are being held (for example, memory, file handles,</span></span><br><span class="line"><span class="comment">     * threads) and make sure that any persistent state is synchronized</span></span><br><span class="line"><span class="comment">     * with the filter&#x27;s current state in memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们在初学阶段可以不用过分在意细节，上述源码的版本是3.1.0。通过上述源码我们得知，该接口中只有三个方法，分别是init初始化方法、doFilter方法(执行过滤代码的方法)、destroy销毁方法。</p><p>提示</p><blockquote><p>小伙伴们可以注意一下doFilter方法中的chain参数，稍后会讲这个参数是起什么作用的</p></blockquote><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>接下来我们需要创建Filter，创建步骤如下：</p><ol><li>实现javax.servlet.Filter接口</li><li>在doFilter()方法中执行过滤</li><li>如果满足过滤条件使用 chain.doFilter(request, response)放行</li><li>如果不满足过滤条件转发或重定向请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target01Filter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">//初始化方法可以不具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.打印一句话表明Filter执行了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器执行：Target01Filter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.检查是否满足过滤条件</span></span><br><span class="line">        <span class="comment">// 人为设定一个过滤条件：请求参数message是否等于gcc</span></span><br><span class="line">        <span class="comment">// 等于：放行</span></span><br><span class="line">        <span class="comment">// 不等于：将请求交给另一个Servlet处理</span></span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②检查请求参数是否等于monster</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;gcc&quot;</span>.equals(message)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行放行</span></span><br><span class="line">            <span class="comment">// FilterChain对象代表过滤器链</span></span><br><span class="line">            <span class="comment">// chain.doFilter(request, response)方法效果：将请求放行到下一个Filter，</span></span><br><span class="line">            <span class="comment">// 如果当前Filter已经是最后一个Filter了，那么就将请求放行到原本要访问的目标资源</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不满足过滤条件，交给另一个Servlet处理</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/SpecialServlet?method=toSpecialPage&quot;</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//销毁方法可以不具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提，我们只写上述代码过滤器是不会起作用的，要想让过滤器起作用，还需要在web.xml文件中注册该过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Target01Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Filter的友好名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target01Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Filter的全类名，便于Servlet容器创建Filter对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.gcc.filter.Target01Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Filter要拦截的目标资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定这个mapping对应的Filter名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target01Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过请求地址模式来设置要拦截的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Target01Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h3><table><thead><tr><th>生命周期阶段</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>Web应用启动时</td><td>一次</td></tr><tr><td>初始化</td><td>创建对象后</td><td>一次</td></tr><tr><td>拦截请求</td><td>接收到匹配的请求</td><td>多次</td></tr><tr><td>销毁</td><td>Web应用卸载前</td><td>一次</td></tr></tbody></table><h3 id="Filter过滤规则详述"><a href="#Filter过滤规则详述" class="headerlink" title="Filter过滤规则详述"></a>Filter过滤规则详述</h3><p>本节要探讨的是在filter-mapping中如何将Filter同它要拦截的资源关联起来。</p><h4 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h4><p>指定被拦截资源的完整路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Filter要拦截的目标资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定这个mapping对应的Filter名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target01Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过请求地址模式来设置要拦截的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Target01Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>相比较精确匹配，使用模糊匹配可以让我们创建一个Filter就能够覆盖很多目标资源，不必专门为每一个目标资源都创建Filter。</p><h5 id="前杠后星"><a href="#前杠后星" class="headerlink" title="前杠后星"></a>前杠后星</h5><p>在我们配置了url-pattern为&#x2F;user&#x2F;*之后，请求地址只要是&#x2F;user开头的那么就会被匹配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target02Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模糊匹配：前杠后星 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        /user/Target02Servlet</span></span><br><span class="line"><span class="comment">        /user/Target03Servlet</span></span><br><span class="line"><span class="comment">        /user/Target04Servlet</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>极端情况：&#x2F;*匹配所有请求</p><h5 id="前星后缀"><a href="#前星后缀" class="headerlink" title="前星后缀"></a>前星后缀</h5><p>可以匹配所有后缀为某个特定值的请求，举例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target03Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.gcc.filter.Target04Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Target03Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.png<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该过滤可以拦截所有后缀为png的请求</p><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>多个Filter的<strong>拦截范围</strong>如果存在<strong>重合部分</strong>，那么这些Filter会形成<strong>Filter链</strong>。</li><li>浏览器请求重合部分对应的目标资源时，会<strong>依次经过</strong>Filter链中的每一个Filter。</li><li>Filter链中每一个Filter执行的<strong>顺序是由web.xml中filter-mapping配置的顺序决定</strong>的。</li></ul><p><img src="%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.jpg"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>创建超链接访问一个普通的Servlet即可</li><li>创建多个Filter拦截Servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/testServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/testServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="FilterChainh%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为一个Java后端初学者，本人水平有限，只能从Filter的应用层面给出自己的见解。如果小伙伴们需要更加深入地学习Filter这个组件，建议观看源码，毕竟源码之下没有秘密，愿开源精神永存。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文参考尚硅谷的JavaWeb教程，有兴趣的朋友可以去看看（b站直接搜索即可）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h2&gt;&lt;p&gt;Filter(过滤器)是JavaWeb三大组件之一，为了后续可以更好地掌握SpringMVC框架，仔细学习一下过滤器的基础知识是很有必要的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="过滤器" scheme="https://gccforstudy.github.io/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://gccforstudy.github.io/2022/08/16/hello-world/"/>
    <id>https://gccforstudy.github.io/2022/08/16/hello-world/</id>
    <published>2022-08-16T13:35:21.740Z</published>
    <updated>2022-08-18T13:44:38.790Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
